#!/usr/bin/env ruby
#================================================================================
# Top module generator for verilog
# Written by kimu_shu
#================================================================================

topname = nil
topdesc = nil
modules = []
wires = []
force = []
params = []
prefix = {}

require 'optparse'
OptionParser.new {|opt|
	opt.on('-f WIRES') {|v|
		v.split(/[, ]/).each {|w|
			abort "Error: Illegal wire name `#{w}'" if !(w =~ /^[a-z][a-z0-9_]*$/i)
			force << w if !force.include?(w)
		}
	}
	opt.on('-n NAME') {|v| topname = v }
	opt.on('-d DESC') {|v| topdesc = v }
	opt.on('-p PREF') {|v| v = v.split("="); prefix[v[0]] = v[1] + "_" }
	opt.parse!(ARGV)
}

abort "Error: no top-name specified!" if !topname

ARGV.each {|f|
	mn = nil
	pr = nil
	mw = nil
	open(f).each_line {|line|
		if(line =~ /^\s*module\s+(\w+)\s*(#\()?/)
			abort "Error: Source file contains 2 or more modules!" if mn
			mn = $1
			pr = [] if $2
			mw = [] if !$2
			next
		elsif(!mw and line =~ /^\s*\)\s*\(/)
			mw = []
			next
		elsif(line =~ /^\s*\);/)
			pr ||= []
			break
		elsif(!mw and pr and line =~ /\s*(\w+)\s*(?:=[^,;]*)?,?/)
			pr << $1 if $1 != "parameter"
		end
		next if !(line =~ /^\s*(input|output|inout)\s+(?:\[([^:]+):([^\]]+)\]\s+)?(\w+)/)
		dir,msb,lsb,wn = [$1, $2, $3, $4]
		# STDERR.puts wn.inspect
		mw << wn
		msb.gsub!(/ /, '') if msb
		lsb.gsub!(/ /, '') if lsb
		i = wires.index {|w| w[:name] == wn }
		if(!i)
			v = {:name => wn, :msb => msb, :lsb => lsb,
				 :input => [], :output => [], :inout => []}
			v[dir.intern] << f
			wires << v
		else
			STDERR.puts "Warning: Width of `#{wn}' is mismatch" if
				wires[i][:msb] != msb or wires[i][:lsb] != lsb
			wires[i][dir.intern] << f
			abort "Error: Signal `#{wn}' has multiple outputs (#{wires[i][:output].join(",")})" if
				wires[i][:output].size > 1
		end
	}
	abort "Error: Module name is unknown for `#{f}'" if !mn
	modules << {:file => f, :name => mn, :wires => mw, :params => pr}
	params += pr
	params.uniq!
}

puts(<<EOD)
//================================================================================
// #{topname}#{topdesc ? " - #{topdesc.gsub(/\n/, "\n// ")}" : ""}
// (This module is generated by #$0)
//
// Sub-modules:
EOD
modules.each {|m| puts("//   #{m[:file]}") }
puts(<<EOD)
//================================================================================

module #{topname}
EOD
	puts(<<EOD) if params.any?
#(
	parameter
#{params.map {|p| "\t#{p}"}.join(",\n")}
)
EOD
exports = []
forced = []
wires.each {|w|
	wn = w[:name]
	w[:export] = true if w[:input].empty? or w[:output].empty? or w[:inout].any?
	if(force.include?(wn))
		forced << wn
		exports << wn
	elsif(w[:export])
		exports << wn
	end
	w[:bus] = ""
	w[:bus] = "[#{w[:msb]}:#{w[:lsb]}]" if w[:msb] and w[:lsb]
}
puts("(")
puts exports.map {|wn|
	i = wires.index {|w| w[:name] == wn }
	w = wires[i]
	dir = w[:inout].any? ? "inout" : w[:input].empty? ? "output" : "input"
	p = prefix[wn.split("_").first]
	p = "" if !p
	"\t%-6s %6s %s" % [dir, w[:bus], p + wn]
}.join(",\n")
puts(<<EOD)
);

// Wires

EOD
wires.each {|w|
	wn = w[:name]
	next if w[:export]
	puts("wire#{w[:bus] != "" ? " " : ""}#{w[:bus]} #{wn}_w;")
}
puts(<<EOD)

// Sub-module instanciations
EOD
modules.each {|m|
	puts
	puts("#{m[:name]} u_#{m[:name]}")
	puts("#(\n#{m[:params].map {|p| "\t.#{p}(#{p})"}.join(",\n")}\n)") if m[:params].any?
	puts("(")
	maxlen = m[:wires].map {|wn| wn.size }.max
	puts m[:wires].map {|wn|
		i = wires.index {|w| w[:name] == wn }
		w = wires[i]
		p = prefix[wn.split("_").first]
		p = "" if !p or !w[:export]
		"\t.%-*s (#{p+wn}#{w[:export] ? "" : "_w"})" % [maxlen, wn]
	}.join(",\n")
	puts(");")
}
puts(<<EOD) if forced.any?

// Exported signals

#{forced.map {|wn|
p = prefix[wn.split("_").first]
p = "" if !p
"assign #{p+wn} = #{wn}_w;"
}.join("\n")}
EOD
puts(<<EOD)

endmodule
EOD


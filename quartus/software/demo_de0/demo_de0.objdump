
demo_de0.elf:     file format elf32-littlenios2
demo_de0.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0f0001e8

Program Header:
    LOAD off    0x00001000 vaddr 0x0f000000 paddr 0x0f000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x0f000020 paddr 0x0f000020 align 2**12
         filesz 0x00002378 memsz 0x00002378 flags r-x
    LOAD off    0x00004000 vaddr 0x00000000 paddr 0x0f002398 align 2**12
         filesz 0x00000018 memsz 0x00000178 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  0f000000  0f000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001c8  0f000020  0f000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000020f0  0f0001e8  0f0001e8  000011e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000c0  0f0022d8  0f0022d8  000032d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000018  00000000  0f002398  00004000  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000160  00000018  0f0023b0  00004018  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  00004018  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000308  00000000  00000000  00004040  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000006d2  00000000  00000000  00004348  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000037c4  00000000  00000000  00004a1a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000158d  00000000  00000000  000081de  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00003e8f  00000000  00000000  0000976b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000688  00000000  00000000  0000d5fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00000f23  00000000  00000000  0000dc84  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00001da3  00000000  00000000  0000eba7  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  0001094c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000270  00000000  00000000  00010960  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0001240d  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  00012410  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0001241c  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0001241d  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0001241e  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  00012422  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  00012426  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000004  00000000  00000000  0001242a  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000004  00000000  00000000  0001242e  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000004  00000000  00000000  00012432  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000c  00000000  00000000  00012436  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000029  00000000  00000000  00012442  2**0
                  CONTENTS, READONLY
 29 .jdi          00004dc2  00000000  00000000  0001246b  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
0f000000 l    d  .entry	00000000 .entry
0f000020 l    d  .exceptions	00000000 .exceptions
0f0001e8 l    d  .text	00000000 .text
0f0022d8 l    d  .rodata	00000000 .rodata
00000000 l    d  .rwdata	00000000 .rwdata
00000018 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
0f000220 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 demo_de0.c
0f0000ec l     F .exceptions	00000030 frame_rate_handler
0f00011c l     F .exceptions	00000070 m2vdec_irq_handler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 diskio.c
00000000 l     O .rwdata	00000001 Stat
0000001c l     O .bss	00000004 Timer1
00000020 l     O .bss	00000004 Timer2
00000048 l     O .bss	00000018 a.1612
0f000538 l     F .text	00000038 xchg_spi
0f000570 l     F .text	000000c4 rcvr_datablock
0f000634 l     F .text	0000001c deselect
0f000650 l     F .text	00000074 select
0f0006c4 l     F .text	00000124 send_cmd
00000024 l     O .bss	00000001 CardType
00000000 l    df *ABS*	00000000 ff.c
00000028 l     O .bss	00000004 FatFs
0f000b30 l     F .text	00000054 validate
0f000bb8 l     F .text	000000e0 check_fs
0f000c98 l     F .text	00000068 move_window
0f0010b0 l     F .text	0000011c dir_sdi
0000002c l     O .bss	00000002 Fsid
00000000 l    df *ABS*	00000000 lib2-divmod.c
0f001a44 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
0f001cf8 l     F .text	00000020 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_fifo_util.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0f0021b0 l     F .text	0000003c alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 m2vdd_hx8347a.c
0f0022f4 l     O .rodata	000000a2 codes.1404
00000000 l    df *ABS*	00000000 m2vdec.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
0f001d84 g     F .text	0000002c alt_main
00000078 g     O .bss	00000100 alt_irq
0f000d00 g     F .text	00000184 get_fat
0f002090 g     F .text	00000020 altera_avalon_fifo_write_almostfull
0f002398 g       *ABS*	00000000 __flash_rwdata_start
0f0021ec g     F .text	00000028 m2vdd_hx8347a_write_reg
0f002214 g     F .text	000000b0 m2vdd_hx8347a_init
00000014 g     O .rwdata	00000004 m2vdec_0
0f0020ec g     F .text	00000094 altera_avalon_fifo_init
0f002024 g     F .text	0000004c altera_avalon_fifo_write_fifo
0f0022c4 g     F .text	00000004 m2vdec_init
0f000000 g     F .entry	0000000c __reset
0f001ee8 g     F .text	00000008 altera_avalon_fifo_read_backpressure
0f000020 g       *ABS*	00000000 __flash_exceptions_start
00000038 g     O .bss	00000004 alt_argv
00008000 g       *ABS*	00000000 _gp
0f0020d0 g     F .text	0000001c altera_avalon_fifo_clear_event
0f0008d0 g     F .text	000001e8 disk_initialize
0f001b80 g     F .text	00000008 __udivsi3
0f0004b8 g     F .text	00000018 disk_status
0f001c58 g     F .text	000000a0 alt_irq_register
00000178 g       *ABS*	00000000 __bss_end
0f001de4 g     F .text	000000ac alt_tick
00000000 g       *ABS*	00000000 __alt_mem_ram_0
0f001db0 g     F .text	00000034 alt_alarm_stop
00000030 g     O .bss	00000004 alt_irq_active
0f00018c g     F .exceptions	0000005c alt_irq_handler
0f0022c8 g     F .text	00000004 alt_dcache_flush_all
0f0020b0 g     F .text	00000020 altera_avalon_fifo_write_ienable
00000018 g       *ABS*	00000000 __ram_rwdata_end
0f001f0c g     F .text	00000008 altera_avalon_fifo_read_almostempty
0f002398 g       *ABS*	00000000 __ram_rodata_end
0f001b88 g     F .text	00000008 __umodsi3
0f00051c g     F .text	0000001c disk_inittimer
00000178 g       *ABS*	00000000 end
0f001f00 g     F .text	0000000c altera_avalon_fifo_read_event
00002000 g       *ABS*	00000000 __alt_stack_pointer
0f002180 g     F .text	00000030 alt_avalon_timer_sc_init
0f001f34 g     F .text	0000003c altera_avalon_fifo_read_fifo
0f0004d0 g     F .text	0000004c disk_timerproc
0f000b84 g     F .text	00000034 f_close
0f0001e8 g     F .text	0000003c _start
00000040 g     O .bss	00000004 _alt_tick_rate
00000018 g     O .bss	00000004 fr_flags
00000044 g     O .bss	00000004 _alt_nticks
0f001e90 g     F .text	00000038 alt_sys_init
0f000e84 g     F .text	0000022c f_read
0f001b90 g     F .text	00000038 __mulsi3
00000000 g       *ABS*	00000000 __ram_rwdata_start
0f0022d8 g       *ABS*	00000000 __ram_rodata_start
00000178 g       *ABS*	00000000 __alt_stack_base
0f001f28 g     F .text	0000000c altera_avalon_fifo_read_status
0f001ef0 g     F .text	00000008 altera_avalon_fifo_read_other_info
00000018 g       *ABS*	00000000 __bss_start
0f000224 g     F .text	00000294 main
0000003c g     O .bss	00000004 alt_envp
0f001ef8 g     F .text	00000008 altera_avalon_fifo_read_level
0f000b04 g     F .text	0000002c f_mount
0f001ac0 g     F .text	00000060 __divsi3
0f0022d8 g       *ABS*	00000000 __flash_rodata_start
00000060 g     O .bss	00000018 al_frate
0f001ec8 g     F .text	00000020 alt_irq_init
00000034 g     O .bss	00000004 alt_argc
0f000020 g       .exceptions	00000000 alt_irq_entry
00000010 g     O .rwdata	00000004 m2vdd_hx8347a_0
0f000020 g       *ABS*	00000000 __ram_exceptions_start
0f000ab8 g     F .text	0000004c clust2sect
0f001fd8 g     F .text	0000004c altera_avalon_fifo_write_other_info
00000018 g       *ABS*	00000000 _edata
00000178 g       *ABS*	00000000 _end
0f0001e8 g       *ABS*	00000000 __ram_exceptions_end
0f0011cc g     F .text	00000878 f_open
0f0022d0 g     F .text	00000008 altera_nios2_qsys_irq_init
0f00000c g       .entry	00000000 exit
0f001b20 g     F .text	00000060 __modsi3
0f001f1c g     F .text	0000000c altera_avalon_fifo_read_ienable
00002000 g       *ABS*	00000000 __alt_data_end
0f000020 g     F .exceptions	00000000 alt_exception
0f000000 g       *ABS*	00000000 __alt_mem_rom_0
0f00000c g       .entry	00000000 _exit
0f001bc8 g     F .text	00000090 alt_alarm_start
0f001f14 g     F .text	00000008 altera_avalon_fifo_read_almostfull
0f0007e8 g     F .text	000000e8 disk_read
0f001f70 g     F .text	00000068 altera_avalon_read_fifo
0f0022cc g     F .text	00000004 alt_icache_flush_all
00000004 g     O .rwdata	00000004 alt_priority_mask
0f002070 g     F .text	00000020 altera_avalon_fifo_write_almostempty
00000008 g     O .rwdata	00000008 alt_alarm_list
0f001d18 g     F .text	0000006c alt_load



Disassembly of section .entry:

0f000000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 f000000:	0043c034 	movhi	at,3840
    ori r1, r1, %lo(_start)
 f000004:	08407a14 	ori	at,at,488
    jmp r1
 f000008:	0800683a 	jmp	at

0f00000c <_exit>:
	...

Disassembly of section .exceptions:

0f000020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 f000020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 f000024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 f000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 f00002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 f000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 f000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 f000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 f00003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 f000040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 f000044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 f000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 f00004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 f000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 f000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 f000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 f00005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 f000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 f000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 f000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 f00006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 f000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 f000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 f000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 f00007c:	10000326 	beq	r2,zero,f00008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 f000080:	20000226 	beq	r4,zero,f00008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 f000084:	f00018c0 	call	f00018c <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 f000088:	00000306 	br	f000098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 f00008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 f000090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 f000094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 f000098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 f00009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 f0000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 f0000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 f0000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 f0000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 f0000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 f0000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 f0000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 f0000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 f0000c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 f0000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 f0000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 f0000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 f0000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 f0000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 f0000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 f0000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 f0000e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 f0000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 f0000e8:	ef80083a 	eret

0f0000ec <frame_rate_handler>:
	}
	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_IRQ_SEQ_MSK | M2VDEC_STATUS_IRQ_PIC_MSK);
}

static alt_u32 frame_rate_handler(void* context)
{
 f0000ec:	20800017 	ldw	r2,0(r4)
 f0000f0:	10800094 	ori	r2,r2,2
 f0000f4:	20800015 	stw	r2,0(r4)
	*((volatile int*)context) |= 2;
	//return 33;
#ifdef SIM
	return 0;
#else
	return (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 8)) ? 1000 : 33;
 f0000f8:	00840034 	movhi	r2,4096
 f0000fc:	10810004 	addi	r2,r2,1024
 f000100:	10800037 	ldwio	r2,0(r2)
 f000104:	00c0fa04 	movi	r3,1000
 f000108:	1080400c 	andi	r2,r2,256
 f00010c:	1000011e 	bne	r2,zero,f000114 <frame_rate_handler+0x28>
 f000110:	00c00844 	movi	r3,33
#endif
}
 f000114:	1805883a 	mov	r2,r3
 f000118:	f800283a 	ret

0f00011c <m2vdec_irq_handler>:

	return 0;
}

static void m2vdec_irq_handler(void* context, alt_u32 id)
{
 f00011c:	00840034 	movhi	r2,4096
 f000120:	10818004 	addi	r2,r2,1536
 f000124:	10800037 	ldwio	r2,0(r2)
 f000128:	1080040c 	andi	r2,r2,16
 f00012c:	10000426 	beq	r2,zero,f000140 <m2vdec_irq_handler+0x24>
	if(IORD_M2VDEC_STATUS(M2VDEC_0_BASE) & M2VDEC_STATUS_IRQ_PIC_MSK)
	{
		*((volatile int*)context) |= 1;
 f000130:	20800017 	ldw	r2,0(r4)
 f000134:	10800054 	ori	r2,r2,1
 f000138:	20800015 	stw	r2,0(r4)
 f00013c:	00000e06 	br	f000178 <m2vdec_irq_handler+0x5c>
		//*((volatile int*)context) |= 3;
	}
	else
	{
		alt_u32 vinfo = IORD_M2VDEC_VIDEO(M2VDEC_0_BASE);
 f000140:	00840034 	movhi	r2,4096
 f000144:	10818104 	addi	r2,r2,1540
 f000148:	10c00037 	ldwio	r3,0(r2)
		alt_u32 wd = ((vinfo & M2VDEC_VIDEO_WIDTH_MSK) >> M2VDEC_VIDEO_WIDTH_OFST) - 1;
		alt_u32 ht = ((vinfo & M2VDEC_VIDEO_HEIGHT_MSK) >> M2VDEC_VIDEO_HEIGHT_OFST) - 1;
		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, M2VDD_HX8347A_CONTROL_VIDEOWD_MSK | wd);
 f00014c:	01040034 	movhi	r4,4096
 f000150:	2101c004 	addi	r4,r4,1792
 f000154:	188fffcc 	andi	r2,r3,16383
 f000158:	10bfffc4 	addi	r2,r2,-1
 f00015c:	10880034 	orhi	r2,r2,8192
 f000160:	20800035 	stwio	r2,0(r4)
		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, M2VDD_HX8347A_CONTROL_VIDEOHT_MSK | ht);
 f000164:	1806913a 	slli	r3,r3,4
 f000168:	1806d4ba 	srli	r3,r3,18
 f00016c:	18ffffc4 	addi	r3,r3,-1
 f000170:	18c40034 	orhi	r3,r3,4096
 f000174:	20c00035 	stwio	r3,0(r4)
	}
	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_IRQ_SEQ_MSK | M2VDEC_STATUS_IRQ_PIC_MSK);
 f000178:	00c00604 	movi	r3,24
 f00017c:	00840034 	movhi	r2,4096
 f000180:	10818004 	addi	r2,r2,1536
 f000184:	10c00035 	stwio	r3,0(r2)
}
 f000188:	f800283a 	ret

0f00018c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 f00018c:	deffff04 	addi	sp,sp,-4
 f000190:	dfc00015 	stw	ra,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 f000194:	0009313a 	rdctl	r4,ipending
 f000198:	00c00044 	movi	r3,1
 f00019c:	000b883a 	mov	r5,zero
 f0001a0:	01800034 	movhi	r6,0
 f0001a4:	31801e04 	addi	r6,r6,120
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 f0001a8:	20c4703a 	and	r2,r4,r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 f0001ac:	18c7883a 	add	r3,r3,r3
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 f0001b0:	10000726 	beq	r2,zero,f0001d0 <alt_irq_handler+0x44>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
 f0001b4:	31000117 	ldw	r4,4(r6)
 f0001b8:	30800017 	ldw	r2,0(r6)
 f0001bc:	103ee83a 	callr	r2
 f0001c0:	0005313a 	rdctl	r2,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
 f0001c4:	10000526 	beq	r2,zero,f0001dc <alt_irq_handler+0x50>
 f0001c8:	1009883a 	mov	r4,r2
 f0001cc:	003ff206 	br	f000198 <alt_irq_handler+0xc>
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
      i++;
 f0001d0:	29400044 	addi	r5,r5,1
 f0001d4:	31800204 	addi	r6,r6,8
 f0001d8:	003ff306 	br	f0001a8 <alt_irq_handler+0x1c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 f0001dc:	dfc00017 	ldw	ra,0(sp)
 f0001e0:	dec00104 	addi	sp,sp,4
 f0001e4:	f800283a 	ret

Disassembly of section .text:

0f0001e8 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 f0001e8:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
 f0001ec:	dec80014 	ori	sp,sp,8192

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 f0001f0:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
 f0001f4:	d6a00014 	ori	gp,gp,32768
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 f0001f8:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
 f0001fc:	10800614 	ori	r2,r2,24

    movhi r3, %hi(__bss_end)
 f000200:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
 f000204:	18c05e14 	ori	r3,r3,376

    beq r2, r3, 1f
 f000208:	10c00326 	beq	r2,r3,f000218 <_start+0x30>

0:
    stw zero, (r2)
 f00020c:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 f000210:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 f000214:	10fffd36 	bltu	r2,r3,f00020c <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 f000218:	f001d180 	call	f001d18 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 f00021c:	f001d840 	call	f001d84 <alt_main>

0f000220 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 f000220:	003fff06 	br	f000220 <alt_after_alt_main>

0f000224 <main>:
	while(alt_nticks() < end);
#endif
}

int main()
{ 
 f000224:	defeeb04 	addi	sp,sp,-1108
 f000228:	dc011115 	stw	r16,1092(sp)
	FATFS fs;
	FIL f;
	FRESULT res;
	alt_u32 buf[512/4];

	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E0);
 f00022c:	00803804 	movi	r2,224
 f000230:	04040034 	movhi	r16,4096
 f000234:	84008004 	addi	r16,r16,512
	while(alt_nticks() < end);
#endif
}

int main()
{ 
 f000238:	dfc11415 	stw	ra,1104(sp)
 f00023c:	dc811315 	stw	r18,1100(sp)
 f000240:	dc411215 	stw	r17,1096(sp)
	FATFS fs;
	FIL f;
	FRESULT res;
	alt_u32 buf[512/4];

	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E0);
 f000244:	80800035 	stwio	r2,0(r16)
//	M2VDD_HX8347A_INIT ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x10E0);
 f000248:	00843804 	movi	r2,4320
 f00024c:	80800035 	stwio	r2,0(r16)

#ifndef M2V_FLASH_BASE
	disk_inittimer();
 f000250:	f00051c0 	call	f00051c <disk_inittimer>

	if((res = f_mount(0, &fs)) != FR_OK) while(1);
 f000254:	0009883a 	mov	r4,zero
 f000258:	d9408804 	addi	r5,sp,544
 f00025c:	f000b040 	call	f000b04 <f_mount>
 f000260:	10000126 	beq	r2,zero,f000268 <main+0x44>
 f000264:	003fff06 	br	f000264 <main+0x40>
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E1);
 f000268:	00803844 	movi	r2,225
 f00026c:	80800035 	stwio	r2,0(r16)

	if((res = f_open(&f, "test.m2v", FA_READ)) != FR_OK) while(1);
 f000270:	d9000104 	addi	r4,sp,4
 f000274:	0143c034 	movhi	r5,3840
 f000278:	2948b604 	addi	r5,r5,8920
 f00027c:	01800044 	movi	r6,1
 f000280:	f0011cc0 	call	f0011cc <f_open>
 f000284:	10000126 	beq	r2,zero,f00028c <main+0x68>
 f000288:	003fff06 	br	f000288 <main+0x64>
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E2);
 f00028c:	00803884 	movi	r2,226
 f000290:	80800035 	stwio	r2,0(r16)
#endif

	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_SRST_MSK);
 f000294:	00c02004 	movi	r3,128
 f000298:	00840034 	movhi	r2,4096
 f00029c:	10818004 	addi	r2,r2,1536
 f0002a0:	10c00035 	stwio	r3,0(r2)

	{
		// Clear display with black (0x0000)
		int pixels;
		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, 0x22 |
 f0002a4:	00c40034 	movhi	r3,4096
 f0002a8:	18c1c004 	addi	r3,r3,1792
 f0002ac:	009000b4 	movhi	r2,16386
 f0002b0:	10800884 	addi	r2,r2,34
 f0002b4:	18800035 	stwio	r2,0(r3)
 f0002b8:	0009883a 	mov	r4,zero
 f0002bc:	019000f4 	movhi	r6,16387
 f0002c0:	01400074 	movhi	r5,1
 f0002c4:	294b0004 	addi	r5,r5,11264
		for(pixels = 0; pixels < 50; pixels++)
#else
		for(pixels = 0; pixels < 320*240; pixels++)
#endif
		{
    		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE,
 f0002c8:	19800035 	stwio	r6,0(r3)
    			M2VDD_HX8347A_CONTROL_WRITE_MSK |
    			M2VDD_HX8347A_CONTROL_RESET_MSK |
    			M2VDD_HX8347A_CONTROL_RS_MSK);
    		while(IORD_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE) & 2);
 f0002cc:	18800037 	ldwio	r2,0(r3)
 f0002d0:	1080008c 	andi	r2,r2,2
 f0002d4:	103ffd1e 	bne	r2,zero,f0002cc <main+0xa8>
			M2VDD_HX8347A_CONTROL_WRITE_MSK |
			M2VDD_HX8347A_CONTROL_RESET_MSK);
#ifdef SIM
		for(pixels = 0; pixels < 50; pixels++)
#else
		for(pixels = 0; pixels < 320*240; pixels++)
 f0002d8:	21000044 	addi	r4,r4,1
 f0002dc:	217ffa1e 	bne	r4,r5,f0002c8 <main+0xa4>
    			M2VDD_HX8347A_CONTROL_RS_MSK);
    		while(IORD_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE) & 2);
		}
	}

	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, 0);
 f0002e0:	00840034 	movhi	r2,4096
 f0002e4:	10818004 	addi	r2,r2,1536
 f0002e8:	10000035 	stwio	zero,0(r2)
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E3);
 f0002ec:	04040034 	movhi	r16,4096
 f0002f0:	84008004 	addi	r16,r16,512
 f0002f4:	008038c4 	movi	r2,227
 f0002f8:	80800035 	stwio	r2,0(r16)

	fr_flags = 0;
	alt_irq_register(M2VDEC_0_IRQ, (void*)&fr_flags, m2vdec_irq_handler);
 f0002fc:	d1600604 	addi	r5,gp,-32744
 f000300:	0183c034 	movhi	r6,3840
 f000304:	31804704 	addi	r6,r6,284
 f000308:	01000144 	movi	r4,5
	}

	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, 0);
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E3);

	fr_flags = 0;
 f00030c:	d0200615 	stw	zero,-32744(gp)
	alt_irq_register(M2VDEC_0_IRQ, (void*)&fr_flags, m2vdec_irq_handler);
 f000310:	f001c580 	call	f001c58 <alt_irq_register>
	if(alt_alarm_start(&al_frate, frame_rate_handler((void*)&fr_flags), frame_rate_handler, (void*)&fr_flags) < 0)
 f000314:	d1200604 	addi	r4,gp,-32744
 f000318:	f0000ec0 	call	f0000ec <frame_rate_handler>
 f00031c:	100b883a 	mov	r5,r2
 f000320:	01000034 	movhi	r4,0
 f000324:	21001804 	addi	r4,r4,96
 f000328:	0183c034 	movhi	r6,3840
 f00032c:	31803b04 	addi	r6,r6,236
 f000330:	d1e00604 	addi	r7,gp,-32744
 f000334:	f001bc80 	call	f001bc8 <alt_alarm_start>
 f000338:	1000010e 	bge	r2,zero,f000340 <main+0x11c>
 f00033c:	003fff06 	br	f00033c <main+0x118>
	{
		while(1);
	}

	if(altera_avalon_fifo_init(FIFO_0_IN_CSR_BASE, 0, 4, FIFO_0_IN_FIFO_DEPTH - 4) != ALTERA_AVALON_FIFO_OK)
 f000340:	01040034 	movhi	r4,4096
 f000344:	21014804 	addi	r4,r4,1312
 f000348:	000b883a 	mov	r5,zero
 f00034c:	01800104 	movi	r6,4
 f000350:	01c03f04 	movi	r7,252
 f000354:	f0020ec0 	call	f0020ec <altera_avalon_fifo_init>
 f000358:	10000126 	beq	r2,zero,f000360 <main+0x13c>
 f00035c:	003fff06 	br	f00035c <main+0x138>
	{
		while(1);
	}

	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x0000);
 f000360:	80000035 	stwio	zero,0(r16)
	alt_u8 stop = 0;
#ifdef M2V_FLASH_BASE
	alt_u32* p = (alt_u32*)test_1mb_m2v;
#else
	alt_u32* p = buf;
	UINT left = 0;
 f000364:	d8000015 	stw	zero,0(sp)
 f000368:	0023883a 	mov	r17,zero
 f00036c:	0025883a 	mov	r18,zero
 f000370:	d9400804 	addi	r5,sp,32
#endif
	while(1)
	{
#ifndef M2V_FLASH_BASE
		if(left == 0)
 f000374:	d8800017 	ldw	r2,0(sp)
 f000378:	1000411e 	bne	r2,zero,f000480 <main+0x25c>
		{
			if((res = f_read(&f, buf, 512, &left)) != 0)
 f00037c:	dc000804 	addi	r16,sp,32
 f000380:	d9000104 	addi	r4,sp,4
 f000384:	800b883a 	mov	r5,r16
 f000388:	01808004 	movi	r6,512
 f00038c:	d80f883a 	mov	r7,sp
 f000390:	f000e840 	call	f000e84 <f_read>
 f000394:	1000021e 	bne	r2,zero,f0003a0 <main+0x17c>
 f000398:	800b883a 	mov	r5,r16
 f00039c:	00003806 	br	f000480 <main+0x25c>
			{
				IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0xE100);
 f0003a0:	00f84014 	movui	r3,57600
 f0003a4:	00840034 	movhi	r2,4096
 f0003a8:	10808004 	addi	r2,r2,512
 f0003ac:	10c00035 	stwio	r3,0(r2)
 f0003b0:	003fff06 	br	f0003b0 <main+0x18c>
			p = buf;
		}//-*/
#endif
		while(IORD_ALTERA_AVALON_FIFO_STATUS(FIFO_0_IN_CSR_BASE) & ALTERA_AVALON_FIFO_STATUS_F_MSK)
		{
			if(fr_flags == 3)
 f0003b4:	d0e00617 	ldw	r3,-32744(gp)
 f0003b8:	008000c4 	movi	r2,3
 f0003bc:	1880301e 	bne	r3,r2,f000480 <main+0x25c>
			{
				// Refresh display
				IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, M2VDD_HX8347A_CONTROL_START_MSK);
 f0003c0:	00c40034 	movhi	r3,4096
 f0003c4:	18c1c004 	addi	r3,r3,1792
 f0003c8:	00a00034 	movhi	r2,32768
 f0003cc:	18800035 	stwio	r2,0(r3)
				while(IORD_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE) & 1);
 f0003d0:	18800037 	ldwio	r2,0(r3)
 f0003d4:	1080004c 	andi	r2,r2,1
 f0003d8:	103ffd1e 	bne	r2,zero,f0003d0 <main+0x1ac>

#ifndef SIM
				if((alt_u16)stop == (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & 0xff))
 f0003dc:	01040034 	movhi	r4,4096
 f0003e0:	21010004 	addi	r4,r4,1024
 f0003e4:	20800037 	ldwio	r2,0(r4)
 f0003e8:	10803fcc 	andi	r2,r2,255
 f0003ec:	90c03fcc 	andi	r3,r18,255
 f0003f0:	1880191e 	bne	r3,r2,f000458 <main+0x234>
 f0003f4:	2007883a 	mov	r3,r4
				{
					while( (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 11)));
 f0003f8:	18800037 	ldwio	r2,0(r3)
 f0003fc:	1082000c 	andi	r2,r2,2048
 f000400:	103ffd1e 	bne	r2,zero,f0003f8 <main+0x1d4>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 f000404:	00800034 	movhi	r2,0
 f000408:	10801104 	addi	r2,r2,68
 f00040c:	10c00017 	ldw	r3,0(r2)
 f000410:	1009883a 	mov	r4,r2
//M2VDD_HX8347A_INSTANCE ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);

static void delay(int ms)
{
#ifndef SIM
	int end = alt_nticks() + ms + 1;
 f000414:	18c007c4 	addi	r3,r3,31
 f000418:	20800017 	ldw	r2,0(r4)
	while(alt_nticks() < end);
 f00041c:	10fffe36 	bltu	r2,r3,f000418 <main+0x1f4>
 f000420:	00c40034 	movhi	r3,4096
 f000424:	18c10004 	addi	r3,r3,1024
#ifndef SIM
				if((alt_u16)stop == (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & 0xff))
				{
					while( (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 11)));
					delay(30);
					while(!(IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 11)));
 f000428:	18800037 	ldwio	r2,0(r3)
 f00042c:	1082000c 	andi	r2,r2,2048
 f000430:	103ffd26 	beq	r2,zero,f000428 <main+0x204>
 f000434:	00800034 	movhi	r2,0
 f000438:	10801104 	addi	r2,r2,68
 f00043c:	10c00017 	ldw	r3,0(r2)
 f000440:	1009883a 	mov	r4,r2
//M2VDD_HX8347A_INSTANCE ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);

static void delay(int ms)
{
#ifndef SIM
	int end = alt_nticks() + ms + 1;
 f000444:	18c007c4 	addi	r3,r3,31
 f000448:	20800017 	ldw	r2,0(r4)
	while(alt_nticks() < end);
 f00044c:	10fffe36 	bltu	r2,r3,f000448 <main+0x224>
 f000450:	0025883a 	mov	r18,zero
 f000454:	00000106 	br	f00045c <main+0x238>
					delay(30);
					stop = 0;
				}
				else
				{
					++stop;
 f000458:	94800044 	addi	r18,r18,1
				}
#endif

				fr_flags = 0;
				IOWR_32DIRECT(HEXDISP_0_BASE, 0, ++frames);
 f00045c:	8c400044 	addi	r17,r17,1
 f000460:	88ffffcc 	andi	r3,r17,65535
 f000464:	00840034 	movhi	r2,4096
 f000468:	10808004 	addi	r2,r2,512
				{
					++stop;
				}
#endif

				fr_flags = 0;
 f00046c:	d0200615 	stw	zero,-32744(gp)
				IOWR_32DIRECT(HEXDISP_0_BASE, 0, ++frames);
 f000470:	10c00035 	stwio	r3,0(r2)

				// Resume decoding
				IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_PAUSE_MSK);
 f000474:	00c00804 	movi	r3,32
 f000478:	10810004 	addi	r2,r2,1024
 f00047c:	10c00035 	stwio	r3,0(r2)
				while(1);
			}
			p = buf;
		}//-*/
#endif
		while(IORD_ALTERA_AVALON_FIFO_STATUS(FIFO_0_IN_CSR_BASE) & ALTERA_AVALON_FIFO_STATUS_F_MSK)
 f000480:	00840034 	movhi	r2,4096
 f000484:	10814904 	addi	r2,r2,1316
 f000488:	10800037 	ldwio	r2,0(r2)
 f00048c:	1080004c 	andi	r2,r2,1
 f000490:	103fc81e 	bne	r2,zero,f0003b4 <main+0x190>

				// Resume decoding
				IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_PAUSE_MSK);
			}
		}
		IOWR_ALTERA_AVALON_FIFO_DATA(FIFO_0_IN_BASE, *p++);
 f000494:	28c00017 	ldw	r3,0(r5)
 f000498:	00840034 	movhi	r2,4096
 f00049c:	10814004 	addi	r2,r2,1280
 f0004a0:	29400104 	addi	r5,r5,4
 f0004a4:	10c00035 	stwio	r3,0(r2)
#ifndef M2V_FLASH_BASE
		left -= 4;
 f0004a8:	d8800017 	ldw	r2,0(sp)
 f0004ac:	10bfff04 	addi	r2,r2,-4
 f0004b0:	d8800015 	stw	r2,0(sp)
 f0004b4:	003faf06 	br	f000374 <main+0x150>

0f0004b8 <disk_status>:

DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0) */
)
{
	if (drv) return STA_NOINIT;		/* Supports only drive 0 */
 f0004b8:	21003fcc 	andi	r4,r4,255
 f0004bc:	00800044 	movi	r2,1
 f0004c0:	2000021e 	bne	r4,zero,f0004cc <disk_status+0x14>

	return Stat;	/* Return disk status */
 f0004c4:	d0a00003 	ldbu	r2,-32768(gp)
 f0004c8:	10803fcc 	andi	r2,r2,255
}
 f0004cc:	f800283a 	ret

0f0004d0 <disk_timerproc>:
alt_u32 disk_timerproc(void* context)
{
	WORD n;
	BYTE s;

	n = Timer1;						/* 1kHz decrement timer stopped at 0 */
 f0004d0:	d0e00717 	ldw	r3,-32740(gp)
		s &= ~STA_NODISK;
	else		/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
	Stat = s;
	return 1;
}
 f0004d4:	00800044 	movi	r2,1
{
	WORD n;
	BYTE s;

	n = Timer1;						/* 1kHz decrement timer stopped at 0 */
	if (n) Timer1 = --n;
 f0004d8:	193fffc4 	addi	r4,r3,-1
 f0004dc:	18ffffcc 	andi	r3,r3,65535
 f0004e0:	213fffcc 	andi	r4,r4,65535
 f0004e4:	18000126 	beq	r3,zero,f0004ec <disk_timerproc+0x1c>
 f0004e8:	d1200715 	stw	r4,-32740(gp)
	n = Timer2;
 f0004ec:	d0e00817 	ldw	r3,-32736(gp)
	if (n) Timer2 = --n;
 f0004f0:	193fffc4 	addi	r4,r3,-1
 f0004f4:	18ffffcc 	andi	r3,r3,65535
 f0004f8:	213fffcc 	andi	r4,r4,65535
 f0004fc:	18000126 	beq	r3,zero,f000504 <disk_timerproc+0x34>
 f000500:	d1200815 	stw	r4,-32736(gp)

	s = Stat;
 f000504:	d0e00003 	ldbu	r3,-32768(gp)
	if (WP)		/* Write protected */
		s |= STA_PROTECT;
	else		/* Write enabled */
		s &= ~STA_PROTECT;
	if (INS)	/* Card is in socket */
		s &= ~STA_NODISK;
 f000508:	013fff44 	movi	r4,-3
	n = Timer2;
	if (n) Timer2 = --n;

	s = Stat;
	if (WP)		/* Write protected */
		s |= STA_PROTECT;
 f00050c:	18c00114 	ori	r3,r3,4
	else		/* Write enabled */
		s &= ~STA_PROTECT;
	if (INS)	/* Card is in socket */
		s &= ~STA_NODISK;
 f000510:	1906703a 	and	r3,r3,r4
	else		/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
	Stat = s;
 f000514:	d0e00005 	stb	r3,-32768(gp)
	return 1;
}
 f000518:	f800283a 	ret

0f00051c <disk_inittimer>:

void disk_inittimer()
{
	static alt_alarm a;
	alt_alarm_start(&a, 1, disk_timerproc, NULL);
 f00051c:	01000034 	movhi	r4,0
 f000520:	21001204 	addi	r4,r4,72
 f000524:	01400044 	movi	r5,1
 f000528:	0183c034 	movhi	r6,3840
 f00052c:	31813404 	addi	r6,r6,1232
 f000530:	000f883a 	mov	r7,zero
 f000534:	f001bc81 	jmpi	f001bc8 <alt_alarm_start>

0f000538 <xchg_spi>:
static
BYTE xchg_spi (
	BYTE dat	/* Data to send */
)
{
	IOWR_ALTERA_AVALON_SPI_TXDATA(SPI_0_BASE, dat);
 f000538:	21003fcc 	andi	r4,r4,255
 f00053c:	00840034 	movhi	r2,4096
 f000540:	1080c104 	addi	r2,r2,772
 f000544:	11000035 	stwio	r4,0(r2)
 f000548:	00c40034 	movhi	r3,4096
 f00054c:	18c0c204 	addi	r3,r3,776
	while (!(
 f000550:	18800037 	ldwio	r2,0(r3)
 f000554:	1080200c 	andi	r2,r2,128
 f000558:	103ffd26 	beq	r2,zero,f000550 <xchg_spi+0x18>
			IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) &
			ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) ;
	return IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE);
 f00055c:	00840034 	movhi	r2,4096
 f000560:	1080c004 	addi	r2,r2,768
 f000564:	10800037 	ldwio	r2,0(r2)
}
 f000568:	10803fcc 	andi	r2,r2,255
 f00056c:	f800283a 	ret

0f000570 <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Error */
	BYTE *buff,			/* Data buffer */
	UINT btr			/* Data block length (byte) */
)
{
 f000570:	defffc04 	addi	sp,sp,-16
	BYTE token;


	Timer1 = 200;
 f000574:	00803204 	movi	r2,200
static
int rcvr_datablock (	/* 1:OK, 0:Error */
	BYTE *buff,			/* Data buffer */
	UINT btr			/* Data block length (byte) */
)
{
 f000578:	dc800215 	stw	r18,8(sp)
 f00057c:	dc400115 	stw	r17,4(sp)
 f000580:	dfc00315 	stw	ra,12(sp)
 f000584:	dc000015 	stw	r16,0(sp)
	BYTE token;


	Timer1 = 200;
 f000588:	d0a00715 	stw	r2,-32740(gp)
static
int rcvr_datablock (	/* 1:OK, 0:Error */
	BYTE *buff,			/* Data buffer */
	UINT btr			/* Data block length (byte) */
)
{
 f00058c:	2025883a 	mov	r18,r4
 f000590:	2823883a 	mov	r17,r5
	BYTE token;


	Timer1 = 200;
	do {							/* Wait for DataStart token in timeout of 200ms */
		token = xchg_spi(0xff);
 f000594:	04003fc4 	movi	r16,255
 f000598:	8009883a 	mov	r4,r16
 f00059c:	f0005380 	call	f000538 <xchg_spi>
		/* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */
	} while ((token == 0xFF) && Timer1);
 f0005a0:	10c03fcc 	andi	r3,r2,255
 f0005a4:	1c00031e 	bne	r3,r16,f0005b4 <rcvr_datablock+0x44>
 f0005a8:	d0a00717 	ldw	r2,-32740(gp)
 f0005ac:	10001a26 	beq	r2,zero,f000618 <rcvr_datablock+0xa8>
 f0005b0:	003ff806 	br	f000594 <rcvr_datablock+0x24>
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
 f0005b4:	00803f84 	movi	r2,254
 f0005b8:	1880171e 	bne	r3,r2,f000618 <rcvr_datablock+0xa8>
 f0005bc:	8009883a 	mov	r4,r16
 f0005c0:	01840034 	movhi	r6,4096
 f0005c4:	3180c104 	addi	r6,r6,772
 f0005c8:	01440034 	movhi	r5,4096
 f0005cc:	2940c004 	addi	r5,r5,768
 f0005d0:	00000a06 	br	f0005fc <rcvr_datablock+0x8c>
	UINT btr		/* Number of bytes to receive (16, 64 or 512) */
)
{
	while(btr > 0)
	{
		IOWR_ALTERA_AVALON_SPI_TXDATA(SPI_0_BASE, 0xff);
 f0005d4:	31000035 	stwio	r4,0(r6)
 f0005d8:	00c40034 	movhi	r3,4096
 f0005dc:	18c0c204 	addi	r3,r3,776
		while (!(
 f0005e0:	18800037 	ldwio	r2,0(r3)
 f0005e4:	1080200c 	andi	r2,r2,128
 f0005e8:	103ffd26 	beq	r2,zero,f0005e0 <rcvr_datablock+0x70>
				IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) &
				ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) ;
		*buff++ = IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE);
 f0005ec:	28800037 	ldwio	r2,0(r5)
 f0005f0:	90800005 	stb	r2,0(r18)
		--btr;
 f0005f4:	8c7fffc4 	addi	r17,r17,-1
	{
		IOWR_ALTERA_AVALON_SPI_TXDATA(SPI_0_BASE, 0xff);
		while (!(
				IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) &
				ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) ;
		*buff++ = IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE);
 f0005f8:	94800044 	addi	r18,r18,1
void rcvr_spi_multi (
	BYTE *buff,		/* Pointer to data buffer */
	UINT btr		/* Number of bytes to receive (16, 64 or 512) */
)
{
	while(btr > 0)
 f0005fc:	883ff51e 	bne	r17,zero,f0005d4 <rcvr_datablock+0x64>
		/* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */
	} while ((token == 0xFF) && Timer1);
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */

	rcvr_spi_multi(buff, btr);		/* Store trailing data to the buffer */
	xchg_spi(0xFF); xchg_spi(0xFF);			/* Discard CRC */
 f000600:	01003fc4 	movi	r4,255
 f000604:	f0005380 	call	f000538 <xchg_spi>
 f000608:	01003fc4 	movi	r4,255
 f00060c:	f0005380 	call	f000538 <xchg_spi>
 f000610:	00800044 	movi	r2,1
 f000614:	00000106 	br	f00061c <rcvr_datablock+0xac>

	return 1;						/* Function succeeded */
 f000618:	0005883a 	mov	r2,zero
}
 f00061c:	dfc00317 	ldw	ra,12(sp)
 f000620:	dc800217 	ldw	r18,8(sp)
 f000624:	dc400117 	ldw	r17,4(sp)
 f000628:	dc000017 	ldw	r16,0(sp)
 f00062c:	dec00404 	addi	sp,sp,16
 f000630:	f800283a 	ret

0f000634 <deselect>:

static
void deselect (void)
{
	// Negate SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 0);
 f000634:	00840034 	movhi	r2,4096
 f000638:	1080c504 	addi	r2,r2,788
 f00063c:	10000035 	stwio	zero,0(r2)
	IOWR_ALTERA_AVALON_SPI_CONTROL(SPI_0_BASE, 0);
 f000640:	10bffe04 	addi	r2,r2,-8
 f000644:	10000035 	stwio	zero,0(r2)
	xchg_spi(0xFF);
 f000648:	01003fc4 	movi	r4,255
 f00064c:	f0005381 	jmpi	f000538 <xchg_spi>

0f000650 <select>:
/* Select card and wait for ready                                        */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
 f000650:	defffe04 	addi	sp,sp,-8
	// Assert SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 1);
 f000654:	00c00044 	movi	r3,1
 f000658:	00840034 	movhi	r2,4096
 f00065c:	1080c504 	addi	r2,r2,788
/* Select card and wait for ready                                        */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
 f000660:	dfc00115 	stw	ra,4(sp)
 f000664:	dc000015 	stw	r16,0(sp)
	// Assert SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 1);
 f000668:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_SPI_CONTROL(SPI_0_BASE, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 f00066c:	00c10004 	movi	r3,1024
 f000670:	10bffe04 	addi	r2,r2,-8
 f000674:	10c00035 	stwio	r3,0(r2)
	xchg_spi(0xFF);
 f000678:	01003fc4 	movi	r4,255
 f00067c:	f0005380 	call	f000538 <xchg_spi>
)
{
	BYTE d;


	Timer2 = wt;
 f000680:	00807d04 	movi	r2,500
 f000684:	d0a00815 	stw	r2,-32736(gp)
	do {
		d = xchg_spi(0xff);
 f000688:	04003fc4 	movi	r16,255
 f00068c:	8009883a 	mov	r4,r16
 f000690:	f0005380 	call	f000538 <xchg_spi>
		/* This loop takes a time. Insert rot_rdq() here for multitask envilonment. */
	} while (d != 0xFF && Timer2);	/* Wait for card goes ready or timeout */
 f000694:	10803fcc 	andi	r2,r2,255
 f000698:	14000526 	beq	r2,r16,f0006b0 <select+0x60>
 f00069c:	d0a00817 	ldw	r2,-32736(gp)
 f0006a0:	103ff91e 	bne	r2,zero,f000688 <select+0x38>
	// Assert SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 1);
	IOWR_ALTERA_AVALON_SPI_CONTROL(SPI_0_BASE, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
	xchg_spi(0xFF);
	if (wait_ready(500)) return 1;	/* OK */
	deselect();
 f0006a4:	f0006340 	call	f000634 <deselect>
 f0006a8:	0005883a 	mov	r2,zero
 f0006ac:	00000106 	br	f0006b4 <select+0x64>
	return 0;	/* Timeout */
 f0006b0:	00800044 	movi	r2,1
}
 f0006b4:	dfc00117 	ldw	ra,4(sp)
 f0006b8:	dc000017 	ldw	r16,0(sp)
 f0006bc:	dec00204 	addi	sp,sp,8
 f0006c0:	f800283a 	ret

0f0006c4 <send_cmd>:
)
{
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 f0006c4:	20803fcc 	andi	r2,r4,255
 f0006c8:	1080201c 	xori	r2,r2,128
static
BYTE send_cmd (		/* Return value: R1 resp (bit7==1:Failed to send) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
 f0006cc:	defffc04 	addi	sp,sp,-16
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 f0006d0:	10bfe004 	addi	r2,r2,-128
static
BYTE send_cmd (		/* Return value: R1 resp (bit7==1:Failed to send) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
 f0006d4:	dc800215 	stw	r18,8(sp)
 f0006d8:	dc400115 	stw	r17,4(sp)
 f0006dc:	dc000015 	stw	r16,0(sp)
 f0006e0:	dfc00315 	stw	ra,12(sp)
 f0006e4:	2025883a 	mov	r18,r4
 f0006e8:	2021883a 	mov	r16,r4
 f0006ec:	2823883a 	mov	r17,r5
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 f0006f0:	10000a0e 	bge	r2,zero,f00071c <send_cmd+0x58>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
 f0006f4:	01000dc4 	movi	r4,55
 f0006f8:	000b883a 	mov	r5,zero
 f0006fc:	f0006c40 	call	f0006c4 <send_cmd>
		if (res > 1) return res;
 f000700:	10c03fcc 	andi	r3,r2,255
 f000704:	00800044 	movi	r2,1
 f000708:	10c00236 	bltu	r2,r3,f000714 <send_cmd+0x50>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
		cmd &= 0x7F;
 f00070c:	94001fcc 	andi	r16,r18,127
 f000710:	00000206 	br	f00071c <send_cmd+0x58>
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
 f000714:	1805883a 	mov	r2,r3
 f000718:	00002d06 	br	f0007d0 <send_cmd+0x10c>
	}

	/* Select card */
	deselect();
 f00071c:	f0006340 	call	f000634 <deselect>
	if (!select()) return 0xFF;
 f000720:	f0006500 	call	f000650 <select>
 f000724:	1000021e 	bne	r2,zero,f000730 <send_cmd+0x6c>
 f000728:	00803fc4 	movi	r2,255
 f00072c:	00002806 	br	f0007d0 <send_cmd+0x10c>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + command index */
 f000730:	81001014 	ori	r4,r16,64
 f000734:	21003fcc 	andi	r4,r4,255
 f000738:	f0005380 	call	f000538 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
 f00073c:	8808d63a 	srli	r4,r17,24
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 f000740:	84003fcc 	andi	r16,r16,255
	deselect();
	if (!select()) return 0xFF;

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + command index */
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
 f000744:	f0005380 	call	f000538 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
 f000748:	8808d43a 	srli	r4,r17,16
 f00074c:	21003fcc 	andi	r4,r4,255
 f000750:	f0005380 	call	f000538 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
 f000754:	8808d23a 	srli	r4,r17,8
 f000758:	21003fcc 	andi	r4,r4,255
 f00075c:	f0005380 	call	f000538 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
 f000760:	89003fcc 	andi	r4,r17,255
 f000764:	f0005380 	call	f000538 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 f000768:	80001526 	beq	r16,zero,f0007c0 <send_cmd+0xfc>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 f00076c:	00800204 	movi	r2,8
 f000770:	80801526 	beq	r16,r2,f0007c8 <send_cmd+0x104>
	xchg_spi(n);
 f000774:	01000044 	movi	r4,1
 f000778:	f0005380 	call	f000538 <xchg_spi>

	/* Receive command resp */
	if (cmd == CMD12) xchg_spi(0xFF);	/* Diacard following one byte when CMD12 */
 f00077c:	00800304 	movi	r2,12
 f000780:	8080021e 	bne	r16,r2,f00078c <send_cmd+0xc8>
 f000784:	01003fc4 	movi	r4,255
 f000788:	f0005380 	call	f000538 <xchg_spi>
 f00078c:	04000284 	movi	r16,10
	n = 10;								/* Wait for response (10 bytes max) */
	do
		res = xchg_spi(0xFF);
 f000790:	01003fc4 	movi	r4,255
 f000794:	f0005380 	call	f000538 <xchg_spi>
 f000798:	1007883a 	mov	r3,r2
	while ((res & 0x80) && --n);
 f00079c:	18803fcc 	andi	r2,r3,255
 f0007a0:	1080201c 	xori	r2,r2,128
 f0007a4:	843fffc4 	addi	r16,r16,-1
 f0007a8:	10bfe004 	addi	r2,r2,-128
 f0007ac:	81003fcc 	andi	r4,r16,255
 f0007b0:	1000010e 	bge	r2,zero,f0007b8 <send_cmd+0xf4>
 f0007b4:	203ff61e 	bne	r4,zero,f000790 <send_cmd+0xcc>

	return res;							/* Return received response */
 f0007b8:	18803fcc 	andi	r2,r3,255
 f0007bc:	00000406 	br	f0007d0 <send_cmd+0x10c>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
	xchg_spi(n);
 f0007c0:	01002544 	movi	r4,149
 f0007c4:	003ff006 	br	f000788 <send_cmd+0xc4>
 f0007c8:	010021c4 	movi	r4,135
 f0007cc:	003fee06 	br	f000788 <send_cmd+0xc4>
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;							/* Return received response */
}
 f0007d0:	dfc00317 	ldw	ra,12(sp)
 f0007d4:	dc800217 	ldw	r18,8(sp)
 f0007d8:	dc400117 	ldw	r17,4(sp)
 f0007dc:	dc000017 	ldw	r16,0(sp)
 f0007e0:	dec00404 	addi	sp,sp,16
 f0007e4:	f800283a 	ret

0f0007e8 <disk_read>:
	BYTE drv,		/* Physical drive number (0) */
	BYTE *buff,		/* Pointer to the data buffer to store read data */
	DWORD sector,	/* Start sector number (LBA) */
	BYTE count		/* Number of sectors to read (1..128) */
)
{
 f0007e8:	defffd04 	addi	sp,sp,-12
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 f0007ec:	21003fcc 	andi	r4,r4,255
	BYTE drv,		/* Physical drive number (0) */
	BYTE *buff,		/* Pointer to the data buffer to store read data */
	DWORD sector,	/* Start sector number (LBA) */
	BYTE count		/* Number of sectors to read (1..128) */
)
{
 f0007f0:	dc400115 	stw	r17,4(sp)
 f0007f4:	dc000015 	stw	r16,0(sp)
 f0007f8:	2823883a 	mov	r17,r5
 f0007fc:	dfc00215 	stw	ra,8(sp)
 f000800:	300b883a 	mov	r5,r6
 f000804:	3821883a 	mov	r16,r7
	if (drv || !count) return RES_PARERR;		/* Check parameter */
 f000808:	20002b1e 	bne	r4,zero,f0008b8 <disk_read+0xd0>
 f00080c:	38c03fcc 	andi	r3,r7,255
 f000810:	18002926 	beq	r3,zero,f0008b8 <disk_read+0xd0>
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 f000814:	d0a00003 	ldbu	r2,-32768(gp)
 f000818:	1080004c 	andi	r2,r2,1
 f00081c:	1005003a 	cmpeq	r2,r2,zero
 f000820:	1000021e 	bne	r2,zero,f00082c <disk_read+0x44>
 f000824:	008000c4 	movi	r2,3
 f000828:	00002406 	br	f0008bc <disk_read+0xd4>

	if (!(CardType & CT_BLOCK)) sector *= 512;	/* LBA ot BA conversion (byte addressing cards) */
 f00082c:	d0a00903 	ldbu	r2,-32732(gp)
 f000830:	1080020c 	andi	r2,r2,8
 f000834:	1000011e 	bne	r2,zero,f00083c <disk_read+0x54>
 f000838:	300a927a 	slli	r5,r6,9

	if (count == 1) {	/* Single sector read */
 f00083c:	00800044 	movi	r2,1
 f000840:	18800a1e 	bne	r3,r2,f00086c <disk_read+0x84>
		if ((send_cmd(CMD17, sector) == 0)	/* READ_SINGLE_BLOCK */
 f000844:	01000444 	movi	r4,17
 f000848:	f0006c40 	call	f0006c4 <send_cmd>
 f00084c:	10803fcc 	andi	r2,r2,255
 f000850:	1000151e 	bne	r2,zero,f0008a8 <disk_read+0xc0>
 f000854:	8809883a 	mov	r4,r17
 f000858:	01408004 	movi	r5,512
 f00085c:	f0005700 	call	f000570 <rcvr_datablock>
 f000860:	10001126 	beq	r2,zero,f0008a8 <disk_read+0xc0>
 f000864:	0021883a 	mov	r16,zero
 f000868:	00000f06 	br	f0008a8 <disk_read+0xc0>
			&& rcvr_datablock(buff, 512))
			count = 0;
	}
	else {				/* Multiple sector read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
 f00086c:	01000484 	movi	r4,18
 f000870:	f0006c40 	call	f0006c4 <send_cmd>
 f000874:	10803fcc 	andi	r2,r2,255
 f000878:	10000b1e 	bne	r2,zero,f0008a8 <disk_read+0xc0>
			do {
				if (!rcvr_datablock(buff, 512)) break;
 f00087c:	8809883a 	mov	r4,r17
 f000880:	01408004 	movi	r5,512
				buff += 512;
 f000884:	8c408004 	addi	r17,r17,512
			count = 0;
	}
	else {				/* Multiple sector read */
		if (send_cmd(CMD18, sector) == 0) {	/* READ_MULTIPLE_BLOCK */
			do {
				if (!rcvr_datablock(buff, 512)) break;
 f000888:	f0005700 	call	f000570 <rcvr_datablock>
 f00088c:	10000326 	beq	r2,zero,f00089c <disk_read+0xb4>
				buff += 512;
			} while (--count);
 f000890:	843fffc4 	addi	r16,r16,-1
 f000894:	80803fcc 	andi	r2,r16,255
 f000898:	103ff81e 	bne	r2,zero,f00087c <disk_read+0x94>
			send_cmd(CMD12, 0);				/* STOP_TRANSMISSION */
 f00089c:	01000304 	movi	r4,12
 f0008a0:	000b883a 	mov	r5,zero
 f0008a4:	f0006c40 	call	f0006c4 <send_cmd>
		}
	}
	deselect();
 f0008a8:	f0006340 	call	f000634 <deselect>

	return count ? RES_ERROR : RES_OK;	/* Return result */
 f0008ac:	80803fcc 	andi	r2,r16,255
 f0008b0:	1004c03a 	cmpne	r2,r2,zero
 f0008b4:	00000106 	br	f0008bc <disk_read+0xd4>
 f0008b8:	00800104 	movi	r2,4
}
 f0008bc:	dfc00217 	ldw	ra,8(sp)
 f0008c0:	dc400117 	ldw	r17,4(sp)
 f0008c4:	dc000017 	ldw	r16,0(sp)
 f0008c8:	dec00304 	addi	sp,sp,12
 f0008cc:	f800283a 	ret

0f0008d0 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive number (0) */
)
{
 f0008d0:	defffc04 	addi	sp,sp,-16
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only drive 0 */
 f0008d4:	21003fcc 	andi	r4,r4,255
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive number (0) */
)
{
 f0008d8:	dfc00315 	stw	ra,12(sp)
 f0008dc:	dc400215 	stw	r17,8(sp)
 f0008e0:	dc000115 	stw	r16,4(sp)
	BYTE n, cmd, ty, ocr[4];


	if (drv) return STA_NOINIT;			/* Supports only drive 0 */
 f0008e4:	20000226 	beq	r4,zero,f0008f0 <disk_initialize+0x20>
 f0008e8:	00800044 	movi	r2,1
 f0008ec:	00006d06 	br	f000aa4 <disk_initialize+0x1d4>
	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the soket? */
 f0008f0:	d0a00003 	ldbu	r2,-32768(gp)
 f0008f4:	1080008c 	andi	r2,r2,2
 f0008f8:	1000601e 	bne	r2,zero,f000a7c <disk_initialize+0x1ac>
/*-----------------------------------------------------------------------*/

static
void power_on (void)
{
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 0);
 f0008fc:	00840034 	movhi	r2,4096
 f000900:	1080c504 	addi	r2,r2,788
 f000904:	10000035 	stwio	zero,0(r2)
 f000908:	04000284 	movi	r16,10
	if (drv) return STA_NOINIT;			/* Supports only drive 0 */
	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the soket? */

	power_on();							/* Initialize SPI */
	FCLK_SLOW();
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */
 f00090c:	01003fc4 	movi	r4,255
 f000910:	843fffc4 	addi	r16,r16,-1
 f000914:	f0005380 	call	f000538 <xchg_spi>
 f000918:	80803fcc 	andi	r2,r16,255
 f00091c:	103ffb1e 	bne	r2,zero,f00090c <disk_initialize+0x3c>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Put the card SPI/Idle state */
 f000920:	0009883a 	mov	r4,zero
 f000924:	000b883a 	mov	r5,zero
 f000928:	f0006c40 	call	f0006c4 <send_cmd>
 f00092c:	14003fcc 	andi	r16,r2,255
 f000930:	00800044 	movi	r2,1
 f000934:	8080581e 	bne	r16,r2,f000a98 <disk_initialize+0x1c8>
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
 f000938:	0080fa04 	movi	r2,1000
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 f00093c:	01000204 	movi	r4,8
 f000940:	01406a84 	movi	r5,426
	FCLK_SLOW();
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Put the card SPI/Idle state */
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
 f000944:	d0a00715 	stw	r2,-32740(gp)
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 f000948:	f0006c40 	call	f0006c4 <send_cmd>
 f00094c:	10803fcc 	andi	r2,r2,255
 f000950:	1400271e 	bne	r2,r16,f0009f0 <disk_initialize+0x120>
 f000954:	d821883a 	mov	r16,sp
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);	/* Get 32 bit return value of R7 resp */
 f000958:	01003fc4 	movi	r4,255
 f00095c:	f0005380 	call	f000538 <xchg_spi>
 f000960:	80800005 	stb	r2,0(r16)
 f000964:	84000044 	addi	r16,r16,1
 f000968:	d8800104 	addi	r2,sp,4
 f00096c:	80bffa1e 	bne	r16,r2,f000958 <disk_initialize+0x88>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Is the card supports vcc of 2.7-3.6V? */
 f000970:	d8c00083 	ldbu	r3,2(sp)
 f000974:	00800044 	movi	r2,1
 f000978:	1880471e 	bne	r3,r2,f000a98 <disk_initialize+0x1c8>
 f00097c:	d8c000c3 	ldbu	r3,3(sp)
 f000980:	00802a84 	movi	r2,170
 f000984:	1880441e 	bne	r3,r2,f000a98 <disk_initialize+0x1c8>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
 f000988:	d0a00717 	ldw	r2,-32740(gp)
 f00098c:	01002a44 	movi	r4,169
 f000990:	01500034 	movhi	r5,16384
 f000994:	10000326 	beq	r2,zero,f0009a4 <disk_initialize+0xd4>
 f000998:	f0006c40 	call	f0006c4 <send_cmd>
 f00099c:	10803fcc 	andi	r2,r2,255
 f0009a0:	103ff91e 	bne	r2,zero,f000988 <disk_initialize+0xb8>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 f0009a4:	d0a00717 	ldw	r2,-32740(gp)
 f0009a8:	10003b26 	beq	r2,zero,f000a98 <disk_initialize+0x1c8>
 f0009ac:	01000e84 	movi	r4,58
 f0009b0:	000b883a 	mov	r5,zero
 f0009b4:	f0006c40 	call	f0006c4 <send_cmd>
 f0009b8:	10803fcc 	andi	r2,r2,255
 f0009bc:	1000361e 	bne	r2,zero,f000a98 <disk_initialize+0x1c8>
 f0009c0:	d821883a 	mov	r16,sp
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
 f0009c4:	01003fc4 	movi	r4,255
 f0009c8:	f0005380 	call	f000538 <xchg_spi>
 f0009cc:	80800005 	stb	r2,0(r16)
 f0009d0:	84000044 	addi	r16,r16,1
 f0009d4:	d8800104 	addi	r2,sp,4
 f0009d8:	80bffa1e 	bne	r16,r2,f0009c4 <disk_initialize+0xf4>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* Card id SDv2 */
 f0009dc:	d8800003 	ldbu	r2,0(sp)
 f0009e0:	1080100c 	andi	r2,r2,64
 f0009e4:	10002826 	beq	r2,zero,f000a88 <disk_initialize+0x1b8>
 f0009e8:	00800304 	movi	r2,12
 f0009ec:	00002706 	br	f000a8c <disk_initialize+0x1bc>
				}
			}
		} else {	/* Not SDv2 card */
			if (send_cmd(ACMD41, 0) <= 1) 	{	/* SDv1 or MMC? */
 f0009f0:	01002a44 	movi	r4,169
 f0009f4:	000b883a 	mov	r5,zero
 f0009f8:	f0006c40 	call	f0006c4 <send_cmd>
 f0009fc:	10803fcc 	andi	r2,r2,255
 f000a00:	80800336 	bltu	r16,r2,f000a10 <disk_initialize+0x140>
 f000a04:	047fea44 	movi	r17,-87
 f000a08:	04000084 	movi	r16,2
 f000a0c:	00000106 	br	f000a14 <disk_initialize+0x144>
 f000a10:	8023883a 	mov	r17,r16
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 (ACMD41(0)) */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
			}
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for end of initialization */
 f000a14:	d0a00717 	ldw	r2,-32740(gp)
 f000a18:	89003fcc 	andi	r4,r17,255
 f000a1c:	000b883a 	mov	r5,zero
 f000a20:	10000326 	beq	r2,zero,f000a30 <disk_initialize+0x160>
 f000a24:	f0006c40 	call	f0006c4 <send_cmd>
 f000a28:	10803fcc 	andi	r2,r2,255
 f000a2c:	103ff91e 	bne	r2,zero,f000a14 <disk_initialize+0x144>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
 f000a30:	d0a00717 	ldw	r2,-32740(gp)
 f000a34:	10001826 	beq	r2,zero,f000a98 <disk_initialize+0x1c8>
 f000a38:	01000404 	movi	r4,16
 f000a3c:	01408004 	movi	r5,512
 f000a40:	f0006c40 	call	f0006c4 <send_cmd>
 f000a44:	10803fcc 	andi	r2,r2,255
 f000a48:	1000131e 	bne	r2,zero,f000a98 <disk_initialize+0x1c8>
				ty = 0;
		}
	}
	CardType = ty;	/* Card type */
 f000a4c:	d4200905 	stb	r16,-32732(gp)
	deselect();
 f000a50:	f0006340 	call	f000634 <deselect>

	if (ty) {			/* OK */
 f000a54:	80803fcc 	andi	r2,r16,255
 f000a58:	10000426 	beq	r2,zero,f000a6c <disk_initialize+0x19c>
		FCLK_FAST();			/* Set fast clock */
		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
 f000a5c:	d0a00003 	ldbu	r2,-32768(gp)
 f000a60:	00ffff84 	movi	r3,-2
 f000a64:	10c4703a 	and	r2,r2,r3
 f000a68:	00000306 	br	f000a78 <disk_initialize+0x1a8>


static
void power_off (void)
{
	select();				/* Wait for card ready */
 f000a6c:	f0006500 	call	f000650 <select>
	deselect();
 f000a70:	f0006340 	call	f000634 <deselect>
	if (ty) {			/* OK */
		FCLK_FAST();			/* Set fast clock */
		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
	} else {			/* Failed */
		power_off();
		Stat = STA_NOINIT;
 f000a74:	00800044 	movi	r2,1
 f000a78:	d0a00005 	stb	r2,-32768(gp)
	}

	return Stat;
 f000a7c:	d0a00003 	ldbu	r2,-32768(gp)
 f000a80:	10803fcc 	andi	r2,r2,255
 f000a84:	00000706 	br	f000aa4 <disk_initialize+0x1d4>
 f000a88:	00800104 	movi	r2,4
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for end of initialization */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
				ty = 0;
		}
	}
	CardType = ty;	/* Card type */
 f000a8c:	d0a00905 	stb	r2,-32732(gp)
	deselect();
 f000a90:	f0006340 	call	f000634 <deselect>
 f000a94:	003ff106 	br	f000a5c <disk_initialize+0x18c>
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for end of initialization */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
				ty = 0;
		}
	}
	CardType = ty;	/* Card type */
 f000a98:	d0200905 	stb	zero,-32732(gp)
	deselect();
 f000a9c:	f0006340 	call	f000634 <deselect>
 f000aa0:	003ff206 	br	f000a6c <disk_initialize+0x19c>
		power_off();
		Stat = STA_NOINIT;
	}

	return Stat;
}
 f000aa4:	dfc00317 	ldw	ra,12(sp)
 f000aa8:	dc400217 	ldw	r17,8(sp)
 f000aac:	dc000117 	ldw	r16,4(sp)
 f000ab0:	dec00404 	addi	sp,sp,16
 f000ab4:	f800283a 	ret

0f000ab8 <clust2sect>:
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 f000ab8:	20800317 	ldw	r2,12(r4)

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 f000abc:	defffe04 	addi	sp,sp,-8
	clst -= 2;
 f000ac0:	297fff84 	addi	r5,r5,-2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 f000ac4:	10bfff84 	addi	r2,r2,-2

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 f000ac8:	dc000015 	stw	r16,0(sp)
 f000acc:	dfc00115 	stw	ra,4(sp)
 f000ad0:	2021883a 	mov	r16,r4
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 f000ad4:	0007883a 	mov	r3,zero
	return clst * fs->csize + fs->database;
 f000ad8:	2809883a 	mov	r4,r5
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 f000adc:	2880042e 	bgeu	r5,r2,f000af0 <clust2sect+0x38>
	return clst * fs->csize + fs->database;
 f000ae0:	81400083 	ldbu	r5,2(r16)
 f000ae4:	f001b900 	call	f001b90 <__mulsi3>
 f000ae8:	80c00717 	ldw	r3,28(r16)
 f000aec:	10c7883a 	add	r3,r2,r3
}
 f000af0:	1805883a 	mov	r2,r3
 f000af4:	dfc00117 	ldw	ra,4(sp)
 f000af8:	dc000017 	ldw	r16,0(sp)
 f000afc:	dec00204 	addi	sp,sp,8
 f000b00:	f800283a 	ret

0f000b04 <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
 f000b04:	21003fcc 	andi	r4,r4,255
 f000b08:	008002c4 	movi	r2,11
 f000b0c:	2000071e 	bne	r4,zero,f000b2c <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
 f000b10:	d0e00a17 	ldw	r3,-32728(gp)
		fs->fs_type = 0;		/* Clear new fs object */
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
 f000b14:	0005883a 	mov	r2,zero

	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */

	if (rfs) {
 f000b18:	18000126 	beq	r3,zero,f000b20 <f_mount+0x1c>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
 f000b1c:	18000005 	stb	zero,0(r3)
	}

	if (fs) {
 f000b20:	28000126 	beq	r5,zero,f000b28 <f_mount+0x24>
		fs->fs_type = 0;		/* Clear new fs object */
 f000b24:	28000005 	stb	zero,0(r5)
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
 f000b28:	d1600a15 	stw	r5,-32728(gp)

	return FR_OK;
}
 f000b2c:	f800283a 	ret

0f000b30 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
 f000b30:	deffff04 	addi	sp,sp,-4
 f000b34:	dfc00015 	stw	ra,0(sp)
	if (!fs || !fs->fs_type || fs->id != id)
 f000b38:	20000e26 	beq	r4,zero,f000b74 <validate+0x44>
 f000b3c:	20800003 	ldbu	r2,0(r4)
 f000b40:	297fffcc 	andi	r5,r5,65535
 f000b44:	10000b26 	beq	r2,zero,f000b74 <validate+0x44>
 f000b48:	2080018b 	ldhu	r2,6(r4)
 f000b4c:	1140091e 	bne	r2,r5,f000b74 <validate+0x44>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
 f000b50:	21000043 	ldbu	r4,1(r4)
 f000b54:	f0004b80 	call	f0004b8 <disk_status>
 f000b58:	1080004c 	andi	r2,r2,1
 f000b5c:	1005003a 	cmpeq	r2,r2,zero
 f000b60:	1000021e 	bne	r2,zero,f000b6c <validate+0x3c>
 f000b64:	008000c4 	movi	r2,3
 f000b68:	00000306 	br	f000b78 <validate+0x48>
 f000b6c:	0005883a 	mov	r2,zero
 f000b70:	00000106 	br	f000b78 <validate+0x48>
 f000b74:	00800244 	movi	r2,9
		return FR_NOT_READY;

	return FR_OK;
}
 f000b78:	dfc00017 	ldw	ra,0(sp)
 f000b7c:	dec00104 	addi	sp,sp,4
 f000b80:	f800283a 	ret

0f000b84 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 f000b84:	defffe04 	addi	sp,sp,-8
 f000b88:	dc000015 	stw	r16,0(sp)
 f000b8c:	2021883a 	mov	r16,r4
	FRESULT res;

#if _FS_READONLY
	FATFS *fs = fp->fs;
	res = validate(fs, fp->id);
 f000b90:	8140010b 	ldhu	r5,4(r16)
 f000b94:	21000017 	ldw	r4,0(r4)
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
 f000b98:	dfc00115 	stw	ra,4(sp)
	FRESULT res;

#if _FS_READONLY
	FATFS *fs = fp->fs;
	res = validate(fs, fp->id);
 f000b9c:	f000b300 	call	f000b30 <validate>
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
 f000ba0:	1000011e 	bne	r2,zero,f000ba8 <f_close+0x24>
 f000ba4:	80000015 	stw	zero,0(r16)
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
 f000ba8:	dfc00117 	ldw	ra,4(sp)
 f000bac:	dc000017 	ldw	r16,0(sp)
 f000bb0:	dec00204 	addi	sp,sp,8
 f000bb4:	f800283a 	ret

0f000bb8 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 f000bb8:	defffe04 	addi	sp,sp,-8
 f000bbc:	dc000015 	stw	r16,0(sp)
 f000bc0:	dfc00115 	stw	ra,4(sp)
 f000bc4:	2005883a 	mov	r2,r4
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 f000bc8:	21000043 	ldbu	r4,1(r4)
 f000bcc:	14000904 	addi	r16,r2,36
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 f000bd0:	280d883a 	mov	r6,r5
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
 f000bd4:	01c00044 	movi	r7,1
 f000bd8:	800b883a 	mov	r5,r16
 f000bdc:	f0007e80 	call	f0007e8 <disk_read>
 f000be0:	010000c4 	movi	r4,3
 f000be4:	1000271e 	bne	r2,zero,f000c84 <check_fs+0xcc>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 f000be8:	80807fc3 	ldbu	r2,511(r16)
 f000bec:	80c07f83 	ldbu	r3,510(r16)
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 f000bf0:	01c04034 	movhi	r7,256
 f000bf4:	39ffffc4 	addi	r7,r7,-1
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 f000bf8:	1004923a 	slli	r2,r2,8
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 f000bfc:	01801534 	movhi	r6,84
 f000c00:	31905184 	addi	r6,r6,16710
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
 f000c04:	01000084 	movi	r4,2
 f000c08:	10c4b03a 	or	r2,r2,r3
 f000c0c:	10bfffcc 	andi	r2,r2,65535
 f000c10:	10a0001c 	xori	r2,r2,32768
 f000c14:	10a00004 	addi	r2,r2,-32768
 f000c18:	00ea9544 	movi	r3,-21931
 f000c1c:	10c0191e 	bne	r2,r3,f000c84 <check_fs+0xcc>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
 f000c20:	80800e43 	ldbu	r2,57(r16)
 f000c24:	81000e03 	ldbu	r4,56(r16)
 f000c28:	80c00dc3 	ldbu	r3,55(r16)
 f000c2c:	1004963a 	slli	r2,r2,24
 f000c30:	2008943a 	slli	r4,r4,16
 f000c34:	81400d83 	ldbu	r5,54(r16)
 f000c38:	1806923a 	slli	r3,r3,8
 f000c3c:	1104b03a 	or	r2,r2,r4
 f000c40:	1144b03a 	or	r2,r2,r5
 f000c44:	1886b03a 	or	r3,r3,r2
 f000c48:	19c6703a 	and	r3,r3,r7
 f000c4c:	0009883a 	mov	r4,zero
 f000c50:	19800c26 	beq	r3,r6,f000c84 <check_fs+0xcc>
 f000c54:	80801543 	ldbu	r2,85(r16)
 f000c58:	81001503 	ldbu	r4,84(r16)
 f000c5c:	80c014c3 	ldbu	r3,83(r16)
 f000c60:	1004963a 	slli	r2,r2,24
 f000c64:	2008943a 	slli	r4,r4,16
 f000c68:	81401483 	ldbu	r5,82(r16)
 f000c6c:	1806923a 	slli	r3,r3,8
 f000c70:	1104b03a 	or	r2,r2,r4
 f000c74:	1144b03a 	or	r2,r2,r5
 f000c78:	1886b03a 	or	r3,r3,r2
 f000c7c:	19c6703a 	and	r3,r3,r7
 f000c80:	1988c03a 	cmpne	r4,r3,r6
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
 f000c84:	2005883a 	mov	r2,r4
 f000c88:	dfc00117 	ldw	ra,4(sp)
 f000c8c:	dc000017 	ldw	r16,0(sp)
 f000c90:	dec00204 	addi	sp,sp,8
 f000c94:	f800283a 	ret

0f000c98 <move_window>:
{
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
 f000c98:	20800817 	ldw	r2,32(r4)
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
 f000c9c:	defffd04 	addi	sp,sp,-12
 f000ca0:	dc400115 	stw	r17,4(sp)
 f000ca4:	dc000015 	stw	r16,0(sp)
 f000ca8:	dfc00215 	stw	ra,8(sp)
 f000cac:	2023883a 	mov	r17,r4
 f000cb0:	2821883a 	mov	r16,r5
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->winsect = sector;
 f000cb4:	0007883a 	mov	r3,zero
{
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
 f000cb8:	11400b26 	beq	r2,r5,f000ce8 <move_window+0x50>
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 f000cbc:	21400904 	addi	r5,r4,36
 f000cc0:	800d883a 	mov	r6,r16
 f000cc4:	01c00044 	movi	r7,1
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
 f000cc8:	80000726 	beq	r16,zero,f000ce8 <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
 f000ccc:	21000043 	ldbu	r4,1(r4)
 f000cd0:	f0007e80 	call	f0007e8 <disk_read>
 f000cd4:	10000226 	beq	r2,zero,f000ce0 <move_window+0x48>
 f000cd8:	00c00044 	movi	r3,1
 f000cdc:	00000206 	br	f000ce8 <move_window+0x50>
				return FR_DISK_ERR;
			fs->winsect = sector;
 f000ce0:	0007883a 	mov	r3,zero
 f000ce4:	8c000815 	stw	r16,32(r17)
		}
	}

	return FR_OK;
}
 f000ce8:	1805883a 	mov	r2,r3
 f000cec:	dfc00217 	ldw	ra,8(sp)
 f000cf0:	dc400117 	ldw	r17,4(sp)
 f000cf4:	dc000017 	ldw	r16,0(sp)
 f000cf8:	dec00304 	addi	sp,sp,12
 f000cfc:	f800283a 	ret

0f000d00 <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
 f000d00:	defffa04 	addi	sp,sp,-24
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
 f000d04:	00c00044 	movi	r3,1

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
 f000d08:	dc800215 	stw	r18,8(sp)
 f000d0c:	dc400115 	stw	r17,4(sp)
 f000d10:	dfc00515 	stw	ra,20(sp)
 f000d14:	dd000415 	stw	r20,16(sp)
 f000d18:	dcc00315 	stw	r19,12(sp)
 f000d1c:	dc000015 	stw	r16,0(sp)
 f000d20:	2825883a 	mov	r18,r5
 f000d24:	2023883a 	mov	r17,r4
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
 f000d28:	19404b2e 	bgeu	r3,r5,f000e58 <get_fat+0x158>
 f000d2c:	20800317 	ldw	r2,12(r4)
 f000d30:	2880492e 	bgeu	r5,r2,f000e58 <get_fat+0x158>
		return 1;

	switch (fs->fs_type) {
 f000d34:	24c00003 	ldbu	r19,0(r4)
 f000d38:	00800084 	movi	r2,2
 f000d3c:	98802026 	beq	r19,r2,f000dc0 <get_fat+0xc0>
 f000d40:	008000c4 	movi	r2,3
 f000d44:	98802c26 	beq	r19,r2,f000df8 <get_fat+0xf8>
 f000d48:	98c0451e 	bne	r19,r3,f000e60 <get_fat+0x160>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
 f000d4c:	28c4d83a 	srl	r2,r5,r3
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 f000d50:	20c00517 	ldw	r3,20(r4)
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
 f000d54:	28a1883a 	add	r16,r5,r2
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 f000d58:	800ad27a 	srli	r5,r16,9
 f000d5c:	28cb883a 	add	r5,r5,r3
 f000d60:	f000c980 	call	f000c98 <move_window>
 f000d64:	10003e1e 	bne	r2,zero,f000e60 <get_fat+0x160>
		wc = fs->win[bc % SS(fs)]; bc++;
 f000d68:	84e9883a 	add	r20,r16,r19
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 f000d6c:	a006d27a 	srli	r3,r20,9
 f000d70:	89400517 	ldw	r5,20(r17)

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 f000d74:	80807fcc 	andi	r2,r16,511
 f000d78:	1445883a 	add	r2,r2,r17
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 f000d7c:	194b883a 	add	r5,r3,r5
 f000d80:	8809883a 	mov	r4,r17

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 f000d84:	14000903 	ldbu	r16,36(r2)
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
 f000d88:	f000c980 	call	f000c98 <move_window>
 f000d8c:	1000341e 	bne	r2,zero,f000e60 <get_fat+0x160>
		wc |= fs->win[bc % SS(fs)] << 8;
 f000d90:	a0807fcc 	andi	r2,r20,511
 f000d94:	1445883a 	add	r2,r2,r17
 f000d98:	10800903 	ldbu	r2,36(r2)

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
 f000d9c:	80c03fcc 	andi	r3,r16,255
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 f000da0:	94c8703a 	and	r4,r18,r19
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
 f000da4:	1004923a 	slli	r2,r2,8
 f000da8:	1884b03a 	or	r2,r3,r2
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 f000dac:	20000226 	beq	r4,zero,f000db8 <get_fat+0xb8>
 f000db0:	1004d13a 	srli	r2,r2,4
 f000db4:	00002b06 	br	f000e64 <get_fat+0x164>
 f000db8:	1083ffcc 	andi	r2,r2,4095
 f000dbc:	00002906 	br	f000e64 <get_fat+0x164>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
 f000dc0:	2804d23a 	srli	r2,r5,8
 f000dc4:	21400517 	ldw	r5,20(r4)
 f000dc8:	114b883a 	add	r5,r2,r5
 f000dcc:	f000c980 	call	f000c98 <move_window>
 f000dd0:	1000231e 	bne	r2,zero,f000e60 <get_fat+0x160>
		p = &fs->win[clst * 2 % SS(fs)];
 f000dd4:	9485883a 	add	r2,r18,r18
 f000dd8:	10807fcc 	andi	r2,r2,511
 f000ddc:	88c00904 	addi	r3,r17,36
 f000de0:	1887883a 	add	r3,r3,r2
		return LD_WORD(p);
 f000de4:	18800043 	ldbu	r2,1(r3)
 f000de8:	18c00003 	ldbu	r3,0(r3)
 f000dec:	1004923a 	slli	r2,r2,8
 f000df0:	10c4b03a 	or	r2,r2,r3
 f000df4:	00001b06 	br	f000e64 <get_fat+0x164>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
 f000df8:	2804d1fa 	srli	r2,r5,7
 f000dfc:	21400517 	ldw	r5,20(r4)
 f000e00:	114b883a 	add	r5,r2,r5
 f000e04:	f000c980 	call	f000c98 <move_window>
 f000e08:	1000151e 	bne	r2,zero,f000e60 <get_fat+0x160>
		p = &fs->win[clst * 4 % SS(fs)];
 f000e0c:	9485883a 	add	r2,r18,r18
 f000e10:	1085883a 	add	r2,r2,r2
 f000e14:	10807fcc 	andi	r2,r2,511
 f000e18:	88c00904 	addi	r3,r17,36
 f000e1c:	1887883a 	add	r3,r3,r2
		return LD_DWORD(p) & 0x0FFFFFFF;
 f000e20:	188000c3 	ldbu	r2,3(r3)
 f000e24:	19000083 	ldbu	r4,2(r3)
 f000e28:	19400043 	ldbu	r5,1(r3)
 f000e2c:	1004963a 	slli	r2,r2,24
 f000e30:	2008943a 	slli	r4,r4,16
 f000e34:	18c00003 	ldbu	r3,0(r3)
 f000e38:	280a923a 	slli	r5,r5,8
 f000e3c:	1104b03a 	or	r2,r2,r4
 f000e40:	10c4b03a 	or	r2,r2,r3
 f000e44:	288ab03a 	or	r5,r5,r2
 f000e48:	00840034 	movhi	r2,4096
 f000e4c:	10bfffc4 	addi	r2,r2,-1
 f000e50:	2884703a 	and	r2,r5,r2
 f000e54:	00000306 	br	f000e64 <get_fat+0x164>
 f000e58:	00800044 	movi	r2,1
 f000e5c:	00000106 	br	f000e64 <get_fat+0x164>
 f000e60:	00bfffc4 	movi	r2,-1
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
}
 f000e64:	dfc00517 	ldw	ra,20(sp)
 f000e68:	dd000417 	ldw	r20,16(sp)
 f000e6c:	dcc00317 	ldw	r19,12(sp)
 f000e70:	dc800217 	ldw	r18,8(sp)
 f000e74:	dc400117 	ldw	r17,4(sp)
 f000e78:	dc000017 	ldw	r16,0(sp)
 f000e7c:	dec00604 	addi	sp,sp,24
 f000e80:	f800283a 	ret

0f000e84 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 f000e84:	defff704 	addi	sp,sp,-36
 f000e88:	dc000015 	stw	r16,0(sp)
 f000e8c:	2021883a 	mov	r16,r4
 f000e90:	dc800215 	stw	r18,8(sp)
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
 f000e94:	21000017 	ldw	r4,0(r4)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 f000e98:	2825883a 	mov	r18,r5
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
 f000e9c:	8140010b 	ldhu	r5,4(r16)
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
 f000ea0:	38000015 	stw	zero,0(r7)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
 f000ea4:	ddc00715 	stw	r23,28(sp)
 f000ea8:	dd000415 	stw	r20,16(sp)
 f000eac:	dc400115 	stw	r17,4(sp)
 f000eb0:	dfc00815 	stw	ra,32(sp)
 f000eb4:	dd800615 	stw	r22,24(sp)
 f000eb8:	dd400515 	stw	r21,20(sp)
 f000ebc:	dcc00315 	stw	r19,12(sp)
 f000ec0:	382f883a 	mov	r23,r7
 f000ec4:	3023883a 	mov	r17,r6
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
 f000ec8:	f000b300 	call	f000b30 <validate>
 f000ecc:	1029883a 	mov	r20,r2
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
 f000ed0:	10006b1e 	bne	r2,zero,f001080 <f_read+0x1fc>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
 f000ed4:	80c00183 	ldbu	r3,6(r16)
 f000ed8:	18803fcc 	andi	r2,r3,255
 f000edc:	1080201c 	xori	r2,r2,128
 f000ee0:	10bfe004 	addi	r2,r2,-128
 f000ee4:	1000020e 	bge	r2,zero,f000ef0 <f_read+0x6c>
 f000ee8:	05000084 	movi	r20,2
 f000eec:	00006406 	br	f001080 <f_read+0x1fc>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
 f000ef0:	1880004c 	andi	r2,r3,1
 f000ef4:	10000e1e 	bne	r2,zero,f000f30 <f_read+0xac>
 f000ef8:	050001c4 	movi	r20,7
 f000efc:	00006006 	br	f001080 <f_read+0x1fc>
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 f000f00:	80800183 	ldbu	r2,6(r16)
 f000f04:	2029883a 	mov	r20,r4
 f000f08:	00ffe004 	movi	r3,-128
 f000f0c:	10c4b03a 	or	r2,r2,r3
 f000f10:	80800185 	stb	r2,6(r16)
 f000f14:	00005a06 	br	f001080 <f_read+0x1fc>
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 f000f18:	80800183 	ldbu	r2,6(r16)
 f000f1c:	05000084 	movi	r20,2
 f000f20:	003ff906 	br	f000f08 <f_read+0x84>
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
 f000f24:	80800183 	ldbu	r2,6(r16)
 f000f28:	05000044 	movi	r20,1
 f000f2c:	003ff606 	br	f000f08 <f_read+0x84>
)
{
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;
 f000f30:	80c00317 	ldw	r3,12(r16)
 f000f34:	80800217 	ldw	r2,8(r16)
 f000f38:	902d883a 	mov	r22,r18
 f000f3c:	18a7c83a 	sub	r19,r3,r2
 f000f40:	8cc04e2e 	bgeu	r17,r19,f00107c <f_read+0x1f8>
 f000f44:	8827883a 	mov	r19,r17
 f000f48:	00004c06 	br	f00107c <f_read+0x1f8>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
 f000f4c:	81400217 	ldw	r5,8(r16)
 f000f50:	28807fcc 	andi	r2,r5,511
 f000f54:	1000271e 	bne	r2,zero,f000ff4 <f_read+0x170>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
 f000f58:	81000017 	ldw	r4,0(r16)
 f000f5c:	2804d27a 	srli	r2,r5,9
 f000f60:	20c00083 	ldbu	r3,2(r4)
 f000f64:	18ffffc4 	addi	r3,r3,-1
 f000f68:	10ea703a 	and	r21,r2,r3
			if (!csect) {						/* On the cluster boundary? */
 f000f6c:	a8803fcc 	andi	r2,r21,255
 f000f70:	10000b1e 	bne	r2,zero,f000fa0 <f_read+0x11c>
				if (fp->fptr == 0) {			/* On the top of the file? */
 f000f74:	2800021e 	bne	r5,zero,f000f80 <f_read+0xfc>
					clst = fp->sclust;			/* Follow from the origin */
 f000f78:	80c00417 	ldw	r3,16(r16)
 f000f7c:	00000306 	br	f000f8c <f_read+0x108>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
 f000f80:	81400517 	ldw	r5,20(r16)
 f000f84:	f000d000 	call	f000d00 <get_fat>
 f000f88:	1007883a 	mov	r3,r2
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
 f000f8c:	01000044 	movi	r4,1
 f000f90:	20ffe12e 	bgeu	r4,r3,f000f18 <f_read+0x94>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
 f000f94:	00bfffc4 	movi	r2,-1
 f000f98:	18bfd926 	beq	r3,r2,f000f00 <f_read+0x7c>
				fp->clust = clst;				/* Update current cluster */
 f000f9c:	80c00515 	stw	r3,20(r16)
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
 f000fa0:	84800017 	ldw	r18,0(r16)
 f000fa4:	81400517 	ldw	r5,20(r16)
 f000fa8:	9009883a 	mov	r4,r18
 f000fac:	f000ab80 	call	f000ab8 <clust2sect>
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
 f000fb0:	103fd926 	beq	r2,zero,f000f18 <f_read+0x94>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
 f000fb4:	9822d27a 	srli	r17,r19,9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
 f000fb8:	a8c03fcc 	andi	r3,r21,255
 f000fbc:	10cd883a 	add	r6,r2,r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
 f000fc0:	88000b26 	beq	r17,zero,f000ff0 <f_read+0x16c>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
 f000fc4:	91000083 	ldbu	r4,2(r18)
 f000fc8:	1c45883a 	add	r2,r3,r17
 f000fcc:	2080012e 	bgeu	r4,r2,f000fd4 <f_read+0x150>
					cc = fp->fs->csize - csect;
 f000fd0:	20e3c83a 	sub	r17,r4,r3
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
 f000fd4:	91000043 	ldbu	r4,1(r18)
 f000fd8:	b00b883a 	mov	r5,r22
 f000fdc:	89c03fcc 	andi	r7,r17,255
 f000fe0:	f0007e80 	call	f0007e8 <disk_read>
 f000fe4:	103fcf1e 	bne	r2,zero,f000f24 <f_read+0xa0>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
 f000fe8:	880e927a 	slli	r7,r17,9
 f000fec:	00001b06 	br	f00105c <f_read+0x1d8>
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
 f000ff0:	81800615 	stw	r6,24(r16)
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
 f000ff4:	81000017 	ldw	r4,0(r16)
 f000ff8:	81400617 	ldw	r5,24(r16)
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 f000ffc:	84400217 	ldw	r17,8(r16)
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
 f001000:	f000c980 	call	f000c98 <move_window>
 f001004:	103fc71e 	bne	r2,zero,f000f24 <f_read+0xa0>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
 f001008:	88c07fcc 	andi	r3,r17,511
 f00100c:	00808004 	movi	r2,512
 f001010:	10c5c83a 	sub	r2,r2,r3
 f001014:	980f883a 	mov	r7,r19
 f001018:	14c0012e 	bgeu	r2,r19,f001020 <f_read+0x19c>
 f00101c:	100f883a 	mov	r7,r2

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
 f001020:	80c00017 	ldw	r3,0(r16)
 f001024:	80800217 	ldw	r2,8(r16)
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
 f001028:	b00b883a 	mov	r5,r22
	const BYTE *s = (const BYTE*)src;
 f00102c:	18c00904 	addi	r3,r3,36
 f001030:	10807fcc 	andi	r2,r2,511
 f001034:	1887883a 	add	r3,r3,r2
 f001038:	3809883a 	mov	r4,r7
 f00103c:	01bfffc4 	movi	r6,-1
 f001040:	00000406 	br	f001054 <f_read+0x1d0>
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
 f001044:	18800003 	ldbu	r2,0(r3)
 f001048:	18c00044 	addi	r3,r3,1
 f00104c:	28800005 	stb	r2,0(r5)
 f001050:	29400044 	addi	r5,r5,1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
 f001054:	213fffc4 	addi	r4,r4,-1
 f001058:	21bffa1e 	bne	r4,r6,f001044 <f_read+0x1c0>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 f00105c:	80800217 	ldw	r2,8(r16)
 f001060:	b8c00017 	ldw	r3,0(r23)
 f001064:	99e7c83a 	sub	r19,r19,r7
 f001068:	11c5883a 	add	r2,r2,r7
 f00106c:	19c7883a 	add	r3,r3,r7
 f001070:	80800215 	stw	r2,8(r16)
 f001074:	b8c00015 	stw	r3,0(r23)
 f001078:	b1ed883a 	add	r22,r22,r7
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
 f00107c:	983fb31e 	bne	r19,zero,f000f4c <f_read+0xc8>
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
 f001080:	a005883a 	mov	r2,r20
 f001084:	dfc00817 	ldw	ra,32(sp)
 f001088:	ddc00717 	ldw	r23,28(sp)
 f00108c:	dd800617 	ldw	r22,24(sp)
 f001090:	dd400517 	ldw	r21,20(sp)
 f001094:	dd000417 	ldw	r20,16(sp)
 f001098:	dcc00317 	ldw	r19,12(sp)
 f00109c:	dc800217 	ldw	r18,8(sp)
 f0010a0:	dc400117 	ldw	r17,4(sp)
 f0010a4:	dc000017 	ldw	r16,0(sp)
 f0010a8:	dec00904 	addi	sp,sp,36
 f0010ac:	f800283a 	ret

0f0010b0 <dir_sdi>:
	DWORD clst;
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
 f0010b0:	20c00217 	ldw	r3,8(r4)
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
 f0010b4:	defffb04 	addi	sp,sp,-20
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 f0010b8:	00800044 	movi	r2,1
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
 f0010bc:	dc800215 	stw	r18,8(sp)
 f0010c0:	dc000015 	stw	r16,0(sp)
 f0010c4:	dfc00415 	stw	ra,16(sp)
 f0010c8:	dcc00315 	stw	r19,12(sp)
 f0010cc:	dc400115 	stw	r17,4(sp)
 f0010d0:	2021883a 	mov	r16,r4
	DWORD clst;
	WORD ic;


	dj->index = idx;
 f0010d4:	2140018d 	sth	r5,6(r4)
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
 f0010d8:	2825883a 	mov	r18,r5
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
 f0010dc:	18803226 	beq	r3,r2,f0011a8 <dir_sdi+0xf8>
 f0010e0:	21000017 	ldw	r4,0(r4)
 f0010e4:	20800317 	ldw	r2,12(r4)
 f0010e8:	18802f2e 	bgeu	r3,r2,f0011a8 <dir_sdi+0xf8>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 f0010ec:	18000c1e 	bne	r3,zero,f001120 <dir_sdi+0x70>
 f0010f0:	20c00003 	ldbu	r3,0(r4)
 f0010f4:	008000c4 	movi	r2,3
 f0010f8:	1880021e 	bne	r3,r2,f001104 <dir_sdi+0x54>
		clst = dj->fs->dirbase;
 f0010fc:	20c00617 	ldw	r3,24(r4)

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
 f001100:	1800071e 	bne	r3,zero,f001120 <dir_sdi+0x70>
		dj->clust = clst;
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 f001104:	2080020b 	ldhu	r2,8(r4)
 f001108:	90ffffcc 	andi	r3,r18,65535
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
 f00110c:	80000315 	stw	zero,12(r16)
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
 f001110:	1880252e 	bgeu	r3,r2,f0011a8 <dir_sdi+0xf8>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 f001114:	20800617 	ldw	r2,24(r4)
 f001118:	1806d13a 	srli	r3,r3,4
 f00111c:	00001606 	br	f001178 <dir_sdi+0xc8>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
 f001120:	20800083 	ldbu	r2,2(r4)
 f001124:	1026913a 	slli	r19,r2,4
 f001128:	00000b06 	br	f001158 <dir_sdi+0xa8>
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 f00112c:	81000017 	ldw	r4,0(r16)
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
 f001130:	94e5c83a 	sub	r18,r18,r19
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 f001134:	f000d000 	call	f000d00 <get_fat>
 f001138:	1007883a 	mov	r3,r2
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 f00113c:	00bfffc4 	movi	r2,-1
 f001140:	18801726 	beq	r3,r2,f0011a0 <dir_sdi+0xf0>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
 f001144:	00800044 	movi	r2,1
 f001148:	10c0172e 	bgeu	r2,r3,f0011a8 <dir_sdi+0xf8>
 f00114c:	80800017 	ldw	r2,0(r16)
 f001150:	10800317 	ldw	r2,12(r2)
 f001154:	1880142e 	bgeu	r3,r2,f0011a8 <dir_sdi+0xf8>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 f001158:	947fffcc 	andi	r17,r18,65535
 f00115c:	98bfffcc 	andi	r2,r19,65535
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
 f001160:	180b883a 	mov	r5,r3
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
 f001164:	88bff12e 	bgeu	r17,r2,f00112c <dir_sdi+0x7c>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 f001168:	81000017 	ldw	r4,0(r16)
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
 f00116c:	80c00315 	stw	r3,12(r16)
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
 f001170:	f000ab80 	call	f000ab8 <clust2sect>
 f001174:	8806d13a 	srli	r3,r17,4
 f001178:	10c5883a 	add	r2,r2,r3
 f00117c:	80800415 	stw	r2,16(r16)
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
 f001180:	90c003cc 	andi	r3,r18,15
 f001184:	80800017 	ldw	r2,0(r16)
 f001188:	1806917a 	slli	r3,r3,5
 f00118c:	0009883a 	mov	r4,zero
 f001190:	10800904 	addi	r2,r2,36
 f001194:	10c5883a 	add	r2,r2,r3
 f001198:	80800515 	stw	r2,20(r16)
 f00119c:	00000306 	br	f0011ac <dir_sdi+0xfc>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 f0011a0:	01000044 	movi	r4,1
 f0011a4:	00000106 	br	f0011ac <dir_sdi+0xfc>
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
 f0011a8:	01000084 	movi	r4,2
}
 f0011ac:	2005883a 	mov	r2,r4
 f0011b0:	dfc00417 	ldw	ra,16(sp)
 f0011b4:	dcc00317 	ldw	r19,12(sp)
 f0011b8:	dc800217 	ldw	r18,8(sp)
 f0011bc:	dc400117 	ldw	r17,4(sp)
 f0011c0:	dc000017 	ldw	r16,0(sp)
 f0011c4:	dec00504 	addi	sp,sp,20
 f0011c8:	f800283a 	ret

0f0011cc <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 f0011cc:	deffeb04 	addi	sp,sp,-84
 f0011d0:	df001315 	stw	fp,76(sp)
 f0011d4:	dd401015 	stw	r21,64(sp)
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
 f0011d8:	20000015 	stw	zero,0(r4)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 f0011dc:	dfc01415 	stw	ra,80(sp)
 f0011e0:	ddc01215 	stw	r23,72(sp)
 f0011e4:	dd801115 	stw	r22,68(sp)
 f0011e8:	dd000f15 	stw	r20,60(sp)
 f0011ec:	dcc00e15 	stw	r19,56(sp)
 f0011f0:	dc800d15 	stw	r18,52(sp)
 f0011f4:	dc400c15 	stw	r17,48(sp)
 f0011f8:	dc000b15 	stw	r16,44(sp)
	WORD nrsv;
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
 f0011fc:	28800007 	ldb	r2,0(r5)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 f001200:	2039883a 	mov	fp,r4
 f001204:	282b883a 	mov	r21,r5
	WORD nrsv;
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
 f001208:	113ff404 	addi	r4,r2,-48
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 f00120c:	00800244 	movi	r2,9
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 f001210:	d9800a05 	stb	r6,40(sp)
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
 f001214:	11000536 	bltu	r2,r4,f00122c <f_open+0x60>
 f001218:	28c00047 	ldb	r3,1(r5)
 f00121c:	00800e84 	movi	r2,58
 f001220:	1880021e 	bne	r3,r2,f00122c <f_open+0x60>
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
 f001224:	2000ce1e 	bne	r4,zero,f001560 <f_open+0x394>
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
		p += 2; *path = p;				/* Return pointer to the path name */
 f001228:	2d400084 	addi	r21,r5,2
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
 f00122c:	d4200a17 	ldw	r16,-32728(gp)
 f001230:	dc000315 	stw	r16,12(sp)
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 f001234:	8000021e 	bne	r16,zero,f001240 <f_open+0x74>
 f001238:	02000304 	movi	r8,12
 f00123c:	0000cb06 	br	f00156c <f_open+0x3a0>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
 f001240:	80800003 	ldbu	r2,0(r16)
 f001244:	10000526 	beq	r2,zero,f00125c <f_open+0x90>
		stat = disk_status(fs->drv);
 f001248:	81000043 	ldbu	r4,1(r16)
 f00124c:	f0004b80 	call	f0004b8 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
 f001250:	1080004c 	andi	r2,r2,1
 f001254:	1005003a 	cmpeq	r2,r2,zero
 f001258:	1001d91e 	bne	r2,zero,f0019c0 <f_open+0x7f4>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 f00125c:	80000005 	stb	zero,0(r16)
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 f001260:	80000045 	stb	zero,1(r16)
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
 f001264:	0009883a 	mov	r4,zero
 f001268:	f0008d00 	call	f0008d0 <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
 f00126c:	1080004c 	andi	r2,r2,1
 f001270:	1005003a 	cmpeq	r2,r2,zero
 f001274:	1000021e 	bne	r2,zero,f001280 <f_open+0xb4>
 f001278:	020000c4 	movi	r8,3
 f00127c:	0000bb06 	br	f00156c <f_open+0x3a0>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
 f001280:	8009883a 	mov	r4,r16
 f001284:	000b883a 	mov	r5,zero
 f001288:	f000bb80 	call	f000bb8 <check_fs>
 f00128c:	1009883a 	mov	r4,r2
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
 f001290:	10c03fcc 	andi	r3,r2,255
 f001294:	00800044 	movi	r2,1
 f001298:	18800226 	beq	r3,r2,f0012a4 <f_open+0xd8>
 f00129c:	002f883a 	mov	r23,zero
 f0012a0:	00001106 	br	f0012e8 <f_open+0x11c>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
 f0012a4:	81407884 	addi	r5,r16,482
		if (tbl[4]) {						/* Is the partition existing? */
 f0012a8:	28800103 	ldbu	r2,4(r5)
 f0012ac:	1000ae26 	beq	r2,zero,f001568 <f_open+0x39c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
 f0012b0:	288002c3 	ldbu	r2,11(r5)
 f0012b4:	28c00283 	ldbu	r3,10(r5)
 f0012b8:	29000243 	ldbu	r4,9(r5)
 f0012bc:	1004963a 	slli	r2,r2,24
 f0012c0:	1806943a 	slli	r3,r3,16
 f0012c4:	29400203 	ldbu	r5,8(r5)
 f0012c8:	2008923a 	slli	r4,r4,8
 f0012cc:	10c4b03a 	or	r2,r2,r3
 f0012d0:	1144b03a 	or	r2,r2,r5
 f0012d4:	20aeb03a 	or	r23,r4,r2
			fmt = check_fs(fs, bsect);		/* Check the partition */
 f0012d8:	b80b883a 	mov	r5,r23
 f0012dc:	8009883a 	mov	r4,r16
 f0012e0:	f000bb80 	call	f000bb8 <check_fs>
 f0012e4:	1009883a 	mov	r4,r2
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
 f0012e8:	20c03fcc 	andi	r3,r4,255
 f0012ec:	008000c4 	movi	r2,3
 f0012f0:	1880021e 	bne	r3,r2,f0012fc <f_open+0x130>
 f0012f4:	02000044 	movi	r8,1
 f0012f8:	00009c06 	br	f00156c <f_open+0x3a0>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
 f0012fc:	18009a1e 	bne	r3,zero,f001568 <f_open+0x39c>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
 f001300:	84400904 	addi	r17,r16,36
 f001304:	88800303 	ldbu	r2,12(r17)
 f001308:	88c002c3 	ldbu	r3,11(r17)
 f00130c:	1004923a 	slli	r2,r2,8
 f001310:	10c4b03a 	or	r2,r2,r3
 f001314:	10bfffcc 	andi	r2,r2,65535
 f001318:	10a0001c 	xori	r2,r2,32768
 f00131c:	10a00004 	addi	r2,r2,-32768
 f001320:	00c08004 	movi	r3,512
 f001324:	10c0901e 	bne	r2,r3,f001568 <f_open+0x39c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 f001328:	888005c3 	ldbu	r2,23(r17)
 f00132c:	88c00583 	ldbu	r3,22(r17)
 f001330:	1004923a 	slli	r2,r2,8
 f001334:	10c8b03a 	or	r4,r2,r3
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 f001338:	20bfffcc 	andi	r2,r4,65535
 f00133c:	10a0001c 	xori	r2,r2,32768
 f001340:	10a00004 	addi	r2,r2,-32768
 f001344:	10000226 	beq	r2,zero,f001350 <f_open+0x184>
	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
 f001348:	21ffffcc 	andi	r7,r4,65535
 f00134c:	00000a06 	br	f001378 <f_open+0x1ac>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
 f001350:	888009c3 	ldbu	r2,39(r17)
 f001354:	88c00983 	ldbu	r3,38(r17)
 f001358:	89000943 	ldbu	r4,37(r17)
 f00135c:	1004963a 	slli	r2,r2,24
 f001360:	1806943a 	slli	r3,r3,16
 f001364:	89400903 	ldbu	r5,36(r17)
 f001368:	2008923a 	slli	r4,r4,8
 f00136c:	10c4b03a 	or	r2,r2,r3
 f001370:	1144b03a 	or	r2,r2,r5
 f001374:	208eb03a 	or	r7,r4,r2
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 f001378:	81800d03 	ldbu	r6,52(r16)
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 f00137c:	00c00044 	movi	r3,1
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
 f001380:	81c00415 	stw	r7,16(r16)

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 f001384:	30bfffc4 	addi	r2,r6,-1
 f001388:	10803fcc 	andi	r2,r2,255

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
 f00138c:	818000c5 	stb	r6,3(r16)
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
 f001390:	18807536 	bltu	r3,r2,f001568 <f_open+0x39c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 f001394:	80800c43 	ldbu	r2,49(r16)
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 f001398:	1007883a 	mov	r3,r2

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
 f00139c:	80800085 	stb	r2,2(r16)
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 f0013a0:	10007126 	beq	r2,zero,f001568 <f_open+0x39c>
 f0013a4:	10bfffc4 	addi	r2,r2,-1
 f0013a8:	1884703a 	and	r2,r3,r2
 f0013ac:	10006e1e 	bne	r2,zero,f001568 <f_open+0x39c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 f0013b0:	88800483 	ldbu	r2,18(r17)
 f0013b4:	88c00443 	ldbu	r3,17(r17)
 f0013b8:	1004923a 	slli	r2,r2,8
 f0013bc:	10c4b03a 	or	r2,r2,r3
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 f0013c0:	10c003cc 	andi	r3,r2,15
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
 f0013c4:	1027883a 	mov	r19,r2
 f0013c8:	8080020d 	sth	r2,8(r16)
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
 f0013cc:	1800661e 	bne	r3,zero,f001568 <f_open+0x39c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 f0013d0:	88800503 	ldbu	r2,20(r17)
 f0013d4:	88c004c3 	ldbu	r3,19(r17)
 f0013d8:	1004923a 	slli	r2,r2,8
 f0013dc:	10c8b03a 	or	r4,r2,r3
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 f0013e0:	20bfffcc 	andi	r2,r4,65535
 f0013e4:	10a0001c 	xori	r2,r2,32768
 f0013e8:	10a00004 	addi	r2,r2,-32768
 f0013ec:	10000226 	beq	r2,zero,f0013f8 <f_open+0x22c>
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
 f0013f0:	253fffcc 	andi	r20,r4,65535
 f0013f4:	00000a06 	br	f001420 <f_open+0x254>
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
 f0013f8:	888008c3 	ldbu	r2,35(r17)
 f0013fc:	88c00883 	ldbu	r3,34(r17)
 f001400:	89000843 	ldbu	r4,33(r17)
 f001404:	1004963a 	slli	r2,r2,24
 f001408:	1806943a 	slli	r3,r3,16
 f00140c:	89400803 	ldbu	r5,32(r17)
 f001410:	2008923a 	slli	r4,r4,8
 f001414:	10c4b03a 	or	r2,r2,r3
 f001418:	1144b03a 	or	r2,r2,r5
 f00141c:	20a8b03a 	or	r20,r4,r2

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
 f001420:	888003c3 	ldbu	r2,15(r17)
 f001424:	88c00383 	ldbu	r3,14(r17)
 f001428:	1004923a 	slli	r2,r2,8
 f00142c:	10e4b03a 	or	r18,r2,r3
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
 f001430:	90bfffcc 	andi	r2,r18,65535
 f001434:	10a0001c 	xori	r2,r2,32768
 f001438:	10a00004 	addi	r2,r2,-32768
 f00143c:	10004a26 	beq	r2,zero,f001568 <f_open+0x39c>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
 f001440:	3809883a 	mov	r4,r7
 f001444:	31403fcc 	andi	r5,r6,255
 f001448:	f001b900 	call	f001b90 <__mulsi3>
 f00144c:	102d883a 	mov	r22,r2

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
 f001450:	98bfffcc 	andi	r2,r19,65535
 f001454:	1004d13a 	srli	r2,r2,4
 f001458:	94ffffcc 	andi	r19,r18,65535
 f00145c:	9885883a 	add	r2,r19,r2
 f001460:	b0a5883a 	add	r18,r22,r2
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 f001464:	a4804036 	bltu	r20,r18,f001568 <f_open+0x39c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
 f001468:	81400083 	ldbu	r5,2(r16)
 f00146c:	a489c83a 	sub	r4,r20,r18
 f001470:	f001b800 	call	f001b80 <__udivsi3>
 f001474:	1007883a 	mov	r3,r2
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
 f001478:	10003b26 	beq	r2,zero,f001568 <f_open+0x39c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
 f00147c:	0083fd44 	movi	r2,4085
 f001480:	10c00236 	bltu	r2,r3,f00148c <f_open+0x2c0>
 f001484:	01800044 	movi	r6,1
 f001488:	00000306 	br	f001498 <f_open+0x2cc>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
 f00148c:	00bffd54 	movui	r2,65525
 f001490:	10c14236 	bltu	r2,r3,f00199c <f_open+0x7d0>
 f001494:	01800084 	movi	r6,2
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 f001498:	8080020b 	ldhu	r2,8(r16)
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 f00149c:	bccb883a 	add	r5,r23,r19
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 f0014a0:	18c00084 	addi	r3,r3,2
	fs->database = bsect + sysect;						/* Data start sector */
 f0014a4:	bc89883a 	add	r4,r23,r18
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 f0014a8:	80c00315 	stw	r3,12(r16)
	fs->database = bsect + sysect;						/* Data start sector */
 f0014ac:	81000715 	stw	r4,28(r16)
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 f0014b0:	81400515 	stw	r5,20(r16)
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
 f0014b4:	10002c26 	beq	r2,zero,f001568 <f_open+0x39c>
 f0014b8:	00001006 	br	f0014fc <f_open+0x330>
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 f0014bc:	88800bc3 	ldbu	r2,47(r17)
 f0014c0:	89000b83 	ldbu	r4,46(r17)
 f0014c4:	89400b43 	ldbu	r5,45(r17)
 f0014c8:	1004963a 	slli	r2,r2,24
 f0014cc:	2008943a 	slli	r4,r4,16
 f0014d0:	89800b03 	ldbu	r6,44(r17)
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 f0014d4:	80c00317 	ldw	r3,12(r16)
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 f0014d8:	280a923a 	slli	r5,r5,8
 f0014dc:	1104b03a 	or	r2,r2,r4
 f0014e0:	1184b03a 	or	r2,r2,r6
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 f0014e4:	18c7883a 	add	r3,r3,r3
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 f0014e8:	288ab03a 	or	r5,r5,r2
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
 f0014ec:	018000c4 	movi	r6,3
 f0014f0:	18c5883a 	add	r2,r3,r3
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
 f0014f4:	81400615 	stw	r5,24(r16)
 f0014f8:	00000d06 	br	f001530 <f_open+0x364>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
 f0014fc:	2d85883a 	add	r2,r5,r22
 f001500:	80800615 	stw	r2,24(r16)
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
 f001504:	30c03fcc 	andi	r3,r6,255
 f001508:	00800084 	movi	r2,2
 f00150c:	81000317 	ldw	r4,12(r16)
 f001510:	1880021e 	bne	r3,r2,f00151c <f_open+0x350>
 f001514:	2105883a 	add	r2,r4,r4
 f001518:	00000506 	br	f001530 <f_open+0x364>
 f00151c:	2105883a 	add	r2,r4,r4
 f001520:	1105883a 	add	r2,r2,r4
 f001524:	1004d07a 	srli	r2,r2,1
 f001528:	20c0004c 	andi	r3,r4,1
 f00152c:	10c5883a 	add	r2,r2,r3
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
 f001530:	10807fc4 	addi	r2,r2,511
 f001534:	1004d27a 	srli	r2,r2,9
 f001538:	80c00417 	ldw	r3,16(r16)
 f00153c:	18800a36 	bltu	r3,r2,f001568 <f_open+0x39c>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
 f001540:	81800005 	stb	r6,0(r16)
	fs->id = ++Fsid;		/* File system mount ID */
 f001544:	d0a00b0b 	ldhu	r2,-32724(gp)
	fs->winsect = 0;		/* Invalidate sector cache */
 f001548:	80000815 	stw	zero,32(r16)
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
 f00154c:	10800044 	addi	r2,r2,1
 f001550:	d0a00b0d 	sth	r2,-32724(gp)
 f001554:	8080018d 	sth	r2,6(r16)
	fs->winsect = 0;		/* Invalidate sector cache */
	fs->wflag = 0;
 f001558:	80000105 	stb	zero,4(r16)
 f00155c:	00011806 	br	f0019c0 <f_open+0x7f4>
 f001560:	020002c4 	movi	r8,11
 f001564:	00000106 	br	f00156c <f_open+0x3a0>
 f001568:	02000344 	movi	r8,13
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
 f00156c:	dec00915 	stw	sp,36(sp)
 f001570:	00011e06 	br	f0019ec <f_open+0x820>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 f001574:	00801704 	movi	r2,92
 f001578:	18800226 	beq	r3,r2,f001584 <f_open+0x3b8>
 f00157c:	a821883a 	mov	r16,r21
 f001580:	00000106 	br	f001588 <f_open+0x3bc>
		path++;
 f001584:	ac000044 	addi	r16,r21,1
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
 f001588:	80c00003 	ldbu	r3,0(r16)
 f00158c:	008007c4 	movi	r2,31
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
	dj->sclust = 0;						/* Start from the root dir */
 f001590:	d8000515 	stw	zero,20(sp)
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
 f001594:	10c00b36 	bltu	r2,r3,f0015c4 <f_open+0x3f8>
		res = dir_sdi(dj, 0);
 f001598:	d9000304 	addi	r4,sp,12
 f00159c:	000b883a 	mov	r5,zero
 f0015a0:	f0010b00 	call	f0010b0 <dir_sdi>
 f0015a4:	1011883a 	mov	r8,r2
		if (!fp->lockid) res = FR_INT_ERR;
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
 f0015a8:	10011626 	beq	r2,zero,f001a04 <f_open+0x838>
 f0015ac:	00011806 	br	f001a10 <f_open+0x844>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
 f0015b0:	02000084 	movi	r8,2
 f0015b4:	0000be06 	br	f0018b0 <f_open+0x6e4>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 f0015b8:	9011883a 	mov	r8,r18
 f0015bc:	0000bc06 	br	f0018b0 <f_open+0x6e4>
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
 f0015c0:	84000044 	addi	r16,r16,1
 f0015c4:	80c00007 	ldb	r3,0(r16)
 f0015c8:	00800bc4 	movi	r2,47
 f0015cc:	18bffc26 	beq	r3,r2,f0015c0 <f_open+0x3f4>
 f0015d0:	00801704 	movi	r2,92
 f0015d4:	18bffa26 	beq	r3,r2,f0015c0 <f_open+0x3f4>
	sfn = dj->fn;
 f0015d8:	d9800917 	ldw	r6,36(sp)
 f0015dc:	01000804 	movi	r4,32
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
 f0015e0:	3005883a 	mov	r2,r6
 f0015e4:	30c002c4 	addi	r3,r6,11

	while (cnt--)
		*d++ = (BYTE)val;
 f0015e8:	11000005 	stb	r4,0(r2)
 f0015ec:	10800044 	addi	r2,r2,1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
 f0015f0:	10fffd1e 	bne	r2,r3,f0015e8 <f_open+0x41c>
 f0015f4:	0011883a 	mov	r8,zero
 f0015f8:	02800204 	movi	r10,8
 f0015fc:	0013883a 	mov	r9,zero
 f001600:	000f883a 	mov	r7,zero
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 f001604:	8245883a 	add	r2,r16,r9
 f001608:	11000003 	ldbu	r4,0(r2)
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 f00160c:	00800804 	movi	r2,32
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
 f001610:	4a400044 	addi	r9,r9,1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
 f001614:	21403fcc 	andi	r5,r4,255
 f001618:	1140462e 	bgeu	r2,r5,f001734 <f_open+0x568>
 f00161c:	20c03fcc 	andi	r3,r4,255
 f001620:	18c0201c 	xori	r3,r3,128
 f001624:	18ffe004 	addi	r3,r3,-128
 f001628:	00800bc4 	movi	r2,47
 f00162c:	1880e926 	beq	r3,r2,f0019d4 <f_open+0x808>
 f001630:	00801704 	movi	r2,92
 f001634:	1880e726 	beq	r3,r2,f0019d4 <f_open+0x808>
		if (c == '.' || i >= ni) {
 f001638:	00800b84 	movi	r2,46
 f00163c:	18800126 	beq	r3,r2,f001644 <f_open+0x478>
 f001640:	3a800836 	bltu	r7,r10,f001664 <f_open+0x498>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
 f001644:	01000204 	movi	r4,8
 f001648:	5100ee1e 	bne	r10,r4,f001a04 <f_open+0x838>
 f00164c:	1880ed1e 	bne	r3,r2,f001a04 <f_open+0x838>
			i = 8; ni = 11;
			b <<= 2; continue;
 f001650:	4205883a 	add	r2,r8,r8
 f001654:	1091883a 	add	r8,r2,r2
 f001658:	200f883a 	mov	r7,r4
 f00165c:	028002c4 	movi	r10,11
 f001660:	003fe806 	br	f001604 <f_open+0x438>
		}
		if (c >= 0x80) {				/* Extended char? */
 f001664:	1800010e 	bge	r3,zero,f00166c <f_open+0x4a0>
			b |= 3;						/* Eliminate NT flag */
 f001668:	420000d4 	ori	r8,r8,3
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
 f00166c:	20801fc4 	addi	r2,r4,127
 f001670:	10803fcc 	andi	r2,r2,255
 f001674:	00c00784 	movi	r3,30
 f001678:	1880042e 	bgeu	r3,r2,f00168c <f_open+0x4c0>
 f00167c:	20800804 	addi	r2,r4,32
 f001680:	10803fcc 	andi	r2,r2,255
 f001684:	00c00704 	movi	r3,28
 f001688:	18801436 	bltu	r3,r2,f0016dc <f_open+0x510>
			d = (BYTE)p[si++];			/* Get 2nd byte */
 f00168c:	8245883a 	add	r2,r16,r9
 f001690:	11400003 	ldbu	r5,0(r2)
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
 f001694:	00c00f84 	movi	r3,62
 f001698:	28bff004 	addi	r2,r5,-64
 f00169c:	10803fcc 	andi	r2,r2,255
 f0016a0:	1880042e 	bgeu	r3,r2,f0016b4 <f_open+0x4e8>
 f0016a4:	28bfe004 	addi	r2,r5,-128
 f0016a8:	10803fcc 	andi	r2,r2,255
 f0016ac:	00c01f04 	movi	r3,124
 f0016b0:	1880d436 	bltu	r3,r2,f001a04 <f_open+0x838>
 f0016b4:	50bfffc4 	addi	r2,r10,-1
 f0016b8:	3880d22e 	bgeu	r7,r2,f001a04 <f_open+0x838>
				return FR_INVALID_NAME;
			sfn[i++] = c;
 f0016bc:	31c7883a 	add	r3,r6,r7
 f0016c0:	38800044 	addi	r2,r7,1
 f0016c4:	19000005 	stb	r4,0(r3)
			sfn[i++] = d;
 f0016c8:	3085883a 	add	r2,r6,r2
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
 f0016cc:	4a400044 	addi	r9,r9,1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
			sfn[i++] = d;
 f0016d0:	39c00084 	addi	r7,r7,2
 f0016d4:	11400005 	stb	r5,0(r2)
 f0016d8:	003fca06 	br	f001604 <f_open+0x438>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
 f0016dc:	00c3c034 	movhi	r3,3840
 f0016e0:	18c8b904 	addi	r3,r3,8932
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
 f0016e4:	18800007 	ldb	r2,0(r3)
 f0016e8:	18c00044 	addi	r3,r3,1
 f0016ec:	10000226 	beq	r2,zero,f0016f8 <f_open+0x52c>
 f0016f0:	117ffc1e 	bne	r2,r5,f0016e4 <f_open+0x518>
 f0016f4:	0000c306 	br	f001a04 <f_open+0x838>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
 f0016f8:	20bfefc4 	addi	r2,r4,-65
 f0016fc:	10803fcc 	andi	r2,r2,255
 f001700:	00c00644 	movi	r3,25
 f001704:	18800236 	bltu	r3,r2,f001710 <f_open+0x544>
				b |= 2;
 f001708:	42000094 	ori	r8,r8,2
 f00170c:	00000506 	br	f001724 <f_open+0x558>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
 f001710:	20bfe7c4 	addi	r2,r4,-97
 f001714:	10803fcc 	andi	r2,r2,255
 f001718:	18800236 	bltu	r3,r2,f001724 <f_open+0x558>
					b |= 1; c -= 0x20;
 f00171c:	42000054 	ori	r8,r8,1
 f001720:	213ff804 	addi	r4,r4,-32
				}
			}
			sfn[i++] = c;
 f001724:	31c5883a 	add	r2,r6,r7
 f001728:	39c00044 	addi	r7,r7,1
 f00172c:	11000005 	stb	r4,0(r2)
 f001730:	003fb406 	br	f001604 <f_open+0x438>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
 f001734:	8261883a 	add	r16,r16,r9
 f001738:	01400104 	movi	r5,4
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
 f00173c:	3800b126 	beq	r7,zero,f001a04 <f_open+0x838>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
 f001740:	30c00003 	ldbu	r3,0(r6)
 f001744:	00803944 	movi	r2,229
 f001748:	1880021e 	bne	r3,r2,f001754 <f_open+0x588>
 f00174c:	00800144 	movi	r2,5
 f001750:	30800005 	stb	r2,0(r6)

	if (ni == 8) b <<= 2;
 f001754:	00800204 	movi	r2,8
 f001758:	5080021e 	bne	r10,r2,f001764 <f_open+0x598>
 f00175c:	4205883a 	add	r2,r8,r8
 f001760:	1091883a 	add	r8,r2,r2
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
 f001764:	41003fcc 	andi	r4,r8,255
 f001768:	20c000cc 	andi	r3,r4,3
 f00176c:	00800044 	movi	r2,1
 f001770:	1880011e 	bne	r3,r2,f001778 <f_open+0x5ac>
 f001774:	29400414 	ori	r5,r5,16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
 f001778:	20c0030c 	andi	r3,r4,12
 f00177c:	00800104 	movi	r2,4
 f001780:	1880011e 	bne	r3,r2,f001788 <f_open+0x5bc>
 f001784:	29400214 	ori	r5,r5,8

	sfn[NS] = c;		/* Store NT flag, File name is created */
 f001788:	314002c5 	stb	r5,11(r6)
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
 f00178c:	d9000304 	addi	r4,sp,12
 f001790:	000b883a 	mov	r5,zero
 f001794:	f0010b00 	call	f0010b0 <dir_sdi>
 f001798:	1011883a 	mov	r8,r2
	if (res != FR_OK) return res;
 f00179c:	1000441e 	bne	r2,zero,f0018b0 <f_open+0x6e4>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
 f0017a0:	d9000317 	ldw	r4,12(sp)
 f0017a4:	d9400717 	ldw	r5,28(sp)
 f0017a8:	f000c980 	call	f000c98 <move_window>
 f0017ac:	1011883a 	mov	r8,r2
		if (res != FR_OK) break;
 f0017b0:	10003f1e 	bne	r2,zero,f0018b0 <f_open+0x6e4>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
 f0017b4:	d9800817 	ldw	r6,32(sp)
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 f0017b8:	30800003 	ldbu	r2,0(r6)
 f0017bc:	10008e26 	beq	r2,zero,f0019f8 <f_open+0x82c>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 f0017c0:	308002c3 	ldbu	r2,11(r6)
 f0017c4:	1080020c 	andi	r2,r2,8
 f0017c8:	1000101e 	bne	r2,zero,f00180c <f_open+0x640>
 f0017cc:	d9c00917 	ldw	r7,36(sp)
 f0017d0:	000b883a 	mov	r5,zero
 f0017d4:	024002c4 	movi	r9,11
 f0017d8:	00000106 	br	f0017e0 <f_open+0x614>
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 f0017dc:	2a400726 	beq	r5,r9,f0017fc <f_open+0x630>
 f0017e0:	3145883a 	add	r2,r6,r5
 f0017e4:	3947883a 	add	r3,r7,r5
 f0017e8:	11000003 	ldbu	r4,0(r2)
 f0017ec:	18800003 	ldbu	r2,0(r3)
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 f0017f0:	29400044 	addi	r5,r5,1
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
 f0017f4:	20bff926 	beq	r4,r2,f0017dc <f_open+0x610>
 f0017f8:	00000406 	br	f00180c <f_open+0x640>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
 f0017fc:	388002c3 	ldbu	r2,11(r7)
 f001800:	1080010c 	andi	r2,r2,4
 f001804:	10003126 	beq	r2,zero,f0018cc <f_open+0x700>
 f001808:	00007506 	br	f0019e0 <f_open+0x814>
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
 f00180c:	d880048b 	ldhu	r2,18(sp)
 f001810:	14c00044 	addi	r19,r2,1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 f001814:	98ffffcc 	andi	r3,r19,65535
 f001818:	18002426 	beq	r3,zero,f0018ac <f_open+0x6e0>
 f00181c:	d8800717 	ldw	r2,28(sp)
 f001820:	10002226 	beq	r2,zero,f0018ac <f_open+0x6e0>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
 f001824:	1c4003cc 	andi	r17,r3,15
 f001828:	8800191e 	bne	r17,zero,f001890 <f_open+0x6c4>
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
 f00182c:	d9400617 	ldw	r5,24(sp)
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
 f001830:	10800044 	addi	r2,r2,1
 f001834:	d8800715 	stw	r2,28(sp)
 f001838:	04800044 	movi	r18,1
 f00183c:	d9000317 	ldw	r4,12(sp)

		if (dj->clust == 0) {	/* Static table */
 f001840:	2800031e 	bne	r5,zero,f001850 <f_open+0x684>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
 f001844:	2080020b 	ldhu	r2,8(r4)
 f001848:	18801136 	bltu	r3,r2,f001890 <f_open+0x6c4>
 f00184c:	00001706 	br	f0018ac <f_open+0x6e0>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
 f001850:	20800083 	ldbu	r2,2(r4)
 f001854:	1806d13a 	srli	r3,r3,4
 f001858:	10bfffc4 	addi	r2,r2,-1
 f00185c:	1886703a 	and	r3,r3,r2
 f001860:	18000b1e 	bne	r3,zero,f001890 <f_open+0x6c4>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
 f001864:	f000d000 	call	f000d00 <get_fat>
 f001868:	100b883a 	mov	r5,r2
				if (clst <= 1) return FR_INT_ERR;
 f00186c:	90bf502e 	bgeu	r18,r2,f0015b0 <f_open+0x3e4>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
 f001870:	00bfffc4 	movi	r2,-1
 f001874:	28bf5026 	beq	r5,r2,f0015b8 <f_open+0x3ec>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
 f001878:	d9000317 	ldw	r4,12(sp)
 f00187c:	20800317 	ldw	r2,12(r4)
 f001880:	28800a2e 	bgeu	r5,r2,f0018ac <f_open+0x6e0>
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
 f001884:	d9400615 	stw	r5,24(sp)
				dj->sect = clust2sect(dj->fs, clst);
 f001888:	f000ab80 	call	f000ab8 <clust2sect>
 f00188c:	d8800715 	stw	r2,28(sp)
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 f001890:	d8800317 	ldw	r2,12(sp)
 f001894:	8806917a 	slli	r3,r17,5
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
 f001898:	dcc0048d 	sth	r19,18(sp)
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
 f00189c:	10800904 	addi	r2,r2,36
 f0018a0:	10c5883a 	add	r2,r2,r3
 f0018a4:	d8800815 	stw	r2,32(sp)
 f0018a8:	003fbd06 	br	f0017a0 <f_open+0x5d4>
 f0018ac:	02000104 	movi	r8,4
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
 f0018b0:	d8800917 	ldw	r2,36(sp)
 f0018b4:	10c002c3 	ldbu	r3,11(r2)
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
 f0018b8:	00800104 	movi	r2,4
 f0018bc:	40804b1e 	bne	r8,r2,f0019ec <f_open+0x820>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
 f0018c0:	1880010c 	andi	r2,r3,4
 f0018c4:	10005126 	beq	r2,zero,f001a0c <f_open+0x840>
 f0018c8:	00001206 	br	f001914 <f_open+0x748>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
 f0018cc:	308002c3 	ldbu	r2,11(r6)
 f0018d0:	1080040c 	andi	r2,r2,16
 f0018d4:	10004d26 	beq	r2,zero,f001a0c <f_open+0x840>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
 f0018d8:	30800543 	ldbu	r2,21(r6)
 f0018dc:	31400503 	ldbu	r5,20(r6)
 f0018e0:	30c006c3 	ldbu	r3,27(r6)
 f0018e4:	1004923a 	slli	r2,r2,8
 f0018e8:	31000683 	ldbu	r4,26(r6)
 f0018ec:	1806923a 	slli	r3,r3,8
 f0018f0:	1144b03a 	or	r2,r2,r5
 f0018f4:	1004943a 	slli	r2,r2,16
 f0018f8:	1906b03a 	or	r3,r3,r4
 f0018fc:	10c4b03a 	or	r2,r2,r3
 f001900:	d8800515 	stw	r2,20(sp)
 f001904:	003f2f06 	br	f0015c4 <f_open+0x3f8>
#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
		if (!dir) {						/* Current dir itself */
			res = FR_INVALID_NAME;
		} else {
			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
 f001908:	388002c3 	ldbu	r2,11(r7)
 f00190c:	1080040c 	andi	r2,r2,16
 f001910:	10000226 	beq	r2,zero,f00191c <f_open+0x750>
 f001914:	02000104 	movi	r8,4
 f001918:	00003d06 	br	f001a10 <f_open+0x844>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
 f00191c:	d8c00a03 	ldbu	r3,40(sp)
 f001920:	1880004c 	andi	r2,r3,1
 f001924:	e0800185 	stb	r2,6(fp)
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
 f001928:	38800543 	ldbu	r2,21(r7)
 f00192c:	39400503 	ldbu	r5,20(r7)
 f001930:	38c006c3 	ldbu	r3,27(r7)
 f001934:	1004923a 	slli	r2,r2,8
 f001938:	39000683 	ldbu	r4,26(r7)
 f00193c:	1806923a 	slli	r3,r3,8
 f001940:	1144b03a 	or	r2,r2,r5
 f001944:	1004943a 	slli	r2,r2,16
 f001948:	1906b03a 	or	r3,r3,r4
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 f00194c:	d9800317 	ldw	r6,12(sp)
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
 f001950:	10c4b03a 	or	r2,r2,r3
 f001954:	e0800415 	stw	r2,16(fp)
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 f001958:	388007c3 	ldbu	r2,31(r7)
 f00195c:	38c00783 	ldbu	r3,30(r7)
 f001960:	39000743 	ldbu	r4,29(r7)
 f001964:	1004963a 	slli	r2,r2,24
 f001968:	1806943a 	slli	r3,r3,16
 f00196c:	39400703 	ldbu	r5,28(r7)
 f001970:	2008923a 	slli	r4,r4,8
 f001974:	10c4b03a 	or	r2,r2,r3
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 f001978:	30c0018b 	ldhu	r3,6(r6)
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 f00197c:	1144b03a 	or	r2,r2,r5
 f001980:	2088b03a 	or	r4,r4,r2
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 f001984:	e0c0010d 	sth	r3,4(fp)
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 f001988:	e1000315 	stw	r4,12(fp)
		fp->fptr = 0;						/* File pointer */
 f00198c:	e0000215 	stw	zero,8(fp)
		fp->dsect = 0;
 f001990:	e0000615 	stw	zero,24(fp)
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
 f001994:	e1800015 	stw	r6,0(fp)
 f001998:	00001d06 	br	f001a10 <f_open+0x844>
	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 f00199c:	8140020b 	ldhu	r5,8(r16)
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 f0019a0:	18800084 	addi	r2,r3,2
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 f0019a4:	bcc9883a 	add	r4,r23,r19
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
 f0019a8:	bc87883a 	add	r3,r23,r18
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
 f0019ac:	80800315 	stw	r2,12(r16)
	fs->database = bsect + sysect;						/* Data start sector */
 f0019b0:	80c00715 	stw	r3,28(r16)
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
 f0019b4:	81000515 	stw	r4,20(r16)
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
 f0019b8:	283eeb1e 	bne	r5,zero,f001568 <f_open+0x39c>
 f0019bc:	003ebf06 	br	f0014bc <f_open+0x2f0>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 f0019c0:	a8c00007 	ldb	r3,0(r21)
 f0019c4:	00800bc4 	movi	r2,47
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
 f0019c8:	dec00915 	stw	sp,36(sp)
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
 f0019cc:	18bee91e 	bne	r3,r2,f001574 <f_open+0x3a8>
 f0019d0:	003eec06 	br	f001584 <f_open+0x3b8>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
 f0019d4:	8261883a 	add	r16,r16,r9
 f0019d8:	000b883a 	mov	r5,zero
 f0019dc:	003f5706 	br	f00173c <f_open+0x570>
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
 f0019e0:	d9c00817 	ldw	r7,32(sp)
#endif
	}

#else				/* R/O configuration */
	if (res == FR_OK) {					/* Follow succeeded */
		if (!dir) {						/* Current dir itself */
 f0019e4:	383fc81e 	bne	r7,zero,f001908 <f_open+0x73c>
 f0019e8:	00000606 	br	f001a04 <f_open+0x838>
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
	dir = dj.dir;
 f0019ec:	d9c00817 	ldw	r7,32(sp)
		}
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
 f0019f0:	403fca26 	beq	r8,zero,f00191c <f_open+0x750>
 f0019f4:	00000606 	br	f001a10 <f_open+0x844>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
 f0019f8:	d8800917 	ldw	r2,36(sp)
 f0019fc:	10c002c3 	ldbu	r3,11(r2)
 f001a00:	003faf06 	br	f0018c0 <f_open+0x6f4>
 f001a04:	02000184 	movi	r8,6
 f001a08:	00000106 	br	f001a10 <f_open+0x844>
 f001a0c:	02000144 	movi	r8,5
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
 f001a10:	4005883a 	mov	r2,r8
 f001a14:	dfc01417 	ldw	ra,80(sp)
 f001a18:	df001317 	ldw	fp,76(sp)
 f001a1c:	ddc01217 	ldw	r23,72(sp)
 f001a20:	dd801117 	ldw	r22,68(sp)
 f001a24:	dd401017 	ldw	r21,64(sp)
 f001a28:	dd000f17 	ldw	r20,60(sp)
 f001a2c:	dcc00e17 	ldw	r19,56(sp)
 f001a30:	dc800d17 	ldw	r18,52(sp)
 f001a34:	dc400c17 	ldw	r17,48(sp)
 f001a38:	dc000b17 	ldw	r16,44(sp)
 f001a3c:	dec01504 	addi	sp,sp,84
 f001a40:	f800283a 	ret

0f001a44 <udivmodsi4>:
 f001a44:	29001b2e 	bgeu	r5,r4,f001ab4 <udivmodsi4+0x70>
 f001a48:	28001a16 	blt	r5,zero,f001ab4 <udivmodsi4+0x70>
 f001a4c:	00800044 	movi	r2,1
 f001a50:	0007883a 	mov	r3,zero
 f001a54:	01c007c4 	movi	r7,31
 f001a58:	00000306 	br	f001a68 <udivmodsi4+0x24>
 f001a5c:	19c01326 	beq	r3,r7,f001aac <udivmodsi4+0x68>
 f001a60:	18c00044 	addi	r3,r3,1
 f001a64:	28000416 	blt	r5,zero,f001a78 <udivmodsi4+0x34>
 f001a68:	294b883a 	add	r5,r5,r5
 f001a6c:	1085883a 	add	r2,r2,r2
 f001a70:	293ffa36 	bltu	r5,r4,f001a5c <udivmodsi4+0x18>
 f001a74:	10000d26 	beq	r2,zero,f001aac <udivmodsi4+0x68>
 f001a78:	0007883a 	mov	r3,zero
 f001a7c:	21400236 	bltu	r4,r5,f001a88 <udivmodsi4+0x44>
 f001a80:	2149c83a 	sub	r4,r4,r5
 f001a84:	1886b03a 	or	r3,r3,r2
 f001a88:	1004d07a 	srli	r2,r2,1
 f001a8c:	280ad07a 	srli	r5,r5,1
 f001a90:	103ffa1e 	bne	r2,zero,f001a7c <udivmodsi4+0x38>
 f001a94:	30000226 	beq	r6,zero,f001aa0 <udivmodsi4+0x5c>
 f001a98:	2005883a 	mov	r2,r4
 f001a9c:	f800283a 	ret
 f001aa0:	1809883a 	mov	r4,r3
 f001aa4:	2005883a 	mov	r2,r4
 f001aa8:	f800283a 	ret
 f001aac:	0007883a 	mov	r3,zero
 f001ab0:	003ff806 	br	f001a94 <udivmodsi4+0x50>
 f001ab4:	00800044 	movi	r2,1
 f001ab8:	0007883a 	mov	r3,zero
 f001abc:	003fef06 	br	f001a7c <udivmodsi4+0x38>

0f001ac0 <__divsi3>:
 f001ac0:	defffe04 	addi	sp,sp,-8
 f001ac4:	dc000015 	stw	r16,0(sp)
 f001ac8:	dfc00115 	stw	ra,4(sp)
 f001acc:	0021883a 	mov	r16,zero
 f001ad0:	20000c16 	blt	r4,zero,f001b04 <__divsi3+0x44>
 f001ad4:	000d883a 	mov	r6,zero
 f001ad8:	28000e16 	blt	r5,zero,f001b14 <__divsi3+0x54>
 f001adc:	f001a440 	call	f001a44 <udivmodsi4>
 f001ae0:	1007883a 	mov	r3,r2
 f001ae4:	8005003a 	cmpeq	r2,r16,zero
 f001ae8:	1000011e 	bne	r2,zero,f001af0 <__divsi3+0x30>
 f001aec:	00c7c83a 	sub	r3,zero,r3
 f001af0:	1805883a 	mov	r2,r3
 f001af4:	dfc00117 	ldw	ra,4(sp)
 f001af8:	dc000017 	ldw	r16,0(sp)
 f001afc:	dec00204 	addi	sp,sp,8
 f001b00:	f800283a 	ret
 f001b04:	0109c83a 	sub	r4,zero,r4
 f001b08:	04000044 	movi	r16,1
 f001b0c:	000d883a 	mov	r6,zero
 f001b10:	283ff20e 	bge	r5,zero,f001adc <__divsi3+0x1c>
 f001b14:	014bc83a 	sub	r5,zero,r5
 f001b18:	8021003a 	cmpeq	r16,r16,zero
 f001b1c:	003fef06 	br	f001adc <__divsi3+0x1c>

0f001b20 <__modsi3>:
 f001b20:	deffff04 	addi	sp,sp,-4
 f001b24:	dfc00015 	stw	ra,0(sp)
 f001b28:	01800044 	movi	r6,1
 f001b2c:	2807883a 	mov	r3,r5
 f001b30:	20000416 	blt	r4,zero,f001b44 <__modsi3+0x24>
 f001b34:	28000c16 	blt	r5,zero,f001b68 <__modsi3+0x48>
 f001b38:	dfc00017 	ldw	ra,0(sp)
 f001b3c:	dec00104 	addi	sp,sp,4
 f001b40:	f001a441 	jmpi	f001a44 <udivmodsi4>
 f001b44:	0109c83a 	sub	r4,zero,r4
 f001b48:	28000b16 	blt	r5,zero,f001b78 <__modsi3+0x58>
 f001b4c:	180b883a 	mov	r5,r3
 f001b50:	01800044 	movi	r6,1
 f001b54:	f001a440 	call	f001a44 <udivmodsi4>
 f001b58:	0085c83a 	sub	r2,zero,r2
 f001b5c:	dfc00017 	ldw	ra,0(sp)
 f001b60:	dec00104 	addi	sp,sp,4
 f001b64:	f800283a 	ret
 f001b68:	014bc83a 	sub	r5,zero,r5
 f001b6c:	dfc00017 	ldw	ra,0(sp)
 f001b70:	dec00104 	addi	sp,sp,4
 f001b74:	f001a441 	jmpi	f001a44 <udivmodsi4>
 f001b78:	0147c83a 	sub	r3,zero,r5
 f001b7c:	003ff306 	br	f001b4c <__modsi3+0x2c>

0f001b80 <__udivsi3>:
 f001b80:	000d883a 	mov	r6,zero
 f001b84:	f001a441 	jmpi	f001a44 <udivmodsi4>

0f001b88 <__umodsi3>:
 f001b88:	01800044 	movi	r6,1
 f001b8c:	f001a441 	jmpi	f001a44 <udivmodsi4>

0f001b90 <__mulsi3>:
 f001b90:	20000a26 	beq	r4,zero,f001bbc <__mulsi3+0x2c>
 f001b94:	0007883a 	mov	r3,zero
 f001b98:	2080004c 	andi	r2,r4,1
 f001b9c:	1005003a 	cmpeq	r2,r2,zero
 f001ba0:	2008d07a 	srli	r4,r4,1
 f001ba4:	1000011e 	bne	r2,zero,f001bac <__mulsi3+0x1c>
 f001ba8:	1947883a 	add	r3,r3,r5
 f001bac:	294b883a 	add	r5,r5,r5
 f001bb0:	203ff91e 	bne	r4,zero,f001b98 <__mulsi3+0x8>
 f001bb4:	1805883a 	mov	r2,r3
 f001bb8:	f800283a 	ret
 f001bbc:	0007883a 	mov	r3,zero
 f001bc0:	1805883a 	mov	r2,r3
 f001bc4:	f800283a 	ret

0f001bc8 <alt_alarm_start>:
                     void* context)
{
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  
  if (alt_ticks_per_second ())
 f001bc8:	00800034 	movhi	r2,0
 f001bcc:	10801004 	addi	r2,r2,64
 f001bd0:	10800017 	ldw	r2,0(r2)
 f001bd4:	00ffde84 	movi	r3,-134
 f001bd8:	10001d26 	beq	r2,zero,f001c50 <alt_alarm_start+0x88>
  {
    if (alarm)
 f001bdc:	00fffa84 	movi	r3,-22
 f001be0:	20001b26 	beq	r4,zero,f001c50 <alt_alarm_start+0x88>
    {
      alarm->callback = callback;
 f001be4:	21800315 	stw	r6,12(r4)
      alarm->context  = context;
 f001be8:	21c00515 	stw	r7,20(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 f001bec:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 f001bf0:	00bfff84 	movi	r2,-2
 f001bf4:	3084703a 	and	r2,r6,r2
 f001bf8:	1001703a 	wrctl	status,r2
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 f001bfc:	00800034 	movhi	r2,0
 f001c00:	10801104 	addi	r2,r2,68
 f001c04:	10c00017 	ldw	r3,0(r2)
 
      irq_context = alt_irq_disable_all ();
      
      current_nticks = alt_nticks();
      
      alarm->time = nticks + current_nticks + 1; 
 f001c08:	18800044 	addi	r2,r3,1
 f001c0c:	2885883a 	add	r2,r5,r2
 f001c10:	20800215 	stw	r2,8(r4)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 f001c14:	10c0032e 	bgeu	r2,r3,f001c24 <alt_alarm_start+0x5c>
      {
        alarm->rollover = 1;
 f001c18:	00800044 	movi	r2,1
 f001c1c:	20800405 	stb	r2,16(r4)
 f001c20:	00000106 	br	f001c28 <alt_alarm_start+0x60>
      }
      else
      {
        alarm->rollover = 0;
 f001c24:	20000405 	stb	zero,16(r4)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 f001c28:	00800034 	movhi	r2,0
 f001c2c:	10800204 	addi	r2,r2,8
  entry->next     = list->next;
 f001c30:	10c00017 	ldw	r3,0(r2)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 f001c34:	20800115 	stw	r2,4(r4)
  entry->next     = list->next;
 f001c38:	20c00015 	stw	r3,0(r4)

  list->next->previous = entry;
 f001c3c:	10c00017 	ldw	r3,0(r2)
  list->next           = entry;
 f001c40:	11000015 	stw	r4,0(r2)
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;

  list->next->previous = entry;
 f001c44:	19000115 	stw	r4,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 f001c48:	3001703a 	wrctl	status,r6
 f001c4c:	0007883a 	mov	r3,zero
  }
  else
  {
    return -ENOTSUP;
  }
}
 f001c50:	1805883a 	mov	r2,r3
 f001c54:	f800283a 	ret

0f001c58 <alt_irq_register>:
                      alt_isr_func handler)
{
  int rc = -EINVAL;  
  alt_irq_context status;

  if (id < ALT_NIRQ)
 f001c58:	008007c4 	movi	r2,31
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
 f001c5c:	200f883a 	mov	r7,r4
  int rc = -EINVAL;  
  alt_irq_context status;

  if (id < ALT_NIRQ)
 f001c60:	00fffa84 	movi	r3,-22
 f001c64:	11002236 	bltu	r2,r4,f001cf0 <alt_irq_register+0x98>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 f001c68:	0015303a 	rdctl	r10,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 f001c6c:	027fff84 	movi	r9,-2
 f001c70:	5244703a 	and	r2,r10,r9
 f001c74:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all ();

    alt_irq[id].handler = handler;
 f001c78:	200490fa 	slli	r2,r4,3
 f001c7c:	00c00034 	movhi	r3,0
 f001c80:	18c01e04 	addi	r3,r3,120
 f001c84:	02000034 	movhi	r8,0
 f001c88:	42000c04 	addi	r8,r8,48
 f001c8c:	10c5883a 	add	r2,r2,r3
    alt_irq[id].context = context;
 f001c90:	11400115 	stw	r5,4(r2)
     * state.
     */

    status = alt_irq_disable_all ();

    alt_irq[id].handler = handler;
 f001c94:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = context;

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 f001c98:	30000826 	beq	r6,zero,f001cbc <alt_irq_register+0x64>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 f001c9c:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 f001ca0:	2244703a 	and	r2,r4,r9
 f001ca4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
 f001ca8:	00c00044 	movi	r3,1
 f001cac:	19c6983a 	sll	r3,r3,r7
 f001cb0:	40800017 	ldw	r2,0(r8)
 f001cb4:	10c4b03a 	or	r2,r2,r3
 f001cb8:	00000706 	br	f001cd8 <alt_irq_register+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 f001cbc:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 f001cc0:	2244703a 	and	r2,r4,r9
 f001cc4:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
 f001cc8:	00ffff84 	movi	r3,-2
 f001ccc:	19c6183a 	rol	r3,r3,r7
 f001cd0:	40800017 	ldw	r2,0(r8)
 f001cd4:	10c4703a 	and	r2,r2,r3
 f001cd8:	40800015 	stw	r2,0(r8)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 f001cdc:	40800017 	ldw	r2,0(r8)
 f001ce0:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 f001ce4:	2001703a 	wrctl	status,r4
 f001ce8:	5001703a 	wrctl	status,r10
 f001cec:	0007883a 	mov	r3,zero

    alt_irq_enable_all(status);
  }
  return rc; 
}
 f001cf0:	1805883a 	mov	r2,r3
 f001cf4:	f800283a 	ret

0f001cf8 <alt_load_section>:

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
 f001cf8:	2900051e 	bne	r5,r4,f001d10 <alt_load_section+0x18>
 f001cfc:	f800283a 	ret
  {
    while( to != end )
    {
      *to++ = *from++;
 f001d00:	20800017 	ldw	r2,0(r4)
 f001d04:	21000104 	addi	r4,r4,4
 f001d08:	28800015 	stw	r2,0(r5)
 f001d0c:	29400104 	addi	r5,r5,4
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 f001d10:	29bffb1e 	bne	r5,r6,f001d00 <alt_load_section+0x8>
 f001d14:	f800283a 	ret

0f001d18 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 f001d18:	deffff04 	addi	sp,sp,-4
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 f001d1c:	0103c034 	movhi	r4,3840
 f001d20:	2108e604 	addi	r4,r4,9112
 f001d24:	01400034 	movhi	r5,0
 f001d28:	29400004 	addi	r5,r5,0
 f001d2c:	01800034 	movhi	r6,0
 f001d30:	31800604 	addi	r6,r6,24
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 f001d34:	dfc00015 	stw	ra,0(sp)
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 f001d38:	f001cf80 	call	f001cf8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 f001d3c:	0103c034 	movhi	r4,3840
 f001d40:	21000804 	addi	r4,r4,32
 f001d44:	0143c034 	movhi	r5,3840
 f001d48:	29400804 	addi	r5,r5,32
 f001d4c:	0183c034 	movhi	r6,3840
 f001d50:	31807a04 	addi	r6,r6,488
 f001d54:	f001cf80 	call	f001cf8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 f001d58:	0103c034 	movhi	r4,3840
 f001d5c:	2108b604 	addi	r4,r4,8920
 f001d60:	0143c034 	movhi	r5,3840
 f001d64:	2948b604 	addi	r5,r5,8920
 f001d68:	0183c034 	movhi	r6,3840
 f001d6c:	3188e604 	addi	r6,r6,9112
 f001d70:	f001cf80 	call	f001cf8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 f001d74:	f0022c80 	call	f0022c8 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
 f001d78:	dfc00017 	ldw	ra,0(sp)
 f001d7c:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
 f001d80:	f0022cc1 	jmpi	f0022cc <alt_icache_flush_all>

0f001d84 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 f001d84:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 f001d88:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 f001d8c:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 f001d90:	f001ec80 	call	f001ec8 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 f001d94:	f001e900 	call	f001e90 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 f001d98:	d1200d17 	ldw	r4,-32716(gp)
 f001d9c:	d1600e17 	ldw	r5,-32712(gp)
 f001da0:	d1a00f17 	ldw	r6,-32708(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 f001da4:	dfc00017 	ldw	ra,0(sp)
 f001da8:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 f001dac:	f0002241 	jmpi	f000224 <main>

0f001db0 <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 f001db0:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 f001db4:	00bfff84 	movi	r2,-2
 f001db8:	2884703a 	and	r2,r5,r2
 f001dbc:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 f001dc0:	20c00017 	ldw	r3,0(r4)
 f001dc4:	20800117 	ldw	r2,4(r4)
 f001dc8:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 f001dcc:	20800117 	ldw	r2,4(r4)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 f001dd0:	21000115 	stw	r4,4(r4)
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  entry->previous->next = entry->next;
 f001dd4:	10c00015 	stw	r3,0(r2)
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  entry->next     = entry;
 f001dd8:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 f001ddc:	2801703a 	wrctl	status,r5
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  alt_llist_remove (&alarm->llist);
  alt_irq_enable_all (irq_context);
}
 f001de0:	f800283a 	ret

0f001de4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 f001de4:	defffd04 	addi	sp,sp,-12

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 f001de8:	d0a01117 	ldw	r2,-32700(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 f001dec:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 f001df0:	d4200217 	ldw	r16,-32760(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 f001df4:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 f001df8:	dfc00215 	stw	ra,8(sp)
 f001dfc:	dc400115 	stw	r17,4(sp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 f001e00:	d0a01115 	stw	r2,-32700(gp)
 f001e04:	00001b06 	br	f001e74 <alt_tick+0x90>
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 f001e08:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
 f001e0c:	84400017 	ldw	r17,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 f001e10:	10000326 	beq	r2,zero,f001e20 <alt_tick+0x3c>
 f001e14:	d0a01117 	ldw	r2,-32700(gp)
 f001e18:	1000011e 	bne	r2,zero,f001e20 <alt_tick+0x3c>
    {
      alarm->rollover = 0;
 f001e1c:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 f001e20:	d0e01117 	ldw	r3,-32700(gp)
 f001e24:	80800217 	ldw	r2,8(r16)
 f001e28:	18801136 	bltu	r3,r2,f001e70 <alt_tick+0x8c>
 f001e2c:	80800403 	ldbu	r2,16(r16)
 f001e30:	10000f1e 	bne	r2,zero,f001e70 <alt_tick+0x8c>
    {
      next_callback = alarm->callback (alarm->context);
 f001e34:	81000517 	ldw	r4,20(r16)
 f001e38:	80800317 	ldw	r2,12(r16)
 f001e3c:	103ee83a 	callr	r2
 f001e40:	1009883a 	mov	r4,r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 f001e44:	1000031e 	bne	r2,zero,f001e54 <alt_tick+0x70>
      {
        alt_alarm_stop (alarm);
 f001e48:	8009883a 	mov	r4,r16
 f001e4c:	f001db00 	call	f001db0 <alt_alarm_stop>
 f001e50:	00000706 	br	f001e70 <alt_tick+0x8c>
      }
      else
      {
        alarm->time += next_callback;
 f001e54:	80800217 	ldw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 f001e58:	d0e01117 	ldw	r3,-32700(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
 f001e5c:	1105883a 	add	r2,r2,r4
 f001e60:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 f001e64:	10c0022e 	bgeu	r2,r3,f001e70 <alt_tick+0x8c>
        {
          alarm->rollover = 1;
 f001e68:	00800044 	movi	r2,1
 f001e6c:	80800405 	stb	r2,16(r16)
 f001e70:	8821883a 	mov	r16,r17

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 f001e74:	d0a00204 	addi	r2,gp,-32760
 f001e78:	80bfe31e 	bne	r16,r2,f001e08 <alt_tick+0x24>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 f001e7c:	dfc00217 	ldw	ra,8(sp)
 f001e80:	dc400117 	ldw	r17,4(sp)
 f001e84:	dc000017 	ldw	r16,0(sp)
 f001e88:	dec00304 	addi	sp,sp,12
 f001e8c:	f800283a 	ret

0f001e90 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 f001e90:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 f001e94:	000b883a 	mov	r5,zero
 f001e98:	01800084 	movi	r6,2
 f001e9c:	01c0fa04 	movi	r7,1000
 f001ea0:	01040034 	movhi	r4,4096
 f001ea4:	21004004 	addi	r4,r4,256
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 f001ea8:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 f001eac:	f0021800 	call	f002180 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( ROM_0, rom_0);
    ALTERA_AVALON_FIFO_INIT ( FIFO_0, fifo_0);
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
    M2VDD_HX8347A_INIT ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);
 f001eb0:	d1200404 	addi	r4,gp,-32752
 f001eb4:	f0022140 	call	f002214 <m2vdd_hx8347a_init>
    M2VDEC_INIT ( M2VDEC_0, m2vdec_0);
 f001eb8:	d1200504 	addi	r4,gp,-32748
}
 f001ebc:	dfc00017 	ldw	ra,0(sp)
 f001ec0:	dec00104 	addi	sp,sp,4
    ALTERA_AVALON_CFI_FLASH_INIT ( ROM_0, rom_0);
    ALTERA_AVALON_FIFO_INIT ( FIFO_0, fifo_0);
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
    M2VDD_HX8347A_INIT ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);
    M2VDEC_INIT ( M2VDEC_0, m2vdec_0);
 f001ec4:	f0022c41 	jmpi	f0022c4 <m2vdec_init>

0f001ec8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 f001ec8:	deffff04 	addi	sp,sp,-4
 f001ecc:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS_0, nios2_qsys_0);
 f001ed0:	f0022d00 	call	f0022d0 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 f001ed4:	00800044 	movi	r2,1
 f001ed8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 f001edc:	dfc00017 	ldw	ra,0(sp)
 f001ee0:	dec00104 	addi	sp,sp,4
 f001ee4:	f800283a 	ret

0f001ee8 <altera_avalon_fifo_read_backpressure>:
}

int altera_avalon_fifo_read_backpressure (alt_u32 read_address){
    // Read data from FIFO directly. If FIFO is empty and backpressure is supported, this call is backpressure.
    return IORD_ALTERA_AVALON_FIFO_DATA(read_address);  
}
 f001ee8:	20800037 	ldwio	r2,0(r4)
 f001eec:	f800283a 	ret

0f001ef0 <altera_avalon_fifo_read_other_info>:
}

int altera_avalon_fifo_read_other_info(alt_u32 read_address)
{
    return IORD_ALTERA_AVALON_FIFO_OTHER_INFO(read_address);
}
 f001ef0:	20800137 	ldwio	r2,4(r4)
 f001ef4:	f800283a 	ret

0f001ef8 <altera_avalon_fifo_read_level>:
}

int altera_avalon_fifo_read_level(alt_u32 address)
{
    return IORD_ALTERA_AVALON_FIFO_LEVEL(address);
}
 f001ef8:	20800037 	ldwio	r2,0(r4)
 f001efc:	f800283a 	ret

0f001f00 <altera_avalon_fifo_read_event>:
    return IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address);
}

int altera_avalon_fifo_read_event(alt_u32 address, alt_u32 mask)
{
    return (IORD_ALTERA_AVALON_FIFO_EVENT(address) & mask);
 f001f00:	20800237 	ldwio	r2,8(r4)
}
 f001f04:	1144703a 	and	r2,r2,r5
 f001f08:	f800283a 	ret

0f001f0c <altera_avalon_fifo_read_almostempty>:
}

int altera_avalon_fifo_read_almostempty(alt_u32 address)
{
    return IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address);
}
 f001f0c:	20800537 	ldwio	r2,20(r4)
 f001f10:	f800283a 	ret

0f001f14 <altera_avalon_fifo_read_almostfull>:
}

int altera_avalon_fifo_read_almostfull(alt_u32 address)
{
    return IORD_ALTERA_AVALON_FIFO_ALMOSTFULL(address);
}
 f001f14:	20800437 	ldwio	r2,16(r4)
 f001f18:	f800283a 	ret

0f001f1c <altera_avalon_fifo_read_ienable>:
}

int altera_avalon_fifo_read_ienable(alt_u32 address, alt_u32 mask)
{
	
    return (IORD_ALTERA_AVALON_FIFO_IENABLE(address) & mask);
 f001f1c:	20800337 	ldwio	r2,12(r4)
}
 f001f20:	1144703a 	and	r2,r2,r5
 f001f24:	f800283a 	ret

0f001f28 <altera_avalon_fifo_read_status>:
    return ALTERA_AVALON_FIFO_OK;
}

int altera_avalon_fifo_read_status(alt_u32 address, alt_u32 mask)
{
    return (IORD_ALTERA_AVALON_FIFO_STATUS(address) & mask);
 f001f28:	20800137 	ldwio	r2,4(r4)
}
 f001f2c:	1144703a 	and	r2,r2,r5
 f001f30:	f800283a 	ret

0f001f34 <altera_avalon_fifo_read_fifo>:
    }
    return return_val;
}

int altera_avalon_fifo_read_fifo(alt_u32 read_address, alt_u32 ctrl_address)
{
 f001f34:	defffe04 	addi	sp,sp,-8
 f001f38:	dc000015 	stw	r16,0(sp)
 f001f3c:	2021883a 	mov	r16,r4
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 f001f40:	2809883a 	mov	r4,r5
 f001f44:	01400084 	movi	r5,2
    }
    return return_val;
}

int altera_avalon_fifo_read_fifo(alt_u32 read_address, alt_u32 ctrl_address)
{
 f001f48:	dfc00115 	stw	ra,4(sp)
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 f001f4c:	f001f280 	call	f001f28 <altera_avalon_fifo_read_status>
 f001f50:	0007883a 	mov	r3,zero
 f001f54:	1000011e 	bne	r2,zero,f001f5c <altera_avalon_fifo_read_fifo+0x28>
    {
        return IORD_ALTERA_AVALON_FIFO_DATA(read_address);
 f001f58:	80c00037 	ldwio	r3,0(r16)
    }
    return 0;
}
 f001f5c:	1805883a 	mov	r2,r3
 f001f60:	dfc00117 	ldw	ra,4(sp)
 f001f64:	dc000017 	ldw	r16,0(sp)
 f001f68:	dec00204 	addi	sp,sp,8
 f001f6c:	f800283a 	ret

0f001f70 <altera_avalon_read_fifo>:
        return ALTERA_AVALON_FIFO_FULL;
    }
}

int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
 f001f70:	defffc04 	addi	sp,sp,-16
 f001f74:	dc800215 	stw	r18,8(sp)
 f001f78:	dc000015 	stw	r16,0(sp)
 f001f7c:	2025883a 	mov	r18,r4
 f001f80:	2821883a 	mov	r16,r5
    int return_val = 0;
    *data = 0;
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 f001f84:	2809883a 	mov	r4,r5
}

int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
    int return_val = 0;
    *data = 0;
 f001f88:	30000015 	stw	zero,0(r6)
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 f001f8c:	01400084 	movi	r5,2
        return ALTERA_AVALON_FIFO_FULL;
    }
}

int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
 f001f90:	dc400115 	stw	r17,4(sp)
 f001f94:	dfc00315 	stw	ra,12(sp)
 f001f98:	3023883a 	mov	r17,r6
    int return_val = 0;
    *data = 0;
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 f001f9c:	f001f280 	call	f001f28 <altera_avalon_fifo_read_status>
 f001fa0:	0007883a 	mov	r3,zero
    {
        return_val = altera_avalon_fifo_read_level(ctrl_address);
 f001fa4:	8009883a 	mov	r4,r16
int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
    int return_val = 0;
    *data = 0;
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 f001fa8:	1000041e 	bne	r2,zero,f001fbc <altera_avalon_read_fifo+0x4c>
    {
        return_val = altera_avalon_fifo_read_level(ctrl_address);
 f001fac:	f001ef80 	call	f001ef8 <altera_avalon_fifo_read_level>
 f001fb0:	1007883a 	mov	r3,r2
        *data = IORD_ALTERA_AVALON_FIFO_DATA(read_address);
 f001fb4:	90800037 	ldwio	r2,0(r18)
 f001fb8:	88800015 	stw	r2,0(r17)
    
    }
    return return_val;
}
 f001fbc:	1805883a 	mov	r2,r3
 f001fc0:	dfc00317 	ldw	ra,12(sp)
 f001fc4:	dc800217 	ldw	r18,8(sp)
 f001fc8:	dc400117 	ldw	r17,4(sp)
 f001fcc:	dc000017 	ldw	r16,0(sp)
 f001fd0:	dec00404 	addi	sp,sp,16
 f001fd4:	f800283a 	ret

0f001fd8 <altera_avalon_fifo_write_other_info>:
}

int altera_avalon_fifo_write_other_info(alt_u32 write_address,
					alt_u32 ctrl_address,
					alt_u32 data)
{
 f001fd8:	defffd04 	addi	sp,sp,-12
 f001fdc:	dc400115 	stw	r17,4(sp)
 f001fe0:	2023883a 	mov	r17,r4
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 f001fe4:	2809883a 	mov	r4,r5
 f001fe8:	01400044 	movi	r5,1
}

int altera_avalon_fifo_write_other_info(alt_u32 write_address,
					alt_u32 ctrl_address,
					alt_u32 data)
{
 f001fec:	dc000015 	stw	r16,0(sp)
 f001ff0:	dfc00215 	stw	ra,8(sp)
 f001ff4:	3021883a 	mov	r16,r6
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 f001ff8:	f001f280 	call	f001f28 <altera_avalon_fifo_read_status>
 f001ffc:	00ffff04 	movi	r3,-4
 f002000:	1000021e 	bne	r2,zero,f00200c <altera_avalon_fifo_write_other_info+0x34>
    {
	IOWR_ALTERA_AVALON_FIFO_OTHER_INFO(write_address, data);
 f002004:	8c000135 	stwio	r16,4(r17)
 f002008:	0007883a 	mov	r3,zero
    }
    else
    {
	return ALTERA_AVALON_FIFO_FULL;
    }
}
 f00200c:	1805883a 	mov	r2,r3
 f002010:	dfc00217 	ldw	ra,8(sp)
 f002014:	dc400117 	ldw	r17,4(sp)
 f002018:	dc000017 	ldw	r16,0(sp)
 f00201c:	dec00304 	addi	sp,sp,12
 f002020:	f800283a 	ret

0f002024 <altera_avalon_fifo_write_fifo>:
}

int altera_avalon_fifo_write_fifo(alt_u32 write_address,
                                  alt_u32 ctrl_address,
                                  alt_u32 data)
{
 f002024:	defffd04 	addi	sp,sp,-12
 f002028:	dc400115 	stw	r17,4(sp)
 f00202c:	2023883a 	mov	r17,r4
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 f002030:	2809883a 	mov	r4,r5
 f002034:	01400044 	movi	r5,1
}

int altera_avalon_fifo_write_fifo(alt_u32 write_address,
                                  alt_u32 ctrl_address,
                                  alt_u32 data)
{
 f002038:	dc000015 	stw	r16,0(sp)
 f00203c:	dfc00215 	stw	ra,8(sp)
 f002040:	3021883a 	mov	r16,r6
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 f002044:	f001f280 	call	f001f28 <altera_avalon_fifo_read_status>
 f002048:	00ffff04 	movi	r3,-4
 f00204c:	1000021e 	bne	r2,zero,f002058 <altera_avalon_fifo_write_fifo+0x34>
    {
        IOWR_ALTERA_AVALON_FIFO_DATA(write_address, data);
 f002050:	8c000035 	stwio	r16,0(r17)
 f002054:	0007883a 	mov	r3,zero
    }
    else
    {
        return ALTERA_AVALON_FIFO_FULL;
    }
}
 f002058:	1805883a 	mov	r2,r3
 f00205c:	dfc00217 	ldw	ra,8(sp)
 f002060:	dc400117 	ldw	r17,4(sp)
 f002064:	dc000017 	ldw	r16,0(sp)
 f002068:	dec00304 	addi	sp,sp,12
 f00206c:	f800283a 	ret

0f002070 <altera_avalon_fifo_write_almostempty>:
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
}

int altera_avalon_fifo_write_almostempty(alt_u32 address, alt_u32 data)
{
    IOWR_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address, data);
 f002070:	20800504 	addi	r2,r4,20
 f002074:	21400535 	stwio	r5,20(r4)
    if(IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address) == data)
 f002078:	10800037 	ldwio	r2,0(r2)
 f00207c:	0007883a 	mov	r3,zero
 f002080:	11400126 	beq	r2,r5,f002088 <altera_avalon_fifo_write_almostempty+0x18>
 f002084:	00ffff44 	movi	r3,-3
        return ALTERA_AVALON_FIFO_OK;
    else
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
}
 f002088:	1805883a 	mov	r2,r3
 f00208c:	f800283a 	ret

0f002090 <altera_avalon_fifo_write_almostfull>:
        return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
}

int altera_avalon_fifo_write_almostfull(alt_u32 address, alt_u32 data)
{
    IOWR_ALTERA_AVALON_FIFO_ALMOSTFULL(address, data);
 f002090:	20800404 	addi	r2,r4,16
 f002094:	21400435 	stwio	r5,16(r4)
    if(IORD_ALTERA_AVALON_FIFO_ALMOSTFULL(address) == data)
 f002098:	10800037 	ldwio	r2,0(r2)
 f00209c:	0007883a 	mov	r3,zero
 f0020a0:	11400126 	beq	r2,r5,f0020a8 <altera_avalon_fifo_write_almostfull+0x18>
 f0020a4:	00ffff44 	movi	r3,-3
        return ALTERA_AVALON_FIFO_OK;
    else
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
}
 f0020a8:	1805883a 	mov	r2,r3
 f0020ac:	f800283a 	ret

0f0020b0 <altera_avalon_fifo_write_ienable>:
    return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
}

int altera_avalon_fifo_write_ienable(alt_u32 address, alt_u32 mask)
{
    IOWR_ALTERA_AVALON_FIFO_IENABLE(address, mask);
 f0020b0:	20800304 	addi	r2,r4,12
 f0020b4:	21400335 	stwio	r5,12(r4)
    if(IORD_ALTERA_AVALON_FIFO_IENABLE(address) == mask)
 f0020b8:	10800037 	ldwio	r2,0(r2)
 f0020bc:	0007883a 	mov	r3,zero
 f0020c0:	11400126 	beq	r2,r5,f0020c8 <altera_avalon_fifo_write_ienable+0x18>
 f0020c4:	00ffff84 	movi	r3,-2
        return ALTERA_AVALON_FIFO_OK;
    else
        return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
}
 f0020c8:	1805883a 	mov	r2,r3
 f0020cc:	f800283a 	ret

0f0020d0 <altera_avalon_fifo_clear_event>:
    return IORD_ALTERA_AVALON_FIFO_LEVEL(address);
}

int altera_avalon_fifo_clear_event(alt_u32 address, alt_u32 mask)
{
    IOWR_ALTERA_AVALON_FIFO_EVENT(address, mask);
 f0020d0:	20800204 	addi	r2,r4,8
 f0020d4:	21400235 	stwio	r5,8(r4)
    if((IORD_ALTERA_AVALON_FIFO_EVENT(address) & mask) == 0)
 f0020d8:	10800037 	ldwio	r2,0(r2)
 f0020dc:	1144703a 	and	r2,r2,r5
 f0020e0:	1004c03a 	cmpne	r2,r2,zero
        return ALTERA_AVALON_FIFO_OK;
    else
    return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
}
 f0020e4:	0085c83a 	sub	r2,zero,r2
 f0020e8:	f800283a 	ret

0f0020ec <altera_avalon_fifo_init>:



int altera_avalon_fifo_init(alt_u32 address, alt_u32 ienable,
                            alt_u32 emptymark, alt_u32 fullmark)
{
 f0020ec:	defffb04 	addi	sp,sp,-20
 f0020f0:	dc000015 	stw	r16,0(sp)
 f0020f4:	2821883a 	mov	r16,r5
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
 f0020f8:	01400fc4 	movi	r5,63



int altera_avalon_fifo_init(alt_u32 address, alt_u32 ienable,
                            alt_u32 emptymark, alt_u32 fullmark)
{
 f0020fc:	dcc00315 	stw	r19,12(sp)
 f002100:	dc800215 	stw	r18,8(sp)
 f002104:	dc400115 	stw	r17,4(sp)
 f002108:	dfc00415 	stw	ra,16(sp)
 f00210c:	2023883a 	mov	r17,r4
 f002110:	3027883a 	mov	r19,r6
 f002114:	3825883a 	mov	r18,r7
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
 f002118:	f0020d00 	call	f0020d0 <altera_avalon_fifo_clear_event>
 f00211c:	00ffffc4 	movi	r3,-1
    {
        return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
    }

    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
 f002120:	800b883a 	mov	r5,r16
 f002124:	8809883a 	mov	r4,r17


int altera_avalon_fifo_init(alt_u32 address, alt_u32 ienable,
                            alt_u32 emptymark, alt_u32 fullmark)
{
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
 f002128:	10000d1e 	bne	r2,zero,f002160 <altera_avalon_fifo_init+0x74>
    {
        return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
    }

    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
 f00212c:	f0020b00 	call	f0020b0 <altera_avalon_fifo_write_ienable>
 f002130:	00ffff84 	movi	r3,-2
    {
         return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
    }

    if( altera_avalon_fifo_write_almostfull(address, fullmark) != ALTERA_AVALON_FIFO_OK)
 f002134:	900b883a 	mov	r5,r18
 f002138:	8809883a 	mov	r4,r17
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
    {
        return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
    }

    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
 f00213c:	1000081e 	bne	r2,zero,f002160 <altera_avalon_fifo_init+0x74>
    {
         return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
    }

    if( altera_avalon_fifo_write_almostfull(address, fullmark) != ALTERA_AVALON_FIFO_OK)
 f002140:	f0020900 	call	f002090 <altera_avalon_fifo_write_almostfull>
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
    }
  
    if( altera_avalon_fifo_write_almostempty(address, emptymark) != ALTERA_AVALON_FIFO_OK)
 f002144:	8809883a 	mov	r4,r17
 f002148:	980b883a 	mov	r5,r19
    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
    {
         return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
    }

    if( altera_avalon_fifo_write_almostfull(address, fullmark) != ALTERA_AVALON_FIFO_OK)
 f00214c:	1000031e 	bne	r2,zero,f00215c <altera_avalon_fifo_init+0x70>
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
    }
  
    if( altera_avalon_fifo_write_almostempty(address, emptymark) != ALTERA_AVALON_FIFO_OK)
 f002150:	f0020700 	call	f002070 <altera_avalon_fifo_write_almostempty>
 f002154:	0007883a 	mov	r3,zero
 f002158:	10000126 	beq	r2,zero,f002160 <altera_avalon_fifo_init+0x74>
 f00215c:	00ffff44 	movi	r3,-3
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
    }

    return ALTERA_AVALON_FIFO_OK;
}
 f002160:	1805883a 	mov	r2,r3
 f002164:	dfc00417 	ldw	ra,16(sp)
 f002168:	dcc00317 	ldw	r19,12(sp)
 f00216c:	dc800217 	ldw	r18,8(sp)
 f002170:	dc400117 	ldw	r17,4(sp)
 f002174:	dc000017 	ldw	r16,0(sp)
 f002178:	dec00504 	addi	sp,sp,20
 f00217c:	f800283a 	ret

0f002180 <alt_avalon_timer_sc_init>:
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 f002180:	00c00034 	movhi	r3,0
 f002184:	18c01004 	addi	r3,r3,64
 f002188:	18800017 	ldw	r2,0(r3)
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 f00218c:	200b883a 	mov	r5,r4
 f002190:	1000011e 	bne	r2,zero,f002198 <alt_avalon_timer_sc_init+0x18>
  {
    _alt_tick_rate = nticks;
 f002194:	19c00015 	stw	r7,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 f002198:	008001c4 	movi	r2,7
 f00219c:	28800135 	stwio	r2,4(r5)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
 f0021a0:	3009883a 	mov	r4,r6
 f0021a4:	0183c034 	movhi	r6,3840
 f0021a8:	31886c04 	addi	r6,r6,8624
 f0021ac:	f001c581 	jmpi	f001c58 <alt_irq_register>

0f0021b0 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 f0021b0:	defffe04 	addi	sp,sp,-8
 f0021b4:	dfc00115 	stw	ra,4(sp)
 f0021b8:	dc000015 	stw	r16,0(sp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 f0021bc:	20000035 	stwio	zero,0(r4)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 f0021c0:	20800137 	ldwio	r2,4(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 f0021c4:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 f0021c8:	00bfff84 	movi	r2,-2
 f0021cc:	8084703a 	and	r2,r16,r2
 f0021d0:	1001703a 	wrctl	status,r2
  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
  alt_tick ();
 f0021d4:	f001de40 	call	f001de4 <alt_tick>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 f0021d8:	8001703a 	wrctl	status,r16
  alt_irq_enable_all(cpu_sr);
}
 f0021dc:	dfc00117 	ldw	ra,4(sp)
 f0021e0:	dc000017 	ldw	r16,0(sp)
 f0021e4:	dec00204 	addi	sp,sp,8
 f0021e8:	f800283a 	ret

0f0021ec <m2vdd_hx8347a_write_reg>:
	}
}

void m2vdd_hx8347a_write_reg(alt_u32 base, alt_u8 index, alt_u16 value)
{
	while(IORD_M2VDD_HX8347A_CONTROL(base) & 2);
 f0021ec:	20800037 	ldwio	r2,0(r4)
 f0021f0:	1080008c 	andi	r2,r2,2
 f0021f4:	103ffd1e 	bne	r2,zero,f0021ec <m2vdd_hx8347a_write_reg>
	IOWR_M2VDD_HX8347A_CONTROL(base, index |
 f0021f8:	28803fcc 	andi	r2,r5,255
 f0021fc:	109000b4 	orhi	r2,r2,16386
 f002200:	20800035 	stwio	r2,0(r4)
		M2VDD_HX8347A_CONTROL_WRITE_MSK |
		M2VDD_HX8347A_CONTROL_RESET_MSK);
	IOWR_M2VDD_HX8347A_CONTROL(base, value |
 f002204:	30bfffcc 	andi	r2,r6,65535
 f002208:	109000f4 	orhi	r2,r2,16387
 f00220c:	20800035 	stwio	r2,0(r4)
		M2VDD_HX8347A_CONTROL_WRITE_MSK |
		M2VDD_HX8347A_CONTROL_RESET_MSK |
		M2VDD_HX8347A_CONTROL_RS_MSK);
}
 f002210:	f800283a 	ret

0f002214 <m2vdd_hx8347a_init>:
//--------------------------------------------------------------------------------
// Initialize LCD
//
void m2vdd_hx8347a_init(m2vdd_hx8347a_state* sp)
{
	void* base = sp->base;
 f002214:	21000017 	ldw	r4,0(r4)

	// Soft reset
	IOWR_M2VDD_HX8347A_CONTROL(base, M2VDD_HX8347A_CONTROL_SRESET_MSK);
 f002218:	00820034 	movhi	r2,2048
 f00221c:	20800035 	stwio	r2,0(r4)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 f002220:	00800034 	movhi	r2,0
 f002224:	10801104 	addi	r2,r2,68
 f002228:	10c00017 	ldw	r3,0(r2)
 f00222c:	100b883a 	mov	r5,r2
#include "m2vdd_hx8347a_regs.h"
#include "sys/alt_alarm.h"

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 f002230:	18c00084 	addi	r3,r3,2
 f002234:	28800017 	ldw	r2,0(r5)
	while(alt_nticks() < end);
 f002238:	10fffe36 	bltu	r2,r3,f002234 <m2vdd_hx8347a_init+0x20>
	void* base = sp->base;

	// Soft reset
	IOWR_M2VDD_HX8347A_CONTROL(base, M2VDD_HX8347A_CONTROL_SRESET_MSK);
	delay(1);
	IOWR_M2VDD_HX8347A_CONTROL(base, 0);
 f00223c:	20000035 	stwio	zero,0(r4)
 f002240:	28800017 	ldw	r2,0(r5)
 f002244:	01400034 	movhi	r5,0
 f002248:	29401104 	addi	r5,r5,68
#include "m2vdd_hx8347a_regs.h"
#include "sys/alt_alarm.h"

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 f00224c:	10c00084 	addi	r3,r2,2
 f002250:	28800017 	ldw	r2,0(r5)
	while(alt_nticks() < end);
 f002254:	10fffe36 	bltu	r2,r3,f002250 <m2vdd_hx8347a_init+0x3c>
	delay(1);
	IOWR_M2VDD_HX8347A_CONTROL(base, 0);
	delay(1);

	// Assert LCD's reset
	IOWR_M2VDD_HX8347A_CONTROL(base, M2VDD_HX8347A_CONTROL_WRITE_MSK);
 f002258:	00900034 	movhi	r2,16384
 f00225c:	20800035 	stwio	r2,0(r4)
 f002260:	0143c034 	movhi	r5,3840
 f002264:	2948bd04 	addi	r5,r5,8948
 f002268:	02003fc4 	movi	r8,255
 f00226c:	01c00034 	movhi	r7,0
 f002270:	39c01104 	addi	r7,r7,68
	};

	const unsigned char* p = codes;
	for(;; p += 2)
	{
		if(p[0] == 0xff)
 f002274:	28800003 	ldbu	r2,0(r5)
 f002278:	12000a1e 	bne	r2,r8,f0022a4 <m2vdd_hx8347a_init+0x90>
		{
			if(p[1] == 0) break;
 f00227c:	28c00043 	ldbu	r3,1(r5)
 f002280:	18000f26 	beq	r3,zero,f0022c0 <m2vdd_hx8347a_init+0xac>
 f002284:	38800017 	ldw	r2,0(r7)
 f002288:	01800034 	movhi	r6,0
 f00228c:	31801104 	addi	r6,r6,68
#include "m2vdd_hx8347a_regs.h"
#include "sys/alt_alarm.h"

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 f002290:	10800044 	addi	r2,r2,1
 f002294:	1887883a 	add	r3,r3,r2
 f002298:	30800017 	ldw	r2,0(r6)
	while(alt_nticks() < end);
 f00229c:	10c0062e 	bgeu	r2,r3,f0022b8 <m2vdd_hx8347a_init+0xa4>
 f0022a0:	003ffd06 	br	f002298 <m2vdd_hx8347a_init+0x84>
			if(p[1] == 0) break;
			delay(p[1]);
		}
		else
		{
			IOWR_M2VDD_HX8347A_CONTROL(base, p[0] |
 f0022a4:	109000b4 	orhi	r2,r2,16386
 f0022a8:	20800035 	stwio	r2,0(r4)
				M2VDD_HX8347A_CONTROL_WRITE_MSK |
				M2VDD_HX8347A_CONTROL_RESET_MSK);
			IOWR_M2VDD_HX8347A_CONTROL(base, p[1] |
 f0022ac:	28800043 	ldbu	r2,1(r5)
 f0022b0:	109000f4 	orhi	r2,r2,16387
 f0022b4:	20800035 	stwio	r2,0(r4)

	0xff,   0, // END
	};

	const unsigned char* p = codes;
	for(;; p += 2)
 f0022b8:	29400084 	addi	r5,r5,2
 f0022bc:	003fed06 	br	f002274 <m2vdd_hx8347a_init+0x60>
 f0022c0:	f800283a 	ret

0f0022c4 <m2vdec_init>:
//--------------------------------------------------------------------------------
// Initialize MPEG2 Video Decoder
//
void m2vdec_init(m2vdec_state* sp)
{
}
 f0022c4:	f800283a 	ret

0f0022c8 <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 f0022c8:	f800283a 	ret

0f0022cc <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 f0022cc:	f800283a 	ret

0f0022d0 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 f0022d0:	000170fa 	wrctl	ienable,zero
}
 f0022d4:	f800283a 	ret

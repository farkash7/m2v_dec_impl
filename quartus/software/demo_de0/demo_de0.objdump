
demo_de0.elf:     file format elf32-littlenios2
demo_de0.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x01000000

Program Header:
    LOAD off    0x00001000 vaddr 0x00400000 paddr 0x00400000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001020 vaddr 0x00400020 paddr 0x00400020 align 2**12
         filesz 0x000001b4 memsz 0x000001b4 flags r-x
    LOAD off    0x00002000 vaddr 0x01000000 paddr 0x01000000 align 2**12
         filesz 0x00001a20 memsz 0x00001b7c flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00400000  00400000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000001b4  00400020  00400020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00001954  01000000  01000000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000b0  01001954  01001954  00003954  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000001c  01001a04  01001a04  00003a04  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000015c  01001a20  01001a20  00003a20  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  00003a20  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00000280  00000000  00000000  00003a48  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000060c  00000000  00000000  00003cc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00002dac  00000000  00000000  000042d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 000012a7  00000000  00000000  00007080  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000030ca  00000000  00000000  00008327  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000560  00000000  00000000  0000b3f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00000c2e  00000000  00000000  0000b954  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000013c7  00000000  00000000  0000c582  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  0000d94c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000001e8  00000000  00000000  0000d960  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0000f05f  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  0000f062  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0000f06e  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0000f06f  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0000f070  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0000f074  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0000f078  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000004  00000000  00000000  0000f07c  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000004  00000000  00000000  0000f080  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000004  00000000  00000000  0000f084  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 0000000c  00000000  00000000  0000f088  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000029  00000000  00000000  0000f094  2**0
                  CONTENTS, READONLY
 29 .jdi          00003acf  00000000  00000000  0000f0bd  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00400000 l    d  .entry	00000000 .entry
00400020 l    d  .exceptions	00000000 .exceptions
01000000 l    d  .text	00000000 .text
01001954 l    d  .rodata	00000000 .rodata
01001a04 l    d  .rwdata	00000000 .rwdata
01001a20 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
01000034 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 demo_de0.c
004000ec l     F .exceptions	0000002c frame_rate_handler
00400118 l     F .exceptions	00000060 m2vdec_irq_handler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 diskio.c
01001a24 l     O .bss	00000004 Timer1
01001a28 l     O .bss	00000004 Timer2
01001a08 l     O .rwdata	00000001 Stat
01001a4c l     O .bss	00000018 a.1590
010002e4 l     F .text	0000002c xchg_spi
01000310 l     F .text	00000018 deselect
01000328 l     F .text	00000070 select
01000398 l     F .text	00000124 send_cmd
01001a2c l     O .bss	00000001 CardType
00000000 l    df *ABS*	00000000 pff.c
0100079c l     F .text	0000004c clust2sect
01001a30 l     O .bss	00000004 FatFs
010007e8 l     F .text	0000008c dir_rewind
01000874 l     F .text	00000100 check_fs
01000974 l     F .text	000000d8 get_fat
00000000 l    df *ABS*	00000000 lib2-divmod.c
010011d8 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_fifo_util.c
00000000 l    df *ABS*	00000000 m2vdd_hx8347a.c
01001960 l     O .rodata	000000a2 codes.1404
00000000 l    df *ABS*	00000000 m2vdec.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
0100148c g     F .text	0000002c alt_main
01001a7c g     O .bss	00000100 alt_irq
01001780 g     F .text	00000020 altera_avalon_fifo_write_almostfull
010004bc g     F .text	00000110 disk_readp
01001870 g     F .text	00000028 m2vdd_hx8347a_write_reg
01001898 g     F .text	000000b0 m2vdd_hx8347a_init
01001a1c g     O .rwdata	00000004 m2vdec_0
010017dc g     F .text	00000094 altera_avalon_fifo_init
01001714 g     F .text	0000004c altera_avalon_fifo_write_fifo
01001a04 g     O .rwdata	00000004 test_1mb_m2v
01001948 g     F .text	00000004 m2vdec_init
00400000 g     F .entry	00000000 __reset
010015d8 g     F .text	00000008 altera_avalon_fifo_read_backpressure
01001a3c g     O .bss	00000004 alt_argv
01009a04 g       *ABS*	00000000 _gp
010017c0 g     F .text	0000001c altera_avalon_fifo_clear_event
010005cc g     F .text	000001d0 disk_initialize
01001314 g     F .text	00000008 __udivsi3
010013ec g     F .text	000000a0 alt_irq_register
01001b7c g       *ABS*	00000000 __bss_end
010014ec g     F .text	000000ac alt_tick
01000000 g       *ABS*	00000000 __alt_mem_ram_0
010014b8 g     F .text	00000034 alt_alarm_stop
01001a34 g     O .bss	00000004 alt_irq_active
00400178 g     F .exceptions	0000005c alt_irq_handler
010017a0 g     F .text	00000020 altera_avalon_fifo_write_ienable
010015fc g     F .text	00000008 altera_avalon_fifo_read_almostempty
0100131c g     F .text	00000008 __umodsi3
010002c8 g     F .text	0000001c disk_inittimer
01001b7c g       *ABS*	00000000 end
010015f0 g     F .text	0000000c altera_avalon_fifo_read_event
01002000 g       *ABS*	00000000 __alt_stack_pointer
01001624 g     F .text	0000003c altera_avalon_fifo_read_fifo
01000280 g     F .text	00000048 disk_timerproc
01000000 g     F .text	00000038 _start
01001a44 g     O .bss	00000004 _alt_tick_rate
01001a20 g     O .bss	00000004 fr_flags
01001a48 g     O .bss	00000004 _alt_nticks
01001598 g     F .text	00000020 alt_sys_init
01001324 g     F .text	00000038 __mulsi3
01001b7c g       *ABS*	00000000 __alt_stack_base
01001618 g     F .text	0000000c altera_avalon_fifo_read_status
010015e0 g     F .text	00000008 altera_avalon_fifo_read_other_info
01001a20 g       *ABS*	00000000 __bss_start
01000038 g     F .text	00000248 main
01001a40 g     O .bss	00000004 alt_envp
010015e8 g     F .text	00000008 altera_avalon_fifo_read_level
01001254 g     F .text	00000060 __divsi3
01000a4c g     F .text	00000188 pf_read
01001a64 g     O .bss	00000018 al_frate
010015b8 g     F .text	00000020 alt_irq_init
01001a38 g     O .bss	00000004 alt_argc
01000bd4 g     F .text	00000358 pf_open
00400020 g       .exceptions	00000000 alt_irq_entry
01001a18 g     O .rwdata	00000004 m2vdd_hx8347a_0
010016c8 g     F .text	0000004c altera_avalon_fifo_write_other_info
01001a20 g       *ABS*	00000000 _edata
01001b7c g       *ABS*	00000000 _end
0100194c g     F .text	00000008 altera_nios2_qsys_irq_init
00400000 g       .entry	00000000 exit
010012b4 g     F .text	00000060 __modsi3
0100160c g     F .text	0000000c altera_avalon_fifo_read_ienable
01002000 g       *ABS*	00000000 __alt_data_end
00400020 g     F .exceptions	00000000 alt_exception
00400000 g       *ABS*	00000000 __alt_mem_rom_0
00400000 g       .entry	00000000 _exit
0100135c g     F .text	00000090 alt_alarm_start
01001604 g     F .text	00000008 altera_avalon_fifo_read_almostfull
01001660 g     F .text	00000068 altera_avalon_read_fifo
01001a0c g     O .rwdata	00000004 alt_priority_mask
01001760 g     F .text	00000020 altera_avalon_fifo_write_almostempty
01001a10 g     O .rwdata	00000008 alt_alarm_list
01000f2c g     F .text	000002ac pf_mount



Disassembly of section .exceptions:

00400020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
  400020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
  400024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
  400028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
  40002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
  400030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
  400034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
  400038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
  40003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
  400040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
  400044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
  400048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
  40004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
  400050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
  400054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
  400058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
  40005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
  400060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
  400064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
  400068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
  40006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
  400070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
  400074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
  400078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
  40007c:	10000326 	beq	r2,zero,40008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
  400080:	20000226 	beq	r4,zero,40008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
  400084:	04001780 	call	400178 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
  400088:	00000306 	br	400098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
  40008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
  400090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
  400094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
  400098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
  40009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
  4000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
  4000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
  4000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
  4000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
  4000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
  4000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
  4000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
  4000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
  4000c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
  4000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
  4000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
  4000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
  4000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
  4000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
  4000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
  4000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
  4000e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
  4000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
  4000e8:	ef80083a 	eret

004000ec <frame_rate_handler>:
	}
	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_IRQ_SEQ_MSK | M2VDEC_STATUS_IRQ_PIC_MSK);
}

static alt_u32 frame_rate_handler(void* context)
{
  4000ec:	20800017 	ldw	r2,0(r4)
  4000f0:	10800094 	ori	r2,r2,2
  4000f4:	20800015 	stw	r2,0(r4)
	*((volatile int*)context) |= 2;
	//return 33;
	return (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 8)) ? 1000 : 33;
  4000f8:	008c8004 	movi	r2,12800
  4000fc:	10800037 	ldwio	r2,0(r2)
  400100:	00c0fa04 	movi	r3,1000
  400104:	1080400c 	andi	r2,r2,256
  400108:	1000011e 	bne	r2,zero,400110 <frame_rate_handler+0x24>
  40010c:	00c00844 	movi	r3,33
}
  400110:	1805883a 	mov	r2,r3
  400114:	f800283a 	ret

00400118 <m2vdec_irq_handler>:

	return 0;
}

static void m2vdec_irq_handler(void* context, alt_u32 id)
{
  400118:	00940004 	movi	r2,20480
  40011c:	10800037 	ldwio	r2,0(r2)
  400120:	1080040c 	andi	r2,r2,16
  400124:	10000426 	beq	r2,zero,400138 <m2vdec_irq_handler+0x20>
	if(IORD_M2VDEC_STATUS(M2VDEC_0_BASE) & M2VDEC_STATUS_IRQ_PIC_MSK)
	{
		*((volatile int*)context) |= 1;
  400128:	20800017 	ldw	r2,0(r4)
  40012c:	10800054 	ori	r2,r2,1
  400130:	20800015 	stw	r2,0(r4)
  400134:	00000c06 	br	400168 <m2vdec_irq_handler+0x50>
	}
	else
	{
		alt_u32 vinfo = IORD_M2VDEC_VIDEO(M2VDEC_0_BASE);
  400138:	00940104 	movi	r2,20484
  40013c:	10c00037 	ldwio	r3,0(r2)
		alt_u32 wd = ((vinfo & M2VDEC_VIDEO_WIDTH_MSK) >> M2VDEC_VIDEO_WIDTH_OFST) - 1;
		alt_u32 ht = ((vinfo & M2VDEC_VIDEO_HEIGHT_MSK) >> M2VDEC_VIDEO_HEIGHT_OFST) - 1;
		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, M2VDD_HX8347A_CONTROL_VIDEOWD_MSK | wd);
  400140:	01180004 	movi	r4,24576
  400144:	188fffcc 	andi	r2,r3,16383
  400148:	10bfffc4 	addi	r2,r2,-1
  40014c:	10880034 	orhi	r2,r2,8192
  400150:	20800035 	stwio	r2,0(r4)
		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, M2VDD_HX8347A_CONTROL_VIDEOHT_MSK | ht);
  400154:	1806913a 	slli	r3,r3,4
  400158:	1806d4ba 	srli	r3,r3,18
  40015c:	18ffffc4 	addi	r3,r3,-1
  400160:	18c40034 	orhi	r3,r3,4096
  400164:	20c00035 	stwio	r3,0(r4)
	}
	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_IRQ_SEQ_MSK | M2VDEC_STATUS_IRQ_PIC_MSK);
  400168:	00c00604 	movi	r3,24
  40016c:	00940004 	movi	r2,20480
  400170:	10c00035 	stwio	r3,0(r2)
}
  400174:	f800283a 	ret

00400178 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
  400178:	deffff04 	addi	sp,sp,-4
  40017c:	dfc00015 	stw	ra,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
  400180:	0009313a 	rdctl	r4,ipending
  400184:	00c00044 	movi	r3,1
  400188:	000b883a 	mov	r5,zero
  40018c:	01804034 	movhi	r6,256
  400190:	31869f04 	addi	r6,r6,6780
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  400194:	20c4703a 	and	r2,r4,r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
  400198:	18c7883a 	add	r3,r3,r3
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
  40019c:	10000726 	beq	r2,zero,4001bc <alt_irq_handler+0x44>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
  4001a0:	31000117 	ldw	r4,4(r6)
  4001a4:	30800017 	ldw	r2,0(r6)
  4001a8:	103ee83a 	callr	r2
  4001ac:	0005313a 	rdctl	r2,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
  4001b0:	10000526 	beq	r2,zero,4001c8 <alt_irq_handler+0x50>
  4001b4:	1009883a 	mov	r4,r2
  4001b8:	003ff206 	br	400184 <alt_irq_handler+0xc>
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
      i++;
  4001bc:	29400044 	addi	r5,r5,1
  4001c0:	31800204 	addi	r6,r6,8
  4001c4:	003ff306 	br	400194 <alt_irq_handler+0x1c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
  4001c8:	dfc00017 	ldw	ra,0(sp)
  4001cc:	dec00104 	addi	sp,sp,4
  4001d0:	f800283a 	ret

Disassembly of section .text:

01000000 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 1000000:	06c04034 	movhi	sp,256
    ori sp, sp, %lo(__alt_stack_pointer)
 1000004:	dec80014 	ori	sp,sp,8192

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 1000008:	06804034 	movhi	gp,256
    ori gp, gp, %lo(_gp)
 100000c:	d6a68114 	ori	gp,gp,39428
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 1000010:	00804034 	movhi	r2,256
    ori r2, r2, %lo(__bss_start)
 1000014:	10868814 	ori	r2,r2,6688

    movhi r3, %hi(__bss_end)
 1000018:	00c04034 	movhi	r3,256
    ori r3, r3, %lo(__bss_end)
 100001c:	18c6df14 	ori	r3,r3,7036

    beq r2, r3, 1f
 1000020:	10c00326 	beq	r2,r3,1000030 <_start+0x30>

0:
    stw zero, (r2)
 1000024:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 1000028:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 100002c:	10fffd36 	bltu	r2,r3,1000024 <_start+0x24>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 1000030:	100148c0 	call	100148c <alt_main>

01000034 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 1000034:	003fff06 	br	1000034 <alt_after_alt_main>

01000038 <main>:
	int end = alt_nticks() + ms + 1;
	while(alt_nticks() < end);
}

int main()
{ 
 1000038:	deff7004 	addi	sp,sp,-576
 100003c:	dc008c15 	stw	r16,560(sp)
	FATFS fs;
	FRESULT res;
	alt_u32 buf[512/4];

	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E0);
 1000040:	00803804 	movi	r2,224
 1000044:	040c0004 	movi	r16,12288
	int end = alt_nticks() + ms + 1;
	while(alt_nticks() < end);
}

int main()
{ 
 1000048:	dfc08f15 	stw	ra,572(sp)
 100004c:	dc808e15 	stw	r18,568(sp)
 1000050:	dc408d15 	stw	r17,564(sp)
	FATFS fs;
	FRESULT res;
	alt_u32 buf[512/4];

	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E0);
 1000054:	80800035 	stwio	r2,0(r16)
	disk_inittimer();
 1000058:	10002c80 	call	10002c8 <disk_inittimer>

	if((res = pf_mount(&fs)) != FR_OK) while(1);
 100005c:	d9000104 	addi	r4,sp,4
 1000060:	1000f2c0 	call	1000f2c <pf_mount>
 1000064:	10000126 	beq	r2,zero,100006c <main+0x34>
 1000068:	003fff06 	br	1000068 <main+0x30>
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E1);
 100006c:	00803844 	movi	r2,225
 1000070:	80800035 	stwio	r2,0(r16)

	if((res = pf_open("test.m2v")) != FR_OK) while(1);
 1000074:	01004034 	movhi	r4,256
 1000078:	21065504 	addi	r4,r4,6484
 100007c:	1000bd40 	call	1000bd4 <pf_open>
 1000080:	10000126 	beq	r2,zero,1000088 <main+0x50>
 1000084:	003fff06 	br	1000084 <main+0x4c>
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E2);
 1000088:	00803884 	movi	r2,226
 100008c:	80800035 	stwio	r2,0(r16)

	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_SRST_MSK);
 1000090:	00c02004 	movi	r3,128
 1000094:	00940004 	movi	r2,20480
 1000098:	10c00035 	stwio	r3,0(r2)

	{
		// Clear display with black (0x0000)
		int pixels;
		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, 0x22 |
 100009c:	00d80004 	movi	r3,24576
 10000a0:	009000b4 	movhi	r2,16386
 10000a4:	10800884 	addi	r2,r2,34
 10000a8:	18800035 	stwio	r2,0(r3)
 10000ac:	0009883a 	mov	r4,zero
 10000b0:	019000f4 	movhi	r6,16387
 10000b4:	01400074 	movhi	r5,1
 10000b8:	294b0004 	addi	r5,r5,11264
			M2VDD_HX8347A_CONTROL_WRITE_MSK |
			M2VDD_HX8347A_CONTROL_RESET_MSK);
		for(pixels = 0; pixels < 320*240; pixels++)
		{
    		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE,
 10000bc:	19800035 	stwio	r6,0(r3)
    			M2VDD_HX8347A_CONTROL_WRITE_MSK |
    			M2VDD_HX8347A_CONTROL_RESET_MSK |
    			M2VDD_HX8347A_CONTROL_RS_MSK);
    		while(IORD_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE) & 2);
 10000c0:	18800037 	ldwio	r2,0(r3)
 10000c4:	1080008c 	andi	r2,r2,2
 10000c8:	103ffd1e 	bne	r2,zero,10000c0 <main+0x88>
		// Clear display with black (0x0000)
		int pixels;
		IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, 0x22 |
			M2VDD_HX8347A_CONTROL_WRITE_MSK |
			M2VDD_HX8347A_CONTROL_RESET_MSK);
		for(pixels = 0; pixels < 320*240; pixels++)
 10000cc:	21000044 	addi	r4,r4,1
 10000d0:	217ffa1e 	bne	r4,r5,10000bc <main+0x84>
    			M2VDD_HX8347A_CONTROL_RS_MSK);
    		while(IORD_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE) & 2);
		}
	}

	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, 0);
 10000d4:	00940004 	movi	r2,20480
 10000d8:	10000035 	stwio	zero,0(r2)
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E3);
 10000dc:	040c0004 	movi	r16,12288
 10000e0:	008038c4 	movi	r2,227
 10000e4:	80800035 	stwio	r2,0(r16)

	fr_flags = 0;
	alt_irq_register(M2VDEC_0_IRQ, (void*)&fr_flags, m2vdec_irq_handler);
 10000e8:	d1600704 	addi	r5,gp,-32740
 10000ec:	01801034 	movhi	r6,64
 10000f0:	31804604 	addi	r6,r6,280
 10000f4:	01000144 	movi	r4,5
	}

	IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, 0);
	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x00E3);

	fr_flags = 0;
 10000f8:	d0200715 	stw	zero,-32740(gp)
	alt_irq_register(M2VDEC_0_IRQ, (void*)&fr_flags, m2vdec_irq_handler);
 10000fc:	10013ec0 	call	10013ec <alt_irq_register>
	if(alt_alarm_start(&al_frate, frame_rate_handler((void*)&fr_flags), frame_rate_handler, (void*)&fr_flags) < 0)
 1000100:	d1200704 	addi	r4,gp,-32740
 1000104:	04000ec0 	call	4000ec <frame_rate_handler>
 1000108:	100b883a 	mov	r5,r2
 100010c:	01004034 	movhi	r4,256
 1000110:	21069904 	addi	r4,r4,6756
 1000114:	01801034 	movhi	r6,64
 1000118:	31803b04 	addi	r6,r6,236
 100011c:	d1e00704 	addi	r7,gp,-32740
 1000120:	100135c0 	call	100135c <alt_alarm_start>
 1000124:	1000010e 	bge	r2,zero,100012c <main+0xf4>
 1000128:	003fff06 	br	1000128 <main+0xf0>
	{
		while(1);
	}

	if(altera_avalon_fifo_init(FIFO_0_IN_CSR_BASE, 0, 4, FIFO_0_IN_FIFO_DEPTH - 4) != ALTERA_AVALON_FIFO_OK)
 100012c:	01104004 	movi	r4,16640
 1000130:	000b883a 	mov	r5,zero
 1000134:	01800104 	movi	r6,4
 1000138:	01c03f04 	movi	r7,252
 100013c:	10017dc0 	call	10017dc <altera_avalon_fifo_init>
 1000140:	10000126 	beq	r2,zero,1000148 <main+0x110>
 1000144:	003fff06 	br	1000144 <main+0x10c>
	{
		while(1);
	}

	IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0x0000);
 1000148:	80000035 	stwio	zero,0(r16)

	alt_u16 frames = 0;
	alt_u8 stop = 0;
	alt_u32* p = buf;
//	alt_u32* p = (alt_u32*)0x500000;
	WORD left = 0;
 100014c:	d800000d 	sth	zero,0(sp)
 1000150:	0025883a 	mov	r18,zero
 1000154:	0023883a 	mov	r17,zero
 1000158:	d9000c04 	addi	r4,sp,48
	while(1)
	{
		if(left == 0)
 100015c:	d880000b 	ldhu	r2,0(sp)
 1000160:	10003b1e 	bne	r2,zero,1000250 <main+0x218>
		{
			if((res = pf_read(buf, 512, &left)) != 0)
 1000164:	dc000c04 	addi	r16,sp,48
 1000168:	8009883a 	mov	r4,r16
 100016c:	01408004 	movi	r5,512
 1000170:	d80d883a 	mov	r6,sp
 1000174:	1000a4c0 	call	1000a4c <pf_read>
 1000178:	1000021e 	bne	r2,zero,1000184 <main+0x14c>
 100017c:	8009883a 	mov	r4,r16
 1000180:	00003306 	br	1000250 <main+0x218>
			{
				IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0xE100);
 1000184:	00f84014 	movui	r3,57600
 1000188:	008c0004 	movi	r2,12288
 100018c:	10c00035 	stwio	r3,0(r2)
 1000190:	003fff06 	br	1000190 <main+0x158>
			}
			p = buf;
		}//-*/
		while(IORD_ALTERA_AVALON_FIFO_STATUS(FIFO_0_IN_CSR_BASE) & ALTERA_AVALON_FIFO_STATUS_F_MSK)
		{
			if(fr_flags == 3)
 1000194:	d0e00717 	ldw	r3,-32740(gp)
 1000198:	008000c4 	movi	r2,3
 100019c:	18802c1e 	bne	r3,r2,1000250 <main+0x218>
			{
				// Refresh display
				IOWR_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE, M2VDD_HX8347A_CONTROL_START_MSK);
 10001a0:	00d80004 	movi	r3,24576
 10001a4:	00a00034 	movhi	r2,32768
 10001a8:	18800035 	stwio	r2,0(r3)
				while(IORD_M2VDD_HX8347A_CONTROL(M2VDD_HX8347A_0_BASE) & 1);
 10001ac:	18800037 	ldwio	r2,0(r3)
 10001b0:	1080004c 	andi	r2,r2,1
 10001b4:	103ffd1e 	bne	r2,zero,10001ac <main+0x174>

				if((alt_u16)stop == (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & 0x2ff))
 10001b8:	014c8004 	movi	r5,12800
 10001bc:	28800037 	ldwio	r2,0(r5)
 10001c0:	1080bfcc 	andi	r2,r2,767
 10001c4:	90c03fcc 	andi	r3,r18,255
 10001c8:	1880181e 	bne	r3,r2,100022c <main+0x1f4>
 10001cc:	2807883a 	mov	r3,r5
				{
					while( (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 10)));
 10001d0:	18800037 	ldwio	r2,0(r3)
 10001d4:	1081000c 	andi	r2,r2,1024
 10001d8:	103ffd1e 	bne	r2,zero,10001d0 <main+0x198>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 10001dc:	00804034 	movhi	r2,256
 10001e0:	10869204 	addi	r2,r2,6728
 10001e4:	10c00017 	ldw	r3,0(r2)
 10001e8:	100b883a 	mov	r5,r2
static void m2vdec_irq_handler(void* context, alt_u32 id) __attribute__((section(".exceptions")));
static alt_u32 frame_rate_handler(void* context) __attribute__((section(".exceptions")));

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 10001ec:	18c007c4 	addi	r3,r3,31
 10001f0:	28800017 	ldw	r2,0(r5)
	while(alt_nticks() < end);
 10001f4:	10fffe36 	bltu	r2,r3,10001f0 <main+0x1b8>
 10001f8:	00cc8004 	movi	r3,12800

				if((alt_u16)stop == (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & 0x2ff))
				{
					while( (IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 10)));
					delay(30);
					while(!(IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE) & (1 << 10)));
 10001fc:	18800037 	ldwio	r2,0(r3)
 1000200:	1081000c 	andi	r2,r2,1024
 1000204:	103ffd26 	beq	r2,zero,10001fc <main+0x1c4>
 1000208:	00804034 	movhi	r2,256
 100020c:	10869204 	addi	r2,r2,6728
 1000210:	10c00017 	ldw	r3,0(r2)
 1000214:	100b883a 	mov	r5,r2
static void m2vdec_irq_handler(void* context, alt_u32 id) __attribute__((section(".exceptions")));
static alt_u32 frame_rate_handler(void* context) __attribute__((section(".exceptions")));

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 1000218:	18c007c4 	addi	r3,r3,31
 100021c:	28800017 	ldw	r2,0(r5)
	while(alt_nticks() < end);
 1000220:	10fffe36 	bltu	r2,r3,100021c <main+0x1e4>
 1000224:	0025883a 	mov	r18,zero
 1000228:	00000106 	br	1000230 <main+0x1f8>
					delay(30);
					stop = 0;
				}
				else
				{
					++stop;
 100022c:	94800044 	addi	r18,r18,1
				}

				fr_flags = 0;
				IOWR_32DIRECT(HEXDISP_0_BASE, 0, ++frames);
 1000230:	8c400044 	addi	r17,r17,1
 1000234:	88ffffcc 	andi	r3,r17,65535
 1000238:	008c0004 	movi	r2,12288
				else
				{
					++stop;
				}

				fr_flags = 0;
 100023c:	d0200715 	stw	zero,-32740(gp)
				IOWR_32DIRECT(HEXDISP_0_BASE, 0, ++frames);
 1000240:	10c00035 	stwio	r3,0(r2)

				// Resume decoding
				IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_PAUSE_MSK);
 1000244:	00c00804 	movi	r3,32
 1000248:	00940004 	movi	r2,20480
 100024c:	10c00035 	stwio	r3,0(r2)
				IOWR_32DIRECT(HEXDISP_0_BASE, 0, 0xE100);
				while(1);
			}
			p = buf;
		}//-*/
		while(IORD_ALTERA_AVALON_FIFO_STATUS(FIFO_0_IN_CSR_BASE) & ALTERA_AVALON_FIFO_STATUS_F_MSK)
 1000250:	00904104 	movi	r2,16644
 1000254:	10800037 	ldwio	r2,0(r2)
 1000258:	1080004c 	andi	r2,r2,1
 100025c:	103fcd1e 	bne	r2,zero,1000194 <main+0x15c>

				// Resume decoding
				IOWR_M2VDEC_STATUS(M2VDEC_0_BASE, M2VDEC_STATUS_PAUSE_MSK);
			}
		}
		IOWR_ALTERA_AVALON_FIFO_DATA(FIFO_0_IN_BASE, *p++);
 1000260:	20c00017 	ldw	r3,0(r4)
 1000264:	00900004 	movi	r2,16384
 1000268:	21000104 	addi	r4,r4,4
 100026c:	10c00035 	stwio	r3,0(r2)
		left -= 4;
 1000270:	d880000b 	ldhu	r2,0(sp)
 1000274:	10bfff04 	addi	r2,r2,-4
 1000278:	d880000d 	sth	r2,0(sp)
 100027c:	003fb706 	br	100015c <main+0x124>

01000280 <disk_timerproc>:
alt_u32 disk_timerproc(void* context)
{
	WORD n;
	BYTE s;

	n = Timer1;						/* 1kHz decrement timer stopped at 0 */
 1000280:	d0e00817 	ldw	r3,-32736(gp)
		s &= ~STA_NODISK;
	else		/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
	Stat = s;
	return 1;
}
 1000284:	00800044 	movi	r2,1
{
	WORD n;
	BYTE s;

	n = Timer1;						/* 1kHz decrement timer stopped at 0 */
	if (n) Timer1 = --n;
 1000288:	193fffc4 	addi	r4,r3,-1
 100028c:	18ffffcc 	andi	r3,r3,65535
 1000290:	213fffcc 	andi	r4,r4,65535
 1000294:	18000126 	beq	r3,zero,100029c <disk_timerproc+0x1c>
 1000298:	d1200815 	stw	r4,-32736(gp)
	n = Timer2;
 100029c:	d0e00917 	ldw	r3,-32732(gp)
	if (n) Timer2 = --n;
 10002a0:	193fffc4 	addi	r4,r3,-1
 10002a4:	18ffffcc 	andi	r3,r3,65535
 10002a8:	213fffcc 	andi	r4,r4,65535
 10002ac:	18000126 	beq	r3,zero,10002b4 <disk_timerproc+0x34>
 10002b0:	d1200915 	stw	r4,-32732(gp)

	s = Stat;
 10002b4:	d0e00103 	ldbu	r3,-32764(gp)
	if (INS)	/* Card is in socket */
		s &= ~STA_NODISK;
 10002b8:	013fff44 	movi	r4,-3
 10002bc:	1906703a 	and	r3,r3,r4
	else		/* Socket empty */
		s |= (STA_NODISK | STA_NOINIT);
	Stat = s;
 10002c0:	d0e00105 	stb	r3,-32764(gp)
	return 1;
}
 10002c4:	f800283a 	ret

010002c8 <disk_inittimer>:

void disk_inittimer()
{
	static alt_alarm a;
	alt_alarm_start(&a, 1, disk_timerproc, NULL);
 10002c8:	01004034 	movhi	r4,256
 10002cc:	21069304 	addi	r4,r4,6732
 10002d0:	01400044 	movi	r5,1
 10002d4:	01804034 	movhi	r6,256
 10002d8:	3180a004 	addi	r6,r6,640
 10002dc:	000f883a 	mov	r7,zero
 10002e0:	100135c1 	jmpi	100135c <alt_alarm_start>

010002e4 <xchg_spi>:
static
BYTE xchg_spi (
	BYTE dat	/* Data to send */
)
{
	IOWR_ALTERA_AVALON_SPI_TXDATA(SPI_0_BASE, dat);
 10002e4:	21003fcc 	andi	r4,r4,255
 10002e8:	008c4104 	movi	r2,12548
 10002ec:	11000035 	stwio	r4,0(r2)
 10002f0:	00cc4204 	movi	r3,12552
	while (!(
 10002f4:	18800037 	ldwio	r2,0(r3)
 10002f8:	1080200c 	andi	r2,r2,128
 10002fc:	103ffd26 	beq	r2,zero,10002f4 <xchg_spi+0x10>
			IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) &
			ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) ;
	return IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE);
 1000300:	008c4004 	movi	r2,12544
 1000304:	10800037 	ldwio	r2,0(r2)
}
 1000308:	10803fcc 	andi	r2,r2,255
 100030c:	f800283a 	ret

01000310 <deselect>:

static
void deselect (void)
{
	// Negate SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 0);
 1000310:	008c4504 	movi	r2,12564
 1000314:	10000035 	stwio	zero,0(r2)
	IOWR_ALTERA_AVALON_SPI_CONTROL(SPI_0_BASE, 0);
 1000318:	008c4304 	movi	r2,12556
 100031c:	10000035 	stwio	zero,0(r2)
	xchg_spi(0xFF);
 1000320:	01003fc4 	movi	r4,255
 1000324:	10002e41 	jmpi	10002e4 <xchg_spi>

01000328 <select>:
/* Select card and wait for ready                                        */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
 1000328:	defffe04 	addi	sp,sp,-8
	// Assert SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 1);
 100032c:	00c00044 	movi	r3,1
 1000330:	008c4504 	movi	r2,12564
/* Select card and wait for ready                                        */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
 1000334:	dfc00115 	stw	ra,4(sp)
 1000338:	dc000015 	stw	r16,0(sp)
	// Assert SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 1);
 100033c:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_SPI_CONTROL(SPI_0_BASE, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 1000340:	00c10004 	movi	r3,1024
 1000344:	008c4304 	movi	r2,12556
 1000348:	10c00035 	stwio	r3,0(r2)
	xchg_spi(0xFF);
 100034c:	01003fc4 	movi	r4,255
 1000350:	10002e40 	call	10002e4 <xchg_spi>
)
{
	BYTE d;


	Timer2 = wt;
 1000354:	00807d04 	movi	r2,500
 1000358:	d0a00915 	stw	r2,-32732(gp)
	do {
		d = xchg_spi(0xff);
 100035c:	04003fc4 	movi	r16,255
 1000360:	8009883a 	mov	r4,r16
 1000364:	10002e40 	call	10002e4 <xchg_spi>
		/* This loop takes a time. Insert rot_rdq() here for multitask envilonment. */
	} while (d != 0xFF && Timer2);	/* Wait for card goes ready or timeout */
 1000368:	10803fcc 	andi	r2,r2,255
 100036c:	14000526 	beq	r2,r16,1000384 <select+0x5c>
 1000370:	d0a00917 	ldw	r2,-32732(gp)
 1000374:	103ff91e 	bne	r2,zero,100035c <select+0x34>
	// Assert SS# and send dummy clock
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 1);
	IOWR_ALTERA_AVALON_SPI_CONTROL(SPI_0_BASE, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
	xchg_spi(0xFF);
	if (wait_ready(500)) return 1;	/* OK */
	deselect();
 1000378:	10003100 	call	1000310 <deselect>
 100037c:	0005883a 	mov	r2,zero
 1000380:	00000106 	br	1000388 <select+0x60>
	return 0;	/* Timeout */
 1000384:	00800044 	movi	r2,1
}
 1000388:	dfc00117 	ldw	ra,4(sp)
 100038c:	dc000017 	ldw	r16,0(sp)
 1000390:	dec00204 	addi	sp,sp,8
 1000394:	f800283a 	ret

01000398 <send_cmd>:
)
{
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 1000398:	20803fcc 	andi	r2,r4,255
 100039c:	1080201c 	xori	r2,r2,128
static
BYTE send_cmd (		/* Return value: R1 resp (bit7==1:Failed to send) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
 10003a0:	defffc04 	addi	sp,sp,-16
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 10003a4:	10bfe004 	addi	r2,r2,-128
static
BYTE send_cmd (		/* Return value: R1 resp (bit7==1:Failed to send) */
	BYTE cmd,		/* Command index */
	DWORD arg		/* Argument */
)
{
 10003a8:	dc800215 	stw	r18,8(sp)
 10003ac:	dc400115 	stw	r17,4(sp)
 10003b0:	dc000015 	stw	r16,0(sp)
 10003b4:	dfc00315 	stw	ra,12(sp)
 10003b8:	2025883a 	mov	r18,r4
 10003bc:	2021883a 	mov	r16,r4
 10003c0:	2823883a 	mov	r17,r5
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
 10003c4:	10000a0e 	bge	r2,zero,10003f0 <send_cmd+0x58>
		cmd &= 0x7F;
		res = send_cmd(CMD55, 0);
 10003c8:	01000dc4 	movi	r4,55
 10003cc:	000b883a 	mov	r5,zero
 10003d0:	10003980 	call	1000398 <send_cmd>
		if (res > 1) return res;
 10003d4:	10c03fcc 	andi	r3,r2,255
 10003d8:	00800044 	movi	r2,1
 10003dc:	10c00236 	bltu	r2,r3,10003e8 <send_cmd+0x50>
{
	BYTE n, res;


	if (cmd & 0x80) {	/* Send a CMD55 prior to ACMD<n> */
		cmd &= 0x7F;
 10003e0:	94001fcc 	andi	r16,r18,127
 10003e4:	00000206 	br	10003f0 <send_cmd+0x58>
		res = send_cmd(CMD55, 0);
		if (res > 1) return res;
 10003e8:	1805883a 	mov	r2,r3
 10003ec:	00002d06 	br	10004a4 <send_cmd+0x10c>
	}

	/* Select card */
	deselect();
 10003f0:	10003100 	call	1000310 <deselect>
	if (!select()) return 0xFF;
 10003f4:	10003280 	call	1000328 <select>
 10003f8:	1000021e 	bne	r2,zero,1000404 <send_cmd+0x6c>
 10003fc:	00803fc4 	movi	r2,255
 1000400:	00002806 	br	10004a4 <send_cmd+0x10c>

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + command index */
 1000404:	81001014 	ori	r4,r16,64
 1000408:	21003fcc 	andi	r4,r4,255
 100040c:	10002e40 	call	10002e4 <xchg_spi>
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
 1000410:	8808d63a 	srli	r4,r17,24
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 1000414:	84003fcc 	andi	r16,r16,255
	deselect();
	if (!select()) return 0xFF;

	/* Send command packet */
	xchg_spi(0x40 | cmd);				/* Start + command index */
	xchg_spi((BYTE)(arg >> 24));		/* Argument[31..24] */
 1000418:	10002e40 	call	10002e4 <xchg_spi>
	xchg_spi((BYTE)(arg >> 16));		/* Argument[23..16] */
 100041c:	8808d43a 	srli	r4,r17,16
 1000420:	21003fcc 	andi	r4,r4,255
 1000424:	10002e40 	call	10002e4 <xchg_spi>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
 1000428:	8808d23a 	srli	r4,r17,8
 100042c:	21003fcc 	andi	r4,r4,255
 1000430:	10002e40 	call	10002e4 <xchg_spi>
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
 1000434:	89003fcc 	andi	r4,r17,255
 1000438:	10002e40 	call	10002e4 <xchg_spi>
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
 100043c:	80001526 	beq	r16,zero,1000494 <send_cmd+0xfc>
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 1000440:	00800204 	movi	r2,8
 1000444:	80801526 	beq	r16,r2,100049c <send_cmd+0x104>
	xchg_spi(n);
 1000448:	01000044 	movi	r4,1
 100044c:	10002e40 	call	10002e4 <xchg_spi>

	/* Receive command resp */
	if (cmd == CMD12) xchg_spi(0xFF);	/* Diacard following one byte when CMD12 */
 1000450:	00800304 	movi	r2,12
 1000454:	8080021e 	bne	r16,r2,1000460 <send_cmd+0xc8>
 1000458:	01003fc4 	movi	r4,255
 100045c:	10002e40 	call	10002e4 <xchg_spi>
 1000460:	04000284 	movi	r16,10
	n = 10;								/* Wait for response (10 bytes max) */
	do
		res = xchg_spi(0xFF);
 1000464:	01003fc4 	movi	r4,255
 1000468:	10002e40 	call	10002e4 <xchg_spi>
 100046c:	1007883a 	mov	r3,r2
	while ((res & 0x80) && --n);
 1000470:	18803fcc 	andi	r2,r3,255
 1000474:	1080201c 	xori	r2,r2,128
 1000478:	843fffc4 	addi	r16,r16,-1
 100047c:	10bfe004 	addi	r2,r2,-128
 1000480:	81003fcc 	andi	r4,r16,255
 1000484:	1000010e 	bge	r2,zero,100048c <send_cmd+0xf4>
 1000488:	203ff61e 	bne	r4,zero,1000464 <send_cmd+0xcc>

	return res;							/* Return received response */
 100048c:	18803fcc 	andi	r2,r3,255
 1000490:	00000406 	br	10004a4 <send_cmd+0x10c>
	xchg_spi((BYTE)(arg >> 8));			/* Argument[15..8] */
	xchg_spi((BYTE)arg);				/* Argument[7..0] */
	n = 0x01;							/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
	xchg_spi(n);
 1000494:	01002544 	movi	r4,149
 1000498:	003ff006 	br	100045c <send_cmd+0xc4>
 100049c:	010021c4 	movi	r4,135
 10004a0:	003fee06 	br	100045c <send_cmd+0xc4>
	do
		res = xchg_spi(0xFF);
	while ((res & 0x80) && --n);

	return res;							/* Return received response */
}
 10004a4:	dfc00317 	ldw	ra,12(sp)
 10004a8:	dc800217 	ldw	r18,8(sp)
 10004ac:	dc400117 	ldw	r17,4(sp)
 10004b0:	dc000017 	ldw	r16,0(sp)
 10004b4:	dec00404 	addi	sp,sp,16
 10004b8:	f800283a 	ret

010004bc <disk_readp>:
	DWORD SectorNumber,  /* Sector number */
	WORD Offset,         /* Byte offset in the sector to start to read */
	WORD Count           /* Number of bytes to read */
)
{
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 10004bc:	d0a00103 	ldbu	r2,-32764(gp)
	BYTE* Buffer,        /* Pointer to the read buffer */
	DWORD SectorNumber,  /* Sector number */
	WORD Offset,         /* Byte offset in the sector to start to read */
	WORD Count           /* Number of bytes to read */
)
{
 10004c0:	defffc04 	addi	sp,sp,-16
 10004c4:	dc800215 	stw	r18,8(sp)
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 10004c8:	1080004c 	andi	r2,r2,1
 10004cc:	1005003a 	cmpeq	r2,r2,zero
	BYTE* Buffer,        /* Pointer to the read buffer */
	DWORD SectorNumber,  /* Sector number */
	WORD Offset,         /* Byte offset in the sector to start to read */
	WORD Count           /* Number of bytes to read */
)
{
 10004d0:	dc400115 	stw	r17,4(sp)
 10004d4:	dfc00315 	stw	ra,12(sp)
 10004d8:	dc000015 	stw	r16,0(sp)
 10004dc:	2025883a 	mov	r18,r4
 10004e0:	3823883a 	mov	r17,r7
	if (Stat & STA_NOINIT) return RES_NOTRDY;	/* Check if drive is ready */
 10004e4:	1000021e 	bne	r2,zero,10004f0 <disk_readp+0x34>
 10004e8:	00800084 	movi	r2,2
 10004ec:	00003106 	br	10005b4 <disk_readp+0xf8>

	if (!(CardType & CT_BLOCK))
 10004f0:	d0a00a03 	ldbu	r2,-32728(gp)
 10004f4:	31bfffcc 	andi	r6,r6,65535
 10004f8:	1080020c 	andi	r2,r2,8
 10004fc:	1000031e 	bne	r2,zero,100050c <disk_readp+0x50>
	{
		SectorNumber *= 512;		/* LBA ot BA conversion (byte addressing cards) */
 1000500:	2804927a 	slli	r2,r5,9
		SectorNumber += Offset;
 1000504:	118b883a 	add	r5,r2,r6
 1000508:	00000306 	br	1000518 <disk_readp+0x5c>
	}
	else if(Offset != 0)
 100050c:	30000226 	beq	r6,zero,1000518 <disk_readp+0x5c>
 1000510:	008000c4 	movi	r2,3
 1000514:	00002706 	br	10005b4 <disk_readp+0xf8>
	{
		return RES_PARERR;	/* Cannot access with offset */
	}

	if ((send_cmd(CMD17, SectorNumber) == 0)	&& rcvr_datablock(Buffer, Count))
 1000518:	01000444 	movi	r4,17
 100051c:	10003980 	call	1000398 <send_cmd>
 1000520:	10803fcc 	andi	r2,r2,255
 1000524:	1000201e 	bne	r2,zero,10005a8 <disk_readp+0xec>
)
{
	BYTE token;


	Timer1 = 200;
 1000528:	00803204 	movi	r2,200
 100052c:	d0a00815 	stw	r2,-32736(gp)
	do {							/* Wait for DataStart token in timeout of 200ms */
		token = xchg_spi(0xff);
 1000530:	04003fc4 	movi	r16,255
 1000534:	8009883a 	mov	r4,r16
 1000538:	10002e40 	call	10002e4 <xchg_spi>
		/* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */
	} while ((token == 0xFF) && Timer1);
 100053c:	10c03fcc 	andi	r3,r2,255
 1000540:	1c00031e 	bne	r3,r16,1000550 <disk_readp+0x94>
 1000544:	d0a00817 	ldw	r2,-32736(gp)
 1000548:	10001726 	beq	r2,zero,10005a8 <disk_readp+0xec>
 100054c:	003ff806 	br	1000530 <disk_readp+0x74>
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */
 1000550:	00803f84 	movi	r2,254
 1000554:	1880141e 	bne	r3,r2,10005a8 <disk_readp+0xec>
	else if(Offset != 0)
	{
		return RES_PARERR;	/* Cannot access with offset */
	}

	if ((send_cmd(CMD17, SectorNumber) == 0)	&& rcvr_datablock(Buffer, Count))
 1000558:	89ffffcc 	andi	r7,r17,65535
 100055c:	8009883a 	mov	r4,r16
 1000560:	018c4104 	movi	r6,12548
 1000564:	014c4004 	movi	r5,12544
 1000568:	00000906 	br	1000590 <disk_readp+0xd4>
	UINT btr		/* Number of bytes to receive (16, 64 or 512) */
)
{
	while(btr > 0)
	{
		IOWR_ALTERA_AVALON_SPI_TXDATA(SPI_0_BASE, 0xff);
 100056c:	31000035 	stwio	r4,0(r6)
 1000570:	00cc4204 	movi	r3,12552
		while (!(
 1000574:	18800037 	ldwio	r2,0(r3)
 1000578:	1080200c 	andi	r2,r2,128
 100057c:	103ffd26 	beq	r2,zero,1000574 <disk_readp+0xb8>
				IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) &
				ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) ;
		*buff++ = IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE);
 1000580:	28800037 	ldwio	r2,0(r5)
 1000584:	90800005 	stb	r2,0(r18)
		--btr;
 1000588:	39ffffc4 	addi	r7,r7,-1
	{
		IOWR_ALTERA_AVALON_SPI_TXDATA(SPI_0_BASE, 0xff);
		while (!(
				IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) &
				ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) ;
		*buff++ = IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE);
 100058c:	94800044 	addi	r18,r18,1
void rcvr_spi_multi (
	BYTE *buff,		/* Pointer to data buffer */
	UINT btr		/* Number of bytes to receive (16, 64 or 512) */
)
{
	while(btr > 0)
 1000590:	383ff61e 	bne	r7,zero,100056c <disk_readp+0xb0>
		/* This loop will take a time. Insert rot_rdq() here for multitask envilonment. */
	} while ((token == 0xFF) && Timer1);
	if(token != 0xFE) return 0;		/* Function fails if invalid DataStart token or timeout */

	rcvr_spi_multi(buff, btr);		/* Store trailing data to the buffer */
	xchg_spi(0xFF); xchg_spi(0xFF);			/* Discard CRC */
 1000594:	01003fc4 	movi	r4,255
 1000598:	10002e40 	call	10002e4 <xchg_spi>
 100059c:	01003fc4 	movi	r4,255
 10005a0:	10002e40 	call	10002e4 <xchg_spi>
 10005a4:	0023883a 	mov	r17,zero

	if ((send_cmd(CMD17, SectorNumber) == 0)	&& rcvr_datablock(Buffer, Count))
	{
		Count = 0;
	}
	deselect();
 10005a8:	10003100 	call	1000310 <deselect>

	return Count ? RES_ERROR : RES_OK;	/* Return result */
 10005ac:	88bfffcc 	andi	r2,r17,65535
 10005b0:	1004c03a 	cmpne	r2,r2,zero
}
 10005b4:	dfc00317 	ldw	ra,12(sp)
 10005b8:	dc800217 	ldw	r18,8(sp)
 10005bc:	dc400117 	ldw	r17,4(sp)
 10005c0:	dc000017 	ldw	r16,0(sp)
 10005c4:	dec00404 	addi	sp,sp,16
 10005c8:	f800283a 	ret

010005cc <disk_initialize>:

DSTATUS disk_initialize()
{
	BYTE n, cmd, ty, ocr[4];

	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the socket? */
 10005cc:	d0a00103 	ldbu	r2,-32764(gp)
/*-----------------------------------------------------------------------*/
/* Initialize disk drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize()
{
 10005d0:	defffc04 	addi	sp,sp,-16
 10005d4:	dfc00315 	stw	ra,12(sp)
	BYTE n, cmd, ty, ocr[4];

	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the socket? */
 10005d8:	1080008c 	andi	r2,r2,2
/*-----------------------------------------------------------------------*/
/* Initialize disk drive                                                 */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize()
{
 10005dc:	dc400215 	stw	r17,8(sp)
 10005e0:	dc000115 	stw	r16,4(sp)
	BYTE n, cmd, ty, ocr[4];

	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the socket? */
 10005e4:	10005f1e 	bne	r2,zero,1000764 <disk_initialize+0x198>
/*-----------------------------------------------------------------------*/

static
void power_on (void)
{
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(SPI_0_BASE, 0);
 10005e8:	008c4504 	movi	r2,12564
 10005ec:	10000035 	stwio	zero,0(r2)
 10005f0:	04000284 	movi	r16,10

	if (Stat & STA_NODISK) return Stat;	/* Is card existing in the socket? */

	power_on();							/* Initialize SPI */
	FCLK_SLOW();
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */
 10005f4:	01003fc4 	movi	r4,255
 10005f8:	843fffc4 	addi	r16,r16,-1
 10005fc:	10002e40 	call	10002e4 <xchg_spi>
 1000600:	80803fcc 	andi	r2,r16,255
 1000604:	103ffb1e 	bne	r2,zero,10005f4 <disk_initialize+0x28>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Put the card SPI/Idle state */
 1000608:	0009883a 	mov	r4,zero
 100060c:	000b883a 	mov	r5,zero
 1000610:	10003980 	call	1000398 <send_cmd>
 1000614:	14003fcc 	andi	r16,r2,255
 1000618:	00800044 	movi	r2,1
 100061c:	80805c1e 	bne	r16,r2,1000790 <disk_initialize+0x1c4>
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
 1000620:	0080fa04 	movi	r2,1000
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 1000624:	01000204 	movi	r4,8
 1000628:	01406a84 	movi	r5,426
	FCLK_SLOW();
	for (n = 10; n; n--) xchg_spi(0xFF);	/* Send 80 dummy clocks */

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Put the card SPI/Idle state */
		Timer1 = 1000;						/* Initialization timeout = 1 sec */
 100062c:	d0a00815 	stw	r2,-32736(gp)
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
 1000630:	10003980 	call	1000398 <send_cmd>
 1000634:	10803fcc 	andi	r2,r2,255
 1000638:	1400271e 	bne	r2,r16,10006d8 <disk_initialize+0x10c>
 100063c:	d821883a 	mov	r16,sp
			for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);	/* Get 32 bit return value of R7 resp */
 1000640:	01003fc4 	movi	r4,255
 1000644:	10002e40 	call	10002e4 <xchg_spi>
 1000648:	80800005 	stb	r2,0(r16)
 100064c:	84000044 	addi	r16,r16,1
 1000650:	d8800104 	addi	r2,sp,4
 1000654:	80bffa1e 	bne	r16,r2,1000640 <disk_initialize+0x74>
			if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* Is the card supports vcc of 2.7-3.6V? */
 1000658:	d8c00083 	ldbu	r3,2(sp)
 100065c:	00800044 	movi	r2,1
 1000660:	18804b1e 	bne	r3,r2,1000790 <disk_initialize+0x1c4>
 1000664:	d8c000c3 	ldbu	r3,3(sp)
 1000668:	00802a84 	movi	r2,170
 100066c:	1880481e 	bne	r3,r2,1000790 <disk_initialize+0x1c4>
				while (Timer1 && send_cmd(ACMD41, 1UL << 30)) ;	/* Wait for end of initialization with ACMD41(HCS) */
 1000670:	d0a00817 	ldw	r2,-32736(gp)
 1000674:	01002a44 	movi	r4,169
 1000678:	01500034 	movhi	r5,16384
 100067c:	10000326 	beq	r2,zero,100068c <disk_initialize+0xc0>
 1000680:	10003980 	call	1000398 <send_cmd>
 1000684:	10803fcc 	andi	r2,r2,255
 1000688:	103ff91e 	bne	r2,zero,1000670 <disk_initialize+0xa4>
				if (Timer1 && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 100068c:	d0a00817 	ldw	r2,-32736(gp)
 1000690:	10003f26 	beq	r2,zero,1000790 <disk_initialize+0x1c4>
 1000694:	01000e84 	movi	r4,58
 1000698:	000b883a 	mov	r5,zero
 100069c:	10003980 	call	1000398 <send_cmd>
 10006a0:	10803fcc 	andi	r2,r2,255
 10006a4:	10003a1e 	bne	r2,zero,1000790 <disk_initialize+0x1c4>
 10006a8:	d821883a 	mov	r16,sp
					for (n = 0; n < 4; n++) ocr[n] = xchg_spi(0xFF);
 10006ac:	01003fc4 	movi	r4,255
 10006b0:	10002e40 	call	10002e4 <xchg_spi>
 10006b4:	80800005 	stb	r2,0(r16)
 10006b8:	84000044 	addi	r16,r16,1
 10006bc:	d8800104 	addi	r2,sp,4
 10006c0:	80bffa1e 	bne	r16,r2,10006ac <disk_initialize+0xe0>
					ty = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* Card id SDv2 */
 10006c4:	d8800003 	ldbu	r2,0(sp)
 10006c8:	1080100c 	andi	r2,r2,64
 10006cc:	10002c26 	beq	r2,zero,1000780 <disk_initialize+0x1b4>
 10006d0:	00800304 	movi	r2,12
 10006d4:	00002b06 	br	1000784 <disk_initialize+0x1b8>
				}
			}
		} else {	/* Not SDv2 card */
			if (send_cmd(ACMD41, 0) <= 1) 	{	/* SDv1 or MMC? */
 10006d8:	01002a44 	movi	r4,169
 10006dc:	000b883a 	mov	r5,zero
 10006e0:	10003980 	call	1000398 <send_cmd>
 10006e4:	10803fcc 	andi	r2,r2,255
 10006e8:	80800336 	bltu	r16,r2,10006f8 <disk_initialize+0x12c>
 10006ec:	047fea44 	movi	r17,-87
 10006f0:	04000084 	movi	r16,2
 10006f4:	00000106 	br	10006fc <disk_initialize+0x130>
 10006f8:	8023883a 	mov	r17,r16
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 (ACMD41(0)) */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 (CMD1(0)) */
			}
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for end of initialization */
 10006fc:	d0a00817 	ldw	r2,-32736(gp)
 1000700:	89003fcc 	andi	r4,r17,255
 1000704:	000b883a 	mov	r5,zero
 1000708:	10000326 	beq	r2,zero,1000718 <disk_initialize+0x14c>
 100070c:	10003980 	call	1000398 <send_cmd>
 1000710:	10803fcc 	andi	r2,r2,255
 1000714:	103ff91e 	bne	r2,zero,10006fc <disk_initialize+0x130>
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
 1000718:	d0a00817 	ldw	r2,-32736(gp)
 100071c:	10001c26 	beq	r2,zero,1000790 <disk_initialize+0x1c4>
 1000720:	01000404 	movi	r4,16
 1000724:	01408004 	movi	r5,512
 1000728:	10003980 	call	1000398 <send_cmd>
 100072c:	10803fcc 	andi	r2,r2,255
 1000730:	1000171e 	bne	r2,zero,1000790 <disk_initialize+0x1c4>
				ty = 0;
		}
	}
	CardType = ty;	/* Card type */
 1000734:	d4200a05 	stb	r16,-32728(gp)
	deselect();
 1000738:	10003100 	call	1000310 <deselect>

	if (ty) {			/* OK */
 100073c:	80803fcc 	andi	r2,r16,255
 1000740:	10000426 	beq	r2,zero,1000754 <disk_initialize+0x188>
		FCLK_FAST();			/* Set fast clock */
		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
 1000744:	d0a00103 	ldbu	r2,-32764(gp)
 1000748:	00ffff84 	movi	r3,-2
 100074c:	10c4703a 	and	r2,r2,r3
 1000750:	00000306 	br	1000760 <disk_initialize+0x194>


static
void power_off (void)
{
	select();				/* Wait for card ready */
 1000754:	10003280 	call	1000328 <select>
	deselect();
 1000758:	10003100 	call	1000310 <deselect>
	if (ty) {			/* OK */
		FCLK_FAST();			/* Set fast clock */
		Stat &= ~STA_NOINIT;	/* Clear STA_NOINIT flag */
	} else {			/* Failed */
		power_off();
		Stat = STA_NOINIT;
 100075c:	00800044 	movi	r2,1
 1000760:	d0a00105 	stb	r2,-32764(gp)
	}

	return Stat;
 1000764:	d0a00103 	ldbu	r2,-32764(gp)
 1000768:	10803fcc 	andi	r2,r2,255
}
 100076c:	dfc00317 	ldw	ra,12(sp)
 1000770:	dc400217 	ldw	r17,8(sp)
 1000774:	dc000117 	ldw	r16,4(sp)
 1000778:	dec00404 	addi	sp,sp,16
 100077c:	f800283a 	ret
	} else {			/* Failed */
		power_off();
		Stat = STA_NOINIT;
	}

	return Stat;
 1000780:	00800104 	movi	r2,4
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for end of initialization */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
				ty = 0;
		}
	}
	CardType = ty;	/* Card type */
 1000784:	d0a00a05 	stb	r2,-32728(gp)
	deselect();
 1000788:	10003100 	call	1000310 <deselect>
 100078c:	003fed06 	br	1000744 <disk_initialize+0x178>
			while (Timer1 && send_cmd(cmd, 0)) ;		/* Wait for end of initialization */
			if (!Timer1 || send_cmd(CMD16, 512) != 0)	/* Set block length: 512 */
				ty = 0;
		}
	}
	CardType = ty;	/* Card type */
 1000790:	d0200a05 	stb	zero,-32728(gp)
	deselect();
 1000794:	10003100 	call	1000310 <deselect>
 1000798:	003fee06 	br	1000754 <disk_initialize+0x188>

0100079c <clust2sect>:

static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
 100079c:	defffe04 	addi	sp,sp,-8
 10007a0:	dc000015 	stw	r16,0(sp)
	FATFS *fs = FatFs;
 10007a4:	d4200b17 	ldw	r16,-32724(gp)


	clst -= 2;
 10007a8:	20ffff84 	addi	r3,r4,-2

static
DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	CLUST clst		/* Cluster# to be converted */
)
{
 10007ac:	dfc00115 	stw	ra,4(sp)
	FATFS *fs = FatFs;


	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 10007b0:	80800217 	ldw	r2,8(r16)
	return (DWORD)clst * fs->csize + fs->database;
 10007b4:	1809883a 	mov	r4,r3
{
	FATFS *fs = FatFs;


	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
 10007b8:	000b883a 	mov	r5,zero
 10007bc:	10bfff84 	addi	r2,r2,-2
 10007c0:	1880042e 	bgeu	r3,r2,10007d4 <clust2sect+0x38>
	return (DWORD)clst * fs->csize + fs->database;
 10007c4:	81400083 	ldbu	r5,2(r16)
 10007c8:	10013240 	call	1001324 <__mulsi3>
 10007cc:	80c00517 	ldw	r3,20(r16)
 10007d0:	10cb883a 	add	r5,r2,r3
}
 10007d4:	2805883a 	mov	r2,r5
 10007d8:	dfc00117 	ldw	ra,4(sp)
 10007dc:	dc000017 	ldw	r16,0(sp)
 10007e0:	dec00204 	addi	sp,sp,8
 10007e4:	f800283a 	ret

010007e8 <dir_rewind>:

static
FRESULT dir_rewind (
	DIR *dj			/* Pointer to directory object */
)
{
 10007e8:	defffe04 	addi	sp,sp,-8
 10007ec:	dc000015 	stw	r16,0(sp)
 10007f0:	2021883a 	mov	r16,r4
	CLUST clst;
	FATFS *fs = FatFs;


	dj->index = 0;
	clst = dj->sclust;
 10007f4:	21000217 	ldw	r4,8(r4)
	if (clst == 1 || clst >= fs->n_fatent)	/* Check start cluster range */
 10007f8:	00800044 	movi	r2,1

static
FRESULT dir_rewind (
	DIR *dj			/* Pointer to directory object */
)
{
 10007fc:	dfc00115 	stw	ra,4(sp)
	CLUST clst;
	FATFS *fs = FatFs;


	dj->index = 0;
 1000800:	8000000d 	sth	zero,0(r16)
FRESULT dir_rewind (
	DIR *dj			/* Pointer to directory object */
)
{
	CLUST clst;
	FATFS *fs = FatFs;
 1000804:	d1600b17 	ldw	r5,-32724(gp)


	dj->index = 0;
	clst = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent)	/* Check start cluster range */
 1000808:	20800f26 	beq	r4,r2,1000848 <dir_rewind+0x60>
 100080c:	28800217 	ldw	r2,8(r5)
 1000810:	20800d2e 	bgeu	r4,r2,1000848 <dir_rewind+0x60>
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
 1000814:	2000101e 	bne	r4,zero,1000858 <dir_rewind+0x70>
 1000818:	28c00003 	ldbu	r3,0(r5)
 100081c:	008000c4 	movi	r2,3
 1000820:	18800b1e 	bne	r3,r2,1000850 <dir_rewind+0x68>
		clst = (CLUST)fs->dirbase;
 1000824:	29000417 	ldw	r4,16(r5)
	dj->clust = clst;						/* Current cluster */
 1000828:	81000315 	stw	r4,12(r16)
	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */
 100082c:	20000226 	beq	r4,zero,1000838 <dir_rewind+0x50>
 1000830:	100079c0 	call	100079c <clust2sect>
 1000834:	00000106 	br	100083c <dir_rewind+0x54>
 1000838:	28800417 	ldw	r2,16(r5)
 100083c:	0007883a 	mov	r3,zero
 1000840:	80800415 	stw	r2,16(r16)
 1000844:	00000606 	br	1000860 <dir_rewind+0x78>

	return FR_OK;	/* Seek succeeded */
 1000848:	00c00044 	movi	r3,1
 100084c:	00000406 	br	1000860 <dir_rewind+0x78>
	clst = dj->sclust;
	if (clst == 1 || clst >= fs->n_fatent)	/* Check start cluster range */
		return FR_DISK_ERR;
	if (_FS_FAT32 && !clst && fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = (CLUST)fs->dirbase;
	dj->clust = clst;						/* Current cluster */
 1000850:	80000315 	stw	zero,12(r16)
 1000854:	003ff806 	br	1000838 <dir_rewind+0x50>
 1000858:	81000315 	stw	r4,12(r16)
 100085c:	003ff406 	br	1000830 <dir_rewind+0x48>
	dj->sect = clst ? clust2sect(clst) : fs->dirbase;	/* Current sector */

	return FR_OK;	/* Seek succeeded */
}
 1000860:	1805883a 	mov	r2,r3
 1000864:	dfc00117 	ldw	ra,4(sp)
 1000868:	dc000017 	ldw	r16,0(sp)
 100086c:	dec00204 	addi	sp,sp,8
 1000870:	f800283a 	ret

01000874 <check_fs>:
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 1000874:	defffc04 	addi	sp,sp,-16
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot sector */
 1000878:	01807f84 	movi	r6,510
 100087c:	01c00084 	movi	r7,2
static
BYTE check_fs (	/* 0:The FAT boot record, 1:Valid boot record but not an FAT, 2:Not a boot record, 3:Error */
	BYTE *buf,	/* Working buffer */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
 1000880:	dc400115 	stw	r17,4(sp)
 1000884:	dc000015 	stw	r16,0(sp)
 1000888:	dfc00315 	stw	ra,12(sp)
 100088c:	dc800215 	stw	r18,8(sp)
 1000890:	2021883a 	mov	r16,r4
 1000894:	2823883a 	mov	r17,r5
	if (disk_readp(buf, sect, 510, 2))		/* Read the boot sector */
 1000898:	10004bc0 	call	10004bc <disk_readp>
 100089c:	10000226 	beq	r2,zero,10008a8 <check_fs+0x34>
 10008a0:	008000c4 	movi	r2,3
 10008a4:	00002d06 	br	100095c <check_fs+0xe8>
		return 3;
	if (LD_WORD(buf) != 0xAA55)				/* Check record signature */
 10008a8:	80800043 	ldbu	r2,1(r16)
 10008ac:	80c00003 	ldbu	r3,0(r16)
 10008b0:	84800044 	addi	r18,r16,1
 10008b4:	1004923a 	slli	r2,r2,8
 10008b8:	10c4b03a 	or	r2,r2,r3
 10008bc:	10bfffcc 	andi	r2,r2,65535
 10008c0:	10a0001c 	xori	r2,r2,32768
 10008c4:	10a00004 	addi	r2,r2,-32768
 10008c8:	00ea9544 	movi	r3,-21931
 10008cc:	10c00226 	beq	r2,r3,10008d8 <check_fs+0x64>
 10008d0:	00800084 	movi	r2,2
 10008d4:	00002106 	br	100095c <check_fs+0xe8>
		return 2;

	if (!disk_readp(buf, sect, BS_FilSysType, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT12/16 */
 10008d8:	8009883a 	mov	r4,r16
 10008dc:	880b883a 	mov	r5,r17
 10008e0:	01800d84 	movi	r6,54
 10008e4:	01c00084 	movi	r7,2
 10008e8:	10004bc0 	call	10004bc <disk_readp>
 10008ec:	10000b1e 	bne	r2,zero,100091c <check_fs+0xa8>
 10008f0:	80800043 	ldbu	r2,1(r16)
 10008f4:	80c00003 	ldbu	r3,0(r16)
 10008f8:	1004923a 	slli	r2,r2,8
 10008fc:	10c4b03a 	or	r2,r2,r3
 1000900:	10bfffcc 	andi	r2,r2,65535
 1000904:	10a0001c 	xori	r2,r2,32768
 1000908:	10a00004 	addi	r2,r2,-32768
 100090c:	00d05184 	movi	r3,16710
 1000910:	10c0021e 	bne	r2,r3,100091c <check_fs+0xa8>
 1000914:	0005883a 	mov	r2,zero
 1000918:	00001006 	br	100095c <check_fs+0xe8>
		return 0;
	if (_FS_FAT32 && !disk_readp(buf, sect, BS_FilSysType32, 2) && LD_WORD(buf) == 0x4146)	/* Check FAT32 */
 100091c:	880b883a 	mov	r5,r17
 1000920:	8009883a 	mov	r4,r16
 1000924:	01801484 	movi	r6,82
 1000928:	01c00084 	movi	r7,2
 100092c:	10004bc0 	call	10004bc <disk_readp>
 1000930:	10000226 	beq	r2,zero,100093c <check_fs+0xc8>
 1000934:	00800044 	movi	r2,1
 1000938:	00000806 	br	100095c <check_fs+0xe8>
 100093c:	90800003 	ldbu	r2,0(r18)
 1000940:	80c00003 	ldbu	r3,0(r16)
 1000944:	1004923a 	slli	r2,r2,8
 1000948:	10c4b03a 	or	r2,r2,r3
 100094c:	10bfffcc 	andi	r2,r2,65535
 1000950:	10a0001c 	xori	r2,r2,32768
 1000954:	10a00004 	addi	r2,r2,-32768
 1000958:	10905198 	cmpnei	r2,r2,16710
		return 0;
	return 1;
}
 100095c:	dfc00317 	ldw	ra,12(sp)
 1000960:	dc800217 	ldw	r18,8(sp)
 1000964:	dc400117 	ldw	r17,4(sp)
 1000968:	dc000017 	ldw	r16,0(sp)
 100096c:	dec00404 	addi	sp,sp,16
 1000970:	f800283a 	ret

01000974 <get_fat>:

static
CLUST get_fat (	/* 1:IO error, Else:Cluster status */
	CLUST clst	/* Cluster# to get the link information */
)
{
 1000974:	defffe04 	addi	sp,sp,-8
#endif
	BYTE buf[4];
	FATFS *fs = FatFs;


	if (clst < 2 || clst >= fs->n_fatent)	/* Range check */
 1000978:	00800044 	movi	r2,1

static
CLUST get_fat (	/* 1:IO error, Else:Cluster status */
	CLUST clst	/* Cluster# to get the link information */
)
{
 100097c:	dfc00115 	stw	ra,4(sp)
#if _FS_FAT12
	WORD wc, bc, ofs;
#endif
	BYTE buf[4];
	FATFS *fs = FatFs;
 1000980:	d0e00b17 	ldw	r3,-32724(gp)


	if (clst < 2 || clst >= fs->n_fatent)	/* Range check */
 1000984:	11002d2e 	bgeu	r2,r4,1000a3c <get_fat+0xc8>
 1000988:	18800217 	ldw	r2,8(r3)
 100098c:	20802b2e 	bgeu	r4,r2,1000a3c <get_fat+0xc8>
		return 1;

	switch (fs->fs_type) {
 1000990:	19c00003 	ldbu	r7,0(r3)
 1000994:	00800084 	movi	r2,2
 1000998:	38800326 	beq	r7,r2,10009a8 <get_fat+0x34>
 100099c:	008000c4 	movi	r2,3
 10009a0:	3880261e 	bne	r7,r2,1000a3c <get_fat+0xc8>
 10009a4:	00000d06 	br	10009dc <get_fat+0x68>
		}
		wc = LD_WORD(buf);
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
#endif
	case FS_FAT16 :
		if (disk_readp(buf, fs->fatbase + clst / 256, (WORD)(((WORD)clst % 256) * 2), 2)) break;
 10009a8:	200ad23a 	srli	r5,r4,8
 10009ac:	18800317 	ldw	r2,12(r3)
 10009b0:	21803fcc 	andi	r6,r4,255
 10009b4:	318d883a 	add	r6,r6,r6
 10009b8:	288b883a 	add	r5,r5,r2
 10009bc:	d809883a 	mov	r4,sp
 10009c0:	10004bc0 	call	10004bc <disk_readp>
 10009c4:	10001d1e 	bne	r2,zero,1000a3c <get_fat+0xc8>
		return LD_WORD(buf);
 10009c8:	d8800043 	ldbu	r2,1(sp)
 10009cc:	d8c00003 	ldbu	r3,0(sp)
 10009d0:	1004923a 	slli	r2,r2,8
 10009d4:	10c4b03a 	or	r2,r2,r3
 10009d8:	00001906 	br	1000a40 <get_fat+0xcc>
#if _FS_FAT32
	case FS_FAT32 :
		if (disk_readp(buf, fs->fatbase + clst / 128, (WORD)(((WORD)clst % 128) * 4), 4)) break;
 10009dc:	200ad1fa 	srli	r5,r4,7
 10009e0:	18800317 	ldw	r2,12(r3)
 10009e4:	21801fcc 	andi	r6,r4,127
 10009e8:	318d883a 	add	r6,r6,r6
 10009ec:	288b883a 	add	r5,r5,r2
 10009f0:	318d883a 	add	r6,r6,r6
 10009f4:	d809883a 	mov	r4,sp
 10009f8:	01c00104 	movi	r7,4
 10009fc:	10004bc0 	call	10004bc <disk_readp>
 1000a00:	10000e1e 	bne	r2,zero,1000a3c <get_fat+0xc8>
		return LD_DWORD(buf) & 0x0FFFFFFF;
 1000a04:	d88000c3 	ldbu	r2,3(sp)
 1000a08:	d8c00083 	ldbu	r3,2(sp)
 1000a0c:	d9000043 	ldbu	r4,1(sp)
 1000a10:	1004963a 	slli	r2,r2,24
 1000a14:	1806943a 	slli	r3,r3,16
 1000a18:	d9400003 	ldbu	r5,0(sp)
 1000a1c:	2008923a 	slli	r4,r4,8
 1000a20:	10c4b03a 	or	r2,r2,r3
 1000a24:	1144b03a 	or	r2,r2,r5
 1000a28:	2088b03a 	or	r4,r4,r2
 1000a2c:	00840034 	movhi	r2,4096
 1000a30:	10bfffc4 	addi	r2,r2,-1
 1000a34:	2084703a 	and	r2,r4,r2
 1000a38:	00000106 	br	1000a40 <get_fat+0xcc>
 1000a3c:	00800044 	movi	r2,1
#endif
	}

	return 1;	/* An error occured at the disk I/O layer */
}
 1000a40:	dfc00117 	ldw	ra,4(sp)
 1000a44:	dec00204 	addi	sp,sp,8
 1000a48:	f800283a 	ret

01000a4c <pf_read>:
FRESULT pf_read (
	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
	WORD btr,		/* Number of bytes to read */
	WORD* br		/* Pointer to number of bytes read */
)
{
 1000a4c:	defff804 	addi	sp,sp,-32
 1000a50:	dc000015 	stw	r16,0(sp)
	DRESULT dr;
	CLUST clst;
	DWORD sect, remain;
	WORD rcnt;
	BYTE cs, *rbuff = buff;
	FATFS *fs = FatFs;
 1000a54:	d4200b17 	ldw	r16,-32724(gp)
FRESULT pf_read (
	void* buff,		/* Pointer to the read buffer (NULL:Forward data to the stream)*/
	WORD btr,		/* Number of bytes to read */
	WORD* br		/* Pointer to number of bytes read */
)
{
 1000a58:	dd800615 	stw	r22,24(sp)
 1000a5c:	dd400515 	stw	r21,20(sp)
 1000a60:	dcc00315 	stw	r19,12(sp)
 1000a64:	dfc00715 	stw	ra,28(sp)
 1000a68:	dd000415 	stw	r20,16(sp)
 1000a6c:	dc800215 	stw	r18,8(sp)
 1000a70:	dc400115 	stw	r17,4(sp)
 1000a74:	302b883a 	mov	r21,r6
 1000a78:	202d883a 	mov	r22,r4
 1000a7c:	2827883a 	mov	r19,r5
	WORD rcnt;
	BYTE cs, *rbuff = buff;
	FATFS *fs = FatFs;


	*br = 0;
 1000a80:	3000000d 	sth	zero,0(r6)
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
 1000a84:	8000021e 	bne	r16,zero,1000a90 <pf_read+0x44>
 1000a88:	00800184 	movi	r2,6
 1000a8c:	00004706 	br	1000bac <pf_read+0x160>
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
 1000a90:	80800043 	ldbu	r2,1(r16)
 1000a94:	1080004c 	andi	r2,r2,1
 1000a98:	1000021e 	bne	r2,zero,1000aa4 <pf_read+0x58>
 1000a9c:	00800144 	movi	r2,5
 1000aa0:	00004206 	br	1000bac <pf_read+0x160>
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
 1000aa4:	80800717 	ldw	r2,28(r16)
 1000aa8:	80c00617 	ldw	r3,24(r16)
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */
 1000aac:	293fffcc 	andi	r4,r5,65535
	*br = 0;
	if (!fs) return FR_NOT_ENABLED;		/* Check file system */
	if (!(fs->flag & FA_OPENED))		/* Check if opened */
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
 1000ab0:	10c5c83a 	sub	r2,r2,r3
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */
 1000ab4:	1100012e 	bgeu	r2,r4,1000abc <pf_read+0x70>
 1000ab8:	1027883a 	mov	r19,r2
{
	DRESULT dr;
	CLUST clst;
	DWORD sect, remain;
	WORD rcnt;
	BYTE cs, *rbuff = buff;
 1000abc:	b029883a 	mov	r20,r22
 1000ac0:	00003506 	br	1000b98 <pf_read+0x14c>

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
		if ((fs->fptr % 512) == 0) {				/* On the sector boundary? */
 1000ac4:	81000617 	ldw	r4,24(r16)
 1000ac8:	20807fcc 	andi	r2,r4,511
 1000acc:	1000161e 	bne	r2,zero,1000b28 <pf_read+0xdc>
			cs = (BYTE)(fs->fptr / 512 & (fs->csize - 1));	/* Sector offset in the cluster */
 1000ad0:	80800083 	ldbu	r2,2(r16)
 1000ad4:	2006d27a 	srli	r3,r4,9
 1000ad8:	10bfffc4 	addi	r2,r2,-1
 1000adc:	18a2703a 	and	r17,r3,r2
			if (!cs) {								/* On the cluster boundary? */
 1000ae0:	88803fcc 	andi	r2,r17,255
 1000ae4:	1000091e 	bne	r2,zero,1000b0c <pf_read+0xc0>
				clst = (fs->fptr == 0) ?			/* On the top of the file? */
 1000ae8:	2000021e 	bne	r4,zero,1000af4 <pf_read+0xa8>
 1000aec:	80c00817 	ldw	r3,32(r16)
 1000af0:	00000306 	br	1000b00 <pf_read+0xb4>
 1000af4:	81000917 	ldw	r4,36(r16)
 1000af8:	10009740 	call	1000974 <get_fat>
 1000afc:	1007883a 	mov	r3,r2
					fs->org_clust : get_fat(fs->curr_clust);
				if (clst <= 1) goto fr_abort;
 1000b00:	00800044 	movi	r2,1
 1000b04:	10c0272e 	bgeu	r2,r3,1000ba4 <pf_read+0x158>
				fs->curr_clust = clst;				/* Update current cluster */
 1000b08:	80c00915 	stw	r3,36(r16)
			}
			sect = clust2sect(fs->curr_clust);		/* Get current sector */
 1000b0c:	81000917 	ldw	r4,36(r16)
 1000b10:	100079c0 	call	100079c <clust2sect>
 1000b14:	1007883a 	mov	r3,r2
			if (!sect) goto fr_abort;
 1000b18:	10002226 	beq	r2,zero,1000ba4 <pf_read+0x158>
			fs->dsect = sect + cs;
 1000b1c:	88803fcc 	andi	r2,r17,255
 1000b20:	1885883a 	add	r2,r3,r2
 1000b24:	80800a15 	stw	r2,40(r16)
		}
		rcnt = (WORD)(512 - (fs->fptr % 512));		/* Get partial sector data from sector buffer */
 1000b28:	81000617 	ldw	r4,24(r16)
 1000b2c:	00808004 	movi	r2,512
 1000b30:	997fffcc 	andi	r5,r19,65535
 1000b34:	20c07fcc 	andi	r3,r4,511
 1000b38:	10c7c83a 	sub	r3,r2,r3
 1000b3c:	18bfffcc 	andi	r2,r3,65535
 1000b40:	200d883a 	mov	r6,r4
 1000b44:	9825883a 	mov	r18,r19
 1000b48:	1140012e 	bgeu	r2,r5,1000b50 <pf_read+0x104>
 1000b4c:	1825883a 	mov	r18,r3
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
 1000b50:	b0000226 	beq	r22,zero,1000b5c <pf_read+0x110>
 1000b54:	a009883a 	mov	r4,r20
 1000b58:	00000106 	br	1000b60 <pf_read+0x114>
 1000b5c:	0009883a 	mov	r4,zero
 1000b60:	81400a17 	ldw	r5,40(r16)
 1000b64:	947fffcc 	andi	r17,r18,65535
 1000b68:	31807fcc 	andi	r6,r6,511
 1000b6c:	880f883a 	mov	r7,r17
 1000b70:	10004bc0 	call	10004bc <disk_readp>
		if (dr) goto fr_abort;
 1000b74:	10000b1e 	bne	r2,zero,1000ba4 <pf_read+0x158>
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
 1000b78:	80800617 	ldw	r2,24(r16)
		btr -= rcnt; *br += rcnt;
 1000b7c:	a8c0000b 	ldhu	r3,0(r21)
		}
		rcnt = (WORD)(512 - (fs->fptr % 512));		/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
		if (dr) goto fr_abort;
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
 1000b80:	a469883a 	add	r20,r20,r17
 1000b84:	1445883a 	add	r2,r2,r17
		btr -= rcnt; *br += rcnt;
 1000b88:	1c87883a 	add	r3,r3,r18
		}
		rcnt = (WORD)(512 - (fs->fptr % 512));		/* Get partial sector data from sector buffer */
		if (rcnt > btr) rcnt = btr;
		dr = disk_readp(!buff ? 0 : rbuff, fs->dsect, (WORD)(fs->fptr % 512), rcnt);
		if (dr) goto fr_abort;
		fs->fptr += rcnt; rbuff += rcnt;			/* Update pointers and counters */
 1000b8c:	80800615 	stw	r2,24(r16)
		btr -= rcnt; *br += rcnt;
 1000b90:	a8c0000d 	sth	r3,0(r21)
 1000b94:	9ca7c83a 	sub	r19,r19,r18
		return FR_NOT_OPENED;

	remain = fs->fsize - fs->fptr;
	if (btr > remain) btr = (WORD)remain;			/* Truncate btr by remaining bytes */

	while (btr)	{									/* Repeat until all data transferred */
 1000b98:	98bfffcc 	andi	r2,r19,65535
 1000b9c:	103fc91e 	bne	r2,zero,1000ac4 <pf_read+0x78>
 1000ba0:	00000206 	br	1000bac <pf_read+0x160>
	}

	return FR_OK;

fr_abort:
	fs->flag = 0;
 1000ba4:	80000045 	stb	zero,1(r16)
 1000ba8:	00800044 	movi	r2,1
	return FR_DISK_ERR;
}
 1000bac:	dfc00717 	ldw	ra,28(sp)
 1000bb0:	dd800617 	ldw	r22,24(sp)
 1000bb4:	dd400517 	ldw	r21,20(sp)
 1000bb8:	dd000417 	ldw	r20,16(sp)
 1000bbc:	dcc00317 	ldw	r19,12(sp)
 1000bc0:	dc800217 	ldw	r18,8(sp)
 1000bc4:	dc400117 	ldw	r17,4(sp)
 1000bc8:	dc000017 	ldw	r16,0(sp)
 1000bcc:	dec00804 	addi	sp,sp,32
 1000bd0:	f800283a 	ret

01000bd4 <pf_open>:
/*-----------------------------------------------------------------------*/

FRESULT pf_open (
	const char *path	/* Pointer to the file name */
)
{
 1000bd4:	deffe904 	addi	sp,sp,-92
 1000bd8:	dd001415 	stw	r20,80(sp)
	FRESULT res;
	DIR dj;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;
 1000bdc:	d5200b17 	ldw	r20,-32724(gp)
/*-----------------------------------------------------------------------*/

FRESULT pf_open (
	const char *path	/* Pointer to the file name */
)
{
 1000be0:	dfc01615 	stw	ra,88(sp)
 1000be4:	dd401515 	stw	r21,84(sp)
 1000be8:	dcc01315 	stw	r19,76(sp)
 1000bec:	dc801215 	stw	r18,72(sp)
 1000bf0:	dc401115 	stw	r17,68(sp)
 1000bf4:	dc001015 	stw	r16,64(sp)
	DIR dj;
	BYTE sp[12], dir[32];
	FATFS *fs = FatFs;


	if (!fs)						/* Check file system */
 1000bf8:	a000021e 	bne	r20,zero,1000c04 <pf_open+0x30>
 1000bfc:	00c00184 	movi	r3,6
 1000c00:	0000c006 	br	1000f04 <pf_open+0x330>
		return FR_NOT_ENABLED;

	fs->flag = 0;
 1000c04:	a0000045 	stb	zero,1(r20)
	dj.fn = sp;
 1000c08:	2023883a 	mov	r17,r4
 1000c0c:	01000804 	movi	r4,32
 1000c10:	dec00415 	stw	sp,16(sp)
 1000c14:	00000106 	br	1000c1c <pf_open+0x48>
)
{
	FRESULT res;


	while (*path == ' ') path++;		/* Skip leading spaces */
 1000c18:	8c400044 	addi	r17,r17,1
 1000c1c:	88c00007 	ldb	r3,0(r17)
 1000c20:	193ffd26 	beq	r3,r4,1000c18 <pf_open+0x44>
	if (*path == '/') path++;			/* Strip heading separator */
 1000c24:	00800bc4 	movi	r2,47
 1000c28:	1880011e 	bne	r3,r2,1000c30 <pf_open+0x5c>
 1000c2c:	8c400044 	addi	r17,r17,1
	dj->sclust = 0;						/* Set start directory (always root dir) */

	if ((BYTE)*path <= ' ') {			/* Null path means the root directory */
 1000c30:	88800003 	ldbu	r2,0(r17)
	FRESULT res;


	while (*path == ' ') path++;		/* Skip leading spaces */
	if (*path == '/') path++;			/* Strip heading separator */
	dj->sclust = 0;						/* Set start directory (always root dir) */
 1000c34:	d8000515 	stw	zero,20(sp)

	if ((BYTE)*path <= ' ') {			/* Null path means the root directory */
 1000c38:	20800536 	bltu	r4,r2,1000c50 <pf_open+0x7c>
		res = dir_rewind(dj);
 1000c3c:	d9000304 	addi	r4,sp,12
 1000c40:	10007e80 	call	10007e8 <dir_rewind>
 1000c44:	1007883a 	mov	r3,r2
		return FR_NOT_ENABLED;

	fs->flag = 0;
	dj.fn = sp;
	res = follow_path(&dj, dir, path);	/* Follow the file path */
	if (res != FR_OK) return res;		/* Follow failed */
 1000c48:	10008a26 	beq	r2,zero,1000e74 <pf_open+0x2a0>
 1000c4c:	0000ad06 	br	1000f04 <pf_open+0x330>
{
	BYTE c, d, ni, si, i, *sfn;
	const char *p;

	/* Create file name in directory form */
	sfn = dj->fn;
 1000c50:	d9c00417 	ldw	r7,16(sp)
 1000c54:	01000804 	movi	r4,32


/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
 1000c58:	3805883a 	mov	r2,r7
 1000c5c:	38c002c4 	addi	r3,r7,11
	while (cnt--) *d++ = (char)val;
 1000c60:	11000005 	stb	r4,0(r2)
 1000c64:	10800044 	addi	r2,r2,1
 1000c68:	10fffd1e 	bne	r2,r3,1000c60 <pf_open+0x8c>
 1000c6c:	02800204 	movi	r10,8
 1000c70:	002b883a 	mov	r21,zero
 1000c74:	0013883a 	mov	r9,zero
 1000c78:	04000804 	movi	r16,32
 1000c7c:	03c00bc4 	movi	r15,47
 1000c80:	03800204 	movi	r14,8
 1000c84:	03400644 	movi	r13,25
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
 1000c88:	a8803fcc 	andi	r2,r21,255
 1000c8c:	8885883a 	add	r2,r17,r2
 1000c90:	10c00003 	ldbu	r3,0(r2)
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') break;
 1000c94:	52c03fcc 	andi	r11,r10,255
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
 1000c98:	03000b84 	movi	r12,46
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
 1000c9c:	19003fcc 	andi	r4,r3,255
 1000ca0:	2100201c 	xori	r4,r4,128
 1000ca4:	18803fcc 	andi	r2,r3,255
 1000ca8:	213fe004 	addi	r4,r4,-128
		if (c == '.' || i >= ni) {
 1000cac:	49403fcc 	andi	r5,r9,255
	sfn = dj->fn;
	mem_set(sfn, ' ', 11);
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
 1000cb0:	ad400044 	addi	r21,r21,1
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
 1000cb4:	8080102e 	bgeu	r16,r2,1000cf8 <pf_open+0x124>
 1000cb8:	23c00f26 	beq	r4,r15,1000cf8 <pf_open+0x124>
		if (c == '.' || i >= ni) {
 1000cbc:	23000526 	beq	r4,r12,1000cd4 <pf_open+0x100>
		if (IsDBCS1(c) && i < ni - 1) {	/* DBC 1st byte? */
			d = p[si++];				/* Get 2nd byte */
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
 1000cc0:	18bfe7c4 	addi	r2,r3,-97
			sfn[i++] = c;
 1000cc4:	394d883a 	add	r6,r7,r5
 1000cc8:	4a400044 	addi	r9,r9,1
		if (IsDBCS1(c) && i < ni - 1) {	/* DBC 1st byte? */
			d = p[si++];				/* Get 2nd byte */
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
 1000ccc:	10803fcc 	andi	r2,r2,255
	si = i = 0; ni = 8;
	p = *path;
	for (;;) {
		c = p[si++];
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
 1000cd0:	2ac00536 	bltu	r5,r11,1000ce8 <pf_open+0x114>

/* Fill memory */
static
void mem_set (void* dst, int val, int cnt) {
	char *d = (char*)dst;
	while (cnt--) *d++ = (char)val;
 1000cd4:	028002c4 	movi	r10,11
 1000cd8:	02400204 	movi	r9,8
	p = *path;
	for (;;) {
		c = p[si++];
		if (c <= ' ' || c == '/') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') break;
 1000cdc:	5b80061e 	bne	r11,r14,1000cf8 <pf_open+0x124>
 1000ce0:	233fe926 	beq	r4,r12,1000c88 <pf_open+0xb4>
 1000ce4:	00000406 	br	1000cf8 <pf_open+0x124>
		if (IsDBCS1(c) && i < ni - 1) {	/* DBC 1st byte? */
			d = p[si++];				/* Get 2nd byte */
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
 1000ce8:	68800136 	bltu	r13,r2,1000cf0 <pf_open+0x11c>
 1000cec:	18fff804 	addi	r3,r3,-32
			sfn[i++] = c;
 1000cf0:	30c00005 	stb	r3,0(r6)
 1000cf4:	003fe406 	br	1000c88 <pf_open+0xb4>
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */

	sfn[11] = (c <= ' ') ? 1 : 0;		/* Set last segment flag if end of path */
 1000cf8:	18c03fcc 	andi	r3,r3,255
 1000cfc:	00800804 	movi	r2,32
 1000d00:	10c5403a 	cmpgeu	r2,r2,r3
 1000d04:	388002c5 	stb	r2,11(r7)
{
	FRESULT res;
	BYTE c;


	res = dir_rewind(dj);			/* Rewind directory object */
 1000d08:	d9000304 	addi	r4,sp,12
 1000d0c:	10007e80 	call	10007e8 <dir_rewind>
 1000d10:	1007883a 	mov	r3,r2
	if (res != FR_OK) return res;
 1000d14:	10003f1e 	bne	r2,zero,1000e14 <pf_open+0x240>

	do {
		res = disk_readp(dir, dj->sect, (WORD)((dj->index % 16) * 32), 32)	/* Read an entry */
 1000d18:	d980030b 	ldhu	r6,12(sp)
 1000d1c:	d9400717 	ldw	r5,28(sp)
 1000d20:	dc000804 	addi	r16,sp,32
 1000d24:	318003cc 	andi	r6,r6,15
 1000d28:	300c917a 	slli	r6,r6,5
 1000d2c:	8009883a 	mov	r4,r16
 1000d30:	01c00804 	movi	r7,32
 1000d34:	10004bc0 	call	10004bc <disk_readp>
			? FR_DISK_ERR : FR_OK;
		if (res != FR_OK) break;
 1000d38:	1006c03a 	cmpne	r3,r2,zero
 1000d3c:	1000351e 	bne	r2,zero,1000e14 <pf_open+0x240>
		c = dir[DIR_Name];	/* First character */
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 1000d40:	d8800803 	ldbu	r2,32(sp)
 1000d44:	10003526 	beq	r2,zero,1000e1c <pf_open+0x248>
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
 1000d48:	d9c00ac3 	ldbu	r7,43(sp)
 1000d4c:	3880020c 	andi	r2,r7,8
 1000d50:	10000f1e 	bne	r2,zero,1000d90 <pf_open+0x1bc>
 1000d54:	d9800417 	ldw	r6,16(sp)
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
	const char *d = (const char *)dst, *s = (const char *)src;
 1000d58:	000b883a 	mov	r5,zero
 1000d5c:	020002c4 	movi	r8,11
 1000d60:	00000106 	br	1000d68 <pf_open+0x194>
	int r = 0;
	while (cnt-- && (r = *d++ - *s++) == 0) ;
 1000d64:	2a000726 	beq	r5,r8,1000d84 <pf_open+0x1b0>
 1000d68:	8145883a 	add	r2,r16,r5
 1000d6c:	3147883a 	add	r3,r6,r5
 1000d70:	11000007 	ldb	r4,0(r2)
 1000d74:	18800007 	ldb	r2,0(r3)
}

/* Compare memory to memory */
static
int mem_cmp (const void* dst, const void* src, int cnt) {
	const char *d = (const char *)dst, *s = (const char *)src;
 1000d78:	29400044 	addi	r5,r5,1
	int r = 0;
	while (cnt-- && (r = *d++ - *s++) == 0) ;
 1000d7c:	20bff926 	beq	r4,r2,1000d64 <pf_open+0x190>
 1000d80:	00000306 	br	1000d90 <pf_open+0x1bc>
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
					res = FR_NO_PATH;
				break;
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
 1000d84:	308002c3 	ldbu	r2,11(r6)
 1000d88:	10002a26 	beq	r2,zero,1000e34 <pf_open+0x260>
 1000d8c:	00003a06 	br	1000e78 <pf_open+0x2a4>
	CLUST clst;
	WORD i;
	FATFS *fs = FatFs;


	i = dj->index + 1;
 1000d90:	d880030b 	ldhu	r2,12(sp)
	DIR *dj			/* Pointer to directory object */
)
{
	CLUST clst;
	WORD i;
	FATFS *fs = FatFs;
 1000d94:	d4200b17 	ldw	r16,-32724(gp)


	i = dj->index + 1;
 1000d98:	14c00044 	addi	r19,r2,1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
 1000d9c:	98ffffcc 	andi	r3,r19,65535
 1000da0:	18001b26 	beq	r3,zero,1000e10 <pf_open+0x23c>
 1000da4:	d9400717 	ldw	r5,28(sp)
 1000da8:	28001926 	beq	r5,zero,1000e10 <pf_open+0x23c>
		return FR_NO_FILE;

	if (!(i % 16)) {		/* Sector changed? */
 1000dac:	188003cc 	andi	r2,r3,15
 1000db0:	1000151e 	bne	r2,zero,1000e08 <pf_open+0x234>
		dj->sect++;			/* Next sector */

		if (dj->clust == 0) {	/* Static table */
 1000db4:	d9000617 	ldw	r4,24(sp)
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % 16)) {		/* Sector changed? */
		dj->sect++;			/* Next sector */
 1000db8:	28800044 	addi	r2,r5,1
 1000dbc:	d8800715 	stw	r2,28(sp)
 1000dc0:	04800044 	movi	r18,1

		if (dj->clust == 0) {	/* Static table */
 1000dc4:	2000031e 	bne	r4,zero,1000dd4 <pf_open+0x200>
			if (i >= fs->n_rootdir)	/* Report EOT when end of table */
 1000dc8:	8080010b 	ldhu	r2,4(r16)
 1000dcc:	18800e36 	bltu	r3,r2,1000e08 <pf_open+0x234>
 1000dd0:	00000f06 	br	1000e10 <pf_open+0x23c>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / 16) & (fs->csize-1)) == 0) {	/* Cluster changed? */
 1000dd4:	80800083 	ldbu	r2,2(r16)
 1000dd8:	1806d13a 	srli	r3,r3,4
 1000ddc:	10bfffc4 	addi	r2,r2,-1
 1000de0:	1886703a 	and	r3,r3,r2
 1000de4:	1800081e 	bne	r3,zero,1000e08 <pf_open+0x234>
				clst = get_fat(dj->clust);		/* Get next cluster */
 1000de8:	10009740 	call	1000974 <get_fat>
 1000dec:	1009883a 	mov	r4,r2
				if (clst <= 1) return FR_DISK_ERR;
 1000df0:	90800e2e 	bgeu	r18,r2,1000e2c <pf_open+0x258>
				if (clst >= fs->n_fatent)		/* When it reached end of dynamic table */
 1000df4:	80800217 	ldw	r2,8(r16)
 1000df8:	2080052e 	bgeu	r4,r2,1000e10 <pf_open+0x23c>
					return FR_NO_FILE;			/* Report EOT */
				dj->clust = clst;				/* Initialize data for new cluster */
 1000dfc:	d9000615 	stw	r4,24(sp)
				dj->sect = clust2sect(clst);
 1000e00:	100079c0 	call	100079c <clust2sect>
 1000e04:	d8800715 	stw	r2,28(sp)
			}
		}
	}

	dj->index = i;
 1000e08:	dcc0030d 	sth	r19,12(sp)
 1000e0c:	003fc206 	br	1000d18 <pf_open+0x144>
 1000e10:	00c000c4 	movi	r3,3
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj, dir);		/* Find it */
			if (res != FR_OK) {				/* Could not find the object */
				if (res == FR_NO_FILE && !*(dj->fn+11))
 1000e14:	008000c4 	movi	r2,3
 1000e18:	18803a1e 	bne	r3,r2,1000f04 <pf_open+0x330>
 1000e1c:	d8800417 	ldw	r2,16(sp)
 1000e20:	108002c3 	ldbu	r2,11(r2)
 1000e24:	10003626 	beq	r2,zero,1000f00 <pf_open+0x32c>
 1000e28:	00003306 	br	1000ef8 <pf_open+0x324>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / 16) & (fs->csize-1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->clust);		/* Get next cluster */
				if (clst <= 1) return FR_DISK_ERR;
 1000e2c:	9007883a 	mov	r3,r18
 1000e30:	003ff806 	br	1000e14 <pf_open+0x240>
				if (res == FR_NO_FILE && !*(dj->fn+11))
					res = FR_NO_PATH;
				break;
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
 1000e34:	3880040c 	andi	r2,r7,16
 1000e38:	10003126 	beq	r2,zero,1000f00 <pf_open+0x32c>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
 1000e3c:	d8800d43 	ldbu	r2,53(sp)
 1000e40:	d9400d03 	ldbu	r5,52(sp)
 1000e44:	d8c00ec3 	ldbu	r3,59(sp)
 1000e48:	1004923a 	slli	r2,r2,8
 1000e4c:	d9000e83 	ldbu	r4,58(sp)
 1000e50:	1806923a 	slli	r3,r3,8
 1000e54:	1144b03a 	or	r2,r2,r5
 1000e58:	1004943a 	slli	r2,r2,16
 1000e5c:	1906b03a 	or	r3,r3,r4
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */
 1000e60:	a9003fcc 	andi	r4,r21,255
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
 1000e64:	10c4b03a 	or	r2,r2,r3
		} else {						/* Single byte code */
			if (IsLower(c)) c -= 0x20;	/* toupper */
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Rerurn pointer to the next segment */
 1000e68:	8923883a 	add	r17,r17,r4
			}
			if (*(dj->fn+11)) break;		/* Last segment match. Function completed. */
			if (!(dir[DIR_Attr] & AM_DIR)) { /* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
 1000e6c:	d8800515 	stw	r2,20(sp)
 1000e70:	003f7706 	br	1000c50 <pf_open+0x7c>
	if (*path == '/') path++;			/* Strip heading separator */
	dj->sclust = 0;						/* Set start directory (always root dir) */

	if ((BYTE)*path <= ' ') {			/* Null path means the root directory */
		res = dir_rewind(dj);
		dir[0] = 0;
 1000e74:	d8000805 	stb	zero,32(sp)

	fs->flag = 0;
	dj.fn = sp;
	res = follow_path(&dj, dir, path);	/* Follow the file path */
	if (res != FR_OK) return res;		/* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
 1000e78:	d8800803 	ldbu	r2,32(sp)
 1000e7c:	10001e26 	beq	r2,zero,1000ef8 <pf_open+0x324>
 1000e80:	d8800ac3 	ldbu	r2,43(sp)
 1000e84:	1080040c 	andi	r2,r2,16
 1000e88:	10001b1e 	bne	r2,zero,1000ef8 <pf_open+0x324>
		return FR_NO_FILE;

	fs->org_clust = LD_CLUST(dir);			/* File start cluster */
 1000e8c:	d8800d43 	ldbu	r2,53(sp)
 1000e90:	d9400d03 	ldbu	r5,52(sp)
 1000e94:	d8c00ec3 	ldbu	r3,59(sp)
 1000e98:	1004923a 	slli	r2,r2,8
 1000e9c:	d9000e83 	ldbu	r4,58(sp)
 1000ea0:	1806923a 	slli	r3,r3,8
 1000ea4:	1144b03a 	or	r2,r2,r5
 1000ea8:	1004943a 	slli	r2,r2,16
 1000eac:	1906b03a 	or	r3,r3,r4
 1000eb0:	10c4b03a 	or	r2,r2,r3
 1000eb4:	a0800815 	stw	r2,32(r20)
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 1000eb8:	d8800fc3 	ldbu	r2,63(sp)
 1000ebc:	d8c00f83 	ldbu	r3,62(sp)
 1000ec0:	d9000f43 	ldbu	r4,61(sp)
 1000ec4:	1004963a 	slli	r2,r2,24
 1000ec8:	1806943a 	slli	r3,r3,16
 1000ecc:	d9400f03 	ldbu	r5,60(sp)
 1000ed0:	2008923a 	slli	r4,r4,8
 1000ed4:	10c4b03a 	or	r2,r2,r3
 1000ed8:	1144b03a 	or	r2,r2,r5
 1000edc:	2088b03a 	or	r4,r4,r2
	fs->fptr = 0;						/* File pointer */
	fs->flag = FA_OPENED;
 1000ee0:	0007883a 	mov	r3,zero
 1000ee4:	00800044 	movi	r2,1
 1000ee8:	a0800045 	stb	r2,1(r20)
	if (res != FR_OK) return res;		/* Follow failed */
	if (!dir[0] || (dir[DIR_Attr] & AM_DIR))	/* It is a directory */
		return FR_NO_FILE;

	fs->org_clust = LD_CLUST(dir);			/* File start cluster */
	fs->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
 1000eec:	a1000715 	stw	r4,28(r20)
	fs->fptr = 0;						/* File pointer */
 1000ef0:	a0000615 	stw	zero,24(r20)
 1000ef4:	00000306 	br	1000f04 <pf_open+0x330>
	fs->flag = FA_OPENED;

	return FR_OK;
 1000ef8:	00c000c4 	movi	r3,3
 1000efc:	00000106 	br	1000f04 <pf_open+0x330>
 1000f00:	00c00104 	movi	r3,4
}
 1000f04:	1805883a 	mov	r2,r3
 1000f08:	dfc01617 	ldw	ra,88(sp)
 1000f0c:	dd401517 	ldw	r21,84(sp)
 1000f10:	dd001417 	ldw	r20,80(sp)
 1000f14:	dcc01317 	ldw	r19,76(sp)
 1000f18:	dc801217 	ldw	r18,72(sp)
 1000f1c:	dc401117 	ldw	r17,68(sp)
 1000f20:	dc001017 	ldw	r16,64(sp)
 1000f24:	dec01704 	addi	sp,sp,92
 1000f28:	f800283a 	ret

01000f2c <pf_mount>:
/*-----------------------------------------------------------------------*/

FRESULT pf_mount (
	FATFS *fs		/* Pointer to new file system object (NULL: Unmount) */
)
{
 1000f2c:	defff304 	addi	sp,sp,-52
 1000f30:	dc000915 	stw	r16,36(sp)
 1000f34:	dfc00c15 	stw	ra,48(sp)
 1000f38:	dc800b15 	stw	r18,44(sp)
 1000f3c:	dc400a15 	stw	r17,40(sp)
 1000f40:	2021883a 	mov	r16,r4
	BYTE fmt, buf[36];
	DWORD bsect, fsize, tsect, mclst;


	FatFs = 0;
 1000f44:	d0200b15 	stw	zero,-32724(gp)
	if (!fs) return FR_OK;				/* Unregister fs object */
 1000f48:	2000021e 	bne	r4,zero,1000f54 <pf_mount+0x28>
 1000f4c:	0009883a 	mov	r4,zero
 1000f50:	00009a06 	br	10011bc <pf_mount+0x290>

	if (disk_initialize() & STA_NOINIT)	/* Check if the drive is ready or not */
 1000f54:	10005cc0 	call	10005cc <disk_initialize>
 1000f58:	1080004c 	andi	r2,r2,1
 1000f5c:	1005003a 	cmpeq	r2,r2,zero
 1000f60:	1000021e 	bne	r2,zero,1000f6c <pf_mount+0x40>
 1000f64:	01000084 	movi	r4,2
 1000f68:	00009406 	br	10011bc <pf_mount+0x290>
		return FR_NOT_READY;

	/* Search FAT partition on the drive */
	bsect = 0;
	fmt = check_fs(buf, bsect);			/* Check sector 0 as an SFD format */
 1000f6c:	d809883a 	mov	r4,sp
 1000f70:	000b883a 	mov	r5,zero
 1000f74:	10008740 	call	1000874 <check_fs>
 1000f78:	1009883a 	mov	r4,r2
	if (fmt == 1) {						/* Not an FAT boot record, it may be FDISK format */
 1000f7c:	10c03fcc 	andi	r3,r2,255
 1000f80:	00800044 	movi	r2,1
 1000f84:	18800226 	beq	r3,r2,1000f90 <pf_mount+0x64>
 1000f88:	0025883a 	mov	r18,zero
 1000f8c:	00001606 	br	1000fe8 <pf_mount+0xbc>
		/* Check a partition listed in top of the partition table */
		if (disk_readp(buf, bsect, MBR_Table, 16)) {	/* 1st partition entry */
 1000f90:	d809883a 	mov	r4,sp
 1000f94:	000b883a 	mov	r5,zero
 1000f98:	01806f84 	movi	r6,446
 1000f9c:	01c00404 	movi	r7,16
 1000fa0:	10004bc0 	call	10004bc <disk_readp>
 1000fa4:	1000731e 	bne	r2,zero,1001174 <pf_mount+0x248>
			fmt = 3;
		} else {
			if (buf[4]) {					/* Is the partition existing? */
 1000fa8:	d8800103 	ldbu	r2,4(sp)
 1000fac:	10007326 	beq	r2,zero,100117c <pf_mount+0x250>
				bsect = LD_DWORD(&buf[8]);	/* Partition offset in LBA */
 1000fb0:	d88002c3 	ldbu	r2,11(sp)
 1000fb4:	d8c00283 	ldbu	r3,10(sp)
 1000fb8:	d9000243 	ldbu	r4,9(sp)
 1000fbc:	1004963a 	slli	r2,r2,24
 1000fc0:	1806943a 	slli	r3,r3,16
 1000fc4:	d9400203 	ldbu	r5,8(sp)
 1000fc8:	2008923a 	slli	r4,r4,8
 1000fcc:	10c4b03a 	or	r2,r2,r3
 1000fd0:	1144b03a 	or	r2,r2,r5
 1000fd4:	20a4b03a 	or	r18,r4,r2
				fmt = check_fs(buf, bsect);	/* Check the partition */
 1000fd8:	900b883a 	mov	r5,r18
 1000fdc:	d809883a 	mov	r4,sp
 1000fe0:	10008740 	call	1000874 <check_fs>
 1000fe4:	1009883a 	mov	r4,r2
			}
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
 1000fe8:	20c03fcc 	andi	r3,r4,255
 1000fec:	008000c4 	movi	r2,3
 1000ff0:	18806026 	beq	r3,r2,1001174 <pf_mount+0x248>
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */
 1000ff4:	1800611e 	bne	r3,zero,100117c <pf_mount+0x250>

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;
 1000ff8:	d809883a 	mov	r4,sp
 1000ffc:	900b883a 	mov	r5,r18
 1001000:	01800344 	movi	r6,13
 1001004:	01c00904 	movi	r7,36
 1001008:	10004bc0 	call	10004bc <disk_readp>
 100100c:	1000591e 	bne	r2,zero,1001174 <pf_mount+0x248>

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
 1001010:	d8800283 	ldbu	r2,10(sp)
 1001014:	d8c00243 	ldbu	r3,9(sp)
 1001018:	1004923a 	slli	r2,r2,8
 100101c:	10c8b03a 	or	r4,r2,r3
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
 1001020:	20bfffcc 	andi	r2,r4,65535
 1001024:	10a0001c 	xori	r2,r2,32768
 1001028:	10a00004 	addi	r2,r2,-32768
 100102c:	10000226 	beq	r2,zero,1001038 <pf_mount+0x10c>
	if (fmt) return FR_NO_FILESYSTEM;	/* No valid FAT patition is found */

	/* Initialize the file system object */
	if (disk_readp(buf, bsect, 13, sizeof(buf))) return FR_DISK_ERR;

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
 1001030:	213fffcc 	andi	r4,r4,65535
 1001034:	00000a06 	br	1001060 <pf_mount+0x134>
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);
 1001038:	d8800683 	ldbu	r2,26(sp)
 100103c:	d8c00643 	ldbu	r3,25(sp)
 1001040:	d9000603 	ldbu	r4,24(sp)
 1001044:	1004963a 	slli	r2,r2,24
 1001048:	1806943a 	slli	r3,r3,16
 100104c:	d94005c3 	ldbu	r5,23(sp)
 1001050:	2008923a 	slli	r4,r4,8
 1001054:	10c4b03a 	or	r2,r2,r3
 1001058:	1144b03a 	or	r2,r2,r5
 100105c:	2088b03a 	or	r4,r4,r2

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
 1001060:	d94000c3 	ldbu	r5,3(sp)
 1001064:	10013240 	call	1001324 <__mulsi3>
 1001068:	1023883a 	mov	r17,r2
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
 100106c:	d90001c3 	ldbu	r4,7(sp)

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
 1001070:	d8800083 	ldbu	r2,2(sp)
 1001074:	d9800043 	ldbu	r6,1(sp)
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
 1001078:	d9c00183 	ldbu	r7,6(sp)
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
 100107c:	d8c00143 	ldbu	r3,5(sp)
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
 1001080:	2008923a 	slli	r4,r4,8

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
 1001084:	1004923a 	slli	r2,r2,8
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
 1001088:	d9400103 	ldbu	r5,4(sp)
 100108c:	1806923a 	slli	r3,r3,8

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
 1001090:	1184b03a 	or	r2,r2,r6
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
 1001094:	21ccb03a 	or	r6,r4,r7
	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
 1001098:	da000003 	ldbu	r8,0(sp)
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
 100109c:	313fffcc 	andi	r4,r6,65535
 10010a0:	2120001c 	xori	r4,r4,32768
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
 10010a4:	1946b03a 	or	r3,r3,r5

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
 10010a8:	9085883a 	add	r2,r18,r2
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
 10010ac:	21200004 	addi	r4,r4,-32768

	fsize = LD_WORD(buf+BPB_FATSz16-13);				/* Number of sectors per FAT */
	if (!fsize) fsize = LD_DWORD(buf+BPB_FATSz32-13);

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
 10010b0:	80800315 	stw	r2,12(r16)
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
 10010b4:	82000085 	stb	r8,2(r16)
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
 10010b8:	80c0010d 	sth	r3,4(r16)
 10010bc:	180f883a 	mov	r7,r3
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
 10010c0:	20000226 	beq	r4,zero,10010cc <pf_mount+0x1a0>

	fsize *= buf[BPB_NumFATs-13];						/* Number of sectors in FAT area */
	fs->fatbase = bsect + LD_WORD(buf+BPB_RsvdSecCnt-13); /* FAT start sector (lba) */
	fs->csize = buf[BPB_SecPerClus-13];					/* Number of sectors per cluster */
	fs->n_rootdir = LD_WORD(buf+BPB_RootEntCnt-13);		/* Nmuber of root directory entries */
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
 10010c4:	31bfffcc 	andi	r6,r6,65535
 10010c8:	00000a06 	br	10010f4 <pf_mount+0x1c8>
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
 10010cc:	d8800583 	ldbu	r2,22(sp)
 10010d0:	d8c00543 	ldbu	r3,21(sp)
 10010d4:	d9000503 	ldbu	r4,20(sp)
 10010d8:	1004963a 	slli	r2,r2,24
 10010dc:	1806943a 	slli	r3,r3,16
 10010e0:	d94004c3 	ldbu	r5,19(sp)
 10010e4:	2008923a 	slli	r4,r4,8
 10010e8:	10c4b03a 	or	r2,r2,r3
 10010ec:	1144b03a 	or	r2,r2,r5
 10010f0:	208cb03a 	or	r6,r4,r2
	mclst = (tsect						/* Last cluster# + 1 */
 10010f4:	d9000083 	ldbu	r4,2(sp)
 10010f8:	d8c00043 	ldbu	r3,1(sp)
 10010fc:	38bfffcc 	andi	r2,r7,65535
 1001100:	2008923a 	slli	r4,r4,8
 1001104:	1004d13a 	srli	r2,r2,4
 1001108:	81400083 	ldbu	r5,2(r16)
 100110c:	20c8b03a 	or	r4,r4,r3
 1001110:	3109c83a 	sub	r4,r6,r4
 1001114:	2449c83a 	sub	r4,r4,r17
 1001118:	2089c83a 	sub	r4,r4,r2
 100111c:	10013140 	call	1001314 <__udivsi3>
 1001120:	10c00084 	addi	r3,r2,2
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
		) / fs->csize + 2;
	fs->n_fatent = (CLUST)mclst;

	fmt = FS_FAT16;							/* Determine the FAT sub type */
	if (mclst < 0xFF7) 						/* Number of clusters < 0xFF5 */
 1001124:	0083fd84 	movi	r2,4086
	tsect = LD_WORD(buf+BPB_TotSec16-13);				/* Number of sectors on the file system */
	if (!tsect) tsect = LD_DWORD(buf+BPB_TotSec32-13);
	mclst = (tsect						/* Last cluster# + 1 */
		- LD_WORD(buf+BPB_RsvdSecCnt-13) - fsize - fs->n_rootdir / 16
		) / fs->csize + 2;
	fs->n_fatent = (CLUST)mclst;
 1001128:	80c00215 	stw	r3,8(r16)

	fmt = FS_FAT16;							/* Determine the FAT sub type */
	if (mclst < 0xFF7) 						/* Number of clusters < 0xFF5 */
 100112c:	10c0132e 	bgeu	r2,r3,100117c <pf_mount+0x250>
#if _FS_FAT12
		fmt = FS_FAT12;
#else
		return FR_NO_FILESYSTEM;
#endif
	if (mclst >= 0xFFF7)					/* Number of clusters >= 0xFFF5 */
 1001130:	00bffd94 	movui	r2,65526
 1001134:	10c01336 	bltu	r2,r3,1001184 <pf_mount+0x258>

	fs->fs_type = fmt;		/* FAT sub-type */
	if (_FS_FAT32 && fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
 1001138:	80800317 	ldw	r2,12(r16)
		fmt = FS_FAT32;
#else
		return FR_NO_FILESYSTEM;
#endif

	fs->fs_type = fmt;		/* FAT sub-type */
 100113c:	00c00084 	movi	r3,2
 1001140:	80c00005 	stb	r3,0(r16)
	if (_FS_FAT32 && fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
 1001144:	1445883a 	add	r2,r2,r17
 1001148:	80800415 	stw	r2,16(r16)
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
 100114c:	8080010b 	ldhu	r2,4(r16)
 1001150:	80c00317 	ldw	r3,12(r16)

	fs->flag = 0;
 1001154:	80000045 	stb	zero,1(r16)
	fs->fs_type = fmt;		/* FAT sub-type */
	if (_FS_FAT32 && fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
 1001158:	1004d13a 	srli	r2,r2,4

	fs->flag = 0;
	FatFs = fs;
 100115c:	0009883a 	mov	r4,zero
 1001160:	d4200b15 	stw	r16,-32724(gp)
	fs->fs_type = fmt;		/* FAT sub-type */
	if (_FS_FAT32 && fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
	else
		fs->dirbase = fs->fatbase + fsize;				/* Root directory start sector (lba) */
	fs->database = fs->fatbase + fsize + fs->n_rootdir / 16;	/* Data start sector (lba) */
 1001164:	10c5883a 	add	r2,r2,r3
 1001168:	8885883a 	add	r2,r17,r2
 100116c:	80800515 	stw	r2,20(r16)
 1001170:	00001206 	br	10011bc <pf_mount+0x290>

	fs->flag = 0;
	FatFs = fs;

	return FR_OK;
 1001174:	01000044 	movi	r4,1
 1001178:	00001006 	br	10011bc <pf_mount+0x290>
 100117c:	010001c4 	movi	r4,7
 1001180:	00000e06 	br	10011bc <pf_mount+0x290>
		return FR_NO_FILESYSTEM;
#endif

	fs->fs_type = fmt;		/* FAT sub-type */
	if (_FS_FAT32 && fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
 1001184:	d8800883 	ldbu	r2,34(sp)
 1001188:	d8c00843 	ldbu	r3,33(sp)
 100118c:	d9000803 	ldbu	r4,32(sp)
 1001190:	1004963a 	slli	r2,r2,24
 1001194:	1806943a 	slli	r3,r3,16
 1001198:	d94007c3 	ldbu	r5,31(sp)
 100119c:	2008923a 	slli	r4,r4,8
 10011a0:	10c4b03a 	or	r2,r2,r3
 10011a4:	1144b03a 	or	r2,r2,r5
 10011a8:	2088b03a 	or	r4,r4,r2
		fmt = FS_FAT32;
#else
		return FR_NO_FILESYSTEM;
#endif

	fs->fs_type = fmt;		/* FAT sub-type */
 10011ac:	008000c4 	movi	r2,3
 10011b0:	80800005 	stb	r2,0(r16)
	if (_FS_FAT32 && fmt == FS_FAT32)
		fs->dirbase = LD_DWORD(buf+(BPB_RootClus-13));	/* Root directory start cluster */
 10011b4:	81000415 	stw	r4,16(r16)
 10011b8:	003fe406 	br	100114c <pf_mount+0x220>

	fs->flag = 0;
	FatFs = fs;

	return FR_OK;
}
 10011bc:	2005883a 	mov	r2,r4
 10011c0:	dfc00c17 	ldw	ra,48(sp)
 10011c4:	dc800b17 	ldw	r18,44(sp)
 10011c8:	dc400a17 	ldw	r17,40(sp)
 10011cc:	dc000917 	ldw	r16,36(sp)
 10011d0:	dec00d04 	addi	sp,sp,52
 10011d4:	f800283a 	ret

010011d8 <udivmodsi4>:
 10011d8:	29001b2e 	bgeu	r5,r4,1001248 <udivmodsi4+0x70>
 10011dc:	28001a16 	blt	r5,zero,1001248 <udivmodsi4+0x70>
 10011e0:	00800044 	movi	r2,1
 10011e4:	0007883a 	mov	r3,zero
 10011e8:	01c007c4 	movi	r7,31
 10011ec:	00000306 	br	10011fc <udivmodsi4+0x24>
 10011f0:	19c01326 	beq	r3,r7,1001240 <udivmodsi4+0x68>
 10011f4:	18c00044 	addi	r3,r3,1
 10011f8:	28000416 	blt	r5,zero,100120c <udivmodsi4+0x34>
 10011fc:	294b883a 	add	r5,r5,r5
 1001200:	1085883a 	add	r2,r2,r2
 1001204:	293ffa36 	bltu	r5,r4,10011f0 <udivmodsi4+0x18>
 1001208:	10000d26 	beq	r2,zero,1001240 <udivmodsi4+0x68>
 100120c:	0007883a 	mov	r3,zero
 1001210:	21400236 	bltu	r4,r5,100121c <udivmodsi4+0x44>
 1001214:	2149c83a 	sub	r4,r4,r5
 1001218:	1886b03a 	or	r3,r3,r2
 100121c:	1004d07a 	srli	r2,r2,1
 1001220:	280ad07a 	srli	r5,r5,1
 1001224:	103ffa1e 	bne	r2,zero,1001210 <udivmodsi4+0x38>
 1001228:	30000226 	beq	r6,zero,1001234 <udivmodsi4+0x5c>
 100122c:	2005883a 	mov	r2,r4
 1001230:	f800283a 	ret
 1001234:	1809883a 	mov	r4,r3
 1001238:	2005883a 	mov	r2,r4
 100123c:	f800283a 	ret
 1001240:	0007883a 	mov	r3,zero
 1001244:	003ff806 	br	1001228 <udivmodsi4+0x50>
 1001248:	00800044 	movi	r2,1
 100124c:	0007883a 	mov	r3,zero
 1001250:	003fef06 	br	1001210 <udivmodsi4+0x38>

01001254 <__divsi3>:
 1001254:	defffe04 	addi	sp,sp,-8
 1001258:	dc000015 	stw	r16,0(sp)
 100125c:	dfc00115 	stw	ra,4(sp)
 1001260:	0021883a 	mov	r16,zero
 1001264:	20000c16 	blt	r4,zero,1001298 <__divsi3+0x44>
 1001268:	000d883a 	mov	r6,zero
 100126c:	28000e16 	blt	r5,zero,10012a8 <__divsi3+0x54>
 1001270:	10011d80 	call	10011d8 <udivmodsi4>
 1001274:	1007883a 	mov	r3,r2
 1001278:	8005003a 	cmpeq	r2,r16,zero
 100127c:	1000011e 	bne	r2,zero,1001284 <__divsi3+0x30>
 1001280:	00c7c83a 	sub	r3,zero,r3
 1001284:	1805883a 	mov	r2,r3
 1001288:	dfc00117 	ldw	ra,4(sp)
 100128c:	dc000017 	ldw	r16,0(sp)
 1001290:	dec00204 	addi	sp,sp,8
 1001294:	f800283a 	ret
 1001298:	0109c83a 	sub	r4,zero,r4
 100129c:	04000044 	movi	r16,1
 10012a0:	000d883a 	mov	r6,zero
 10012a4:	283ff20e 	bge	r5,zero,1001270 <__divsi3+0x1c>
 10012a8:	014bc83a 	sub	r5,zero,r5
 10012ac:	8021003a 	cmpeq	r16,r16,zero
 10012b0:	003fef06 	br	1001270 <__divsi3+0x1c>

010012b4 <__modsi3>:
 10012b4:	deffff04 	addi	sp,sp,-4
 10012b8:	dfc00015 	stw	ra,0(sp)
 10012bc:	01800044 	movi	r6,1
 10012c0:	2807883a 	mov	r3,r5
 10012c4:	20000416 	blt	r4,zero,10012d8 <__modsi3+0x24>
 10012c8:	28000c16 	blt	r5,zero,10012fc <__modsi3+0x48>
 10012cc:	dfc00017 	ldw	ra,0(sp)
 10012d0:	dec00104 	addi	sp,sp,4
 10012d4:	10011d81 	jmpi	10011d8 <udivmodsi4>
 10012d8:	0109c83a 	sub	r4,zero,r4
 10012dc:	28000b16 	blt	r5,zero,100130c <__modsi3+0x58>
 10012e0:	180b883a 	mov	r5,r3
 10012e4:	01800044 	movi	r6,1
 10012e8:	10011d80 	call	10011d8 <udivmodsi4>
 10012ec:	0085c83a 	sub	r2,zero,r2
 10012f0:	dfc00017 	ldw	ra,0(sp)
 10012f4:	dec00104 	addi	sp,sp,4
 10012f8:	f800283a 	ret
 10012fc:	014bc83a 	sub	r5,zero,r5
 1001300:	dfc00017 	ldw	ra,0(sp)
 1001304:	dec00104 	addi	sp,sp,4
 1001308:	10011d81 	jmpi	10011d8 <udivmodsi4>
 100130c:	0147c83a 	sub	r3,zero,r5
 1001310:	003ff306 	br	10012e0 <__modsi3+0x2c>

01001314 <__udivsi3>:
 1001314:	000d883a 	mov	r6,zero
 1001318:	10011d81 	jmpi	10011d8 <udivmodsi4>

0100131c <__umodsi3>:
 100131c:	01800044 	movi	r6,1
 1001320:	10011d81 	jmpi	10011d8 <udivmodsi4>

01001324 <__mulsi3>:
 1001324:	20000a26 	beq	r4,zero,1001350 <__mulsi3+0x2c>
 1001328:	0007883a 	mov	r3,zero
 100132c:	2080004c 	andi	r2,r4,1
 1001330:	1005003a 	cmpeq	r2,r2,zero
 1001334:	2008d07a 	srli	r4,r4,1
 1001338:	1000011e 	bne	r2,zero,1001340 <__mulsi3+0x1c>
 100133c:	1947883a 	add	r3,r3,r5
 1001340:	294b883a 	add	r5,r5,r5
 1001344:	203ff91e 	bne	r4,zero,100132c <__mulsi3+0x8>
 1001348:	1805883a 	mov	r2,r3
 100134c:	f800283a 	ret
 1001350:	0007883a 	mov	r3,zero
 1001354:	1805883a 	mov	r2,r3
 1001358:	f800283a 	ret

0100135c <alt_alarm_start>:
                     void* context)
{
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
  
  if (alt_ticks_per_second ())
 100135c:	00804034 	movhi	r2,256
 1001360:	10869104 	addi	r2,r2,6724
 1001364:	10800017 	ldw	r2,0(r2)
 1001368:	00ffde84 	movi	r3,-134
 100136c:	10001d26 	beq	r2,zero,10013e4 <alt_alarm_start+0x88>
  {
    if (alarm)
 1001370:	00fffa84 	movi	r3,-22
 1001374:	20001b26 	beq	r4,zero,10013e4 <alt_alarm_start+0x88>
    {
      alarm->callback = callback;
 1001378:	21800315 	stw	r6,12(r4)
      alarm->context  = context;
 100137c:	21c00515 	stw	r7,20(r4)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1001380:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1001384:	00bfff84 	movi	r2,-2
 1001388:	3084703a 	and	r2,r6,r2
 100138c:	1001703a 	wrctl	status,r2
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 1001390:	00804034 	movhi	r2,256
 1001394:	10869204 	addi	r2,r2,6728
 1001398:	10c00017 	ldw	r3,0(r2)
 
      irq_context = alt_irq_disable_all ();
      
      current_nticks = alt_nticks();
      
      alarm->time = nticks + current_nticks + 1; 
 100139c:	18800044 	addi	r2,r3,1
 10013a0:	2885883a 	add	r2,r5,r2
 10013a4:	20800215 	stw	r2,8(r4)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 10013a8:	10c0032e 	bgeu	r2,r3,10013b8 <alt_alarm_start+0x5c>
      {
        alarm->rollover = 1;
 10013ac:	00800044 	movi	r2,1
 10013b0:	20800405 	stb	r2,16(r4)
 10013b4:	00000106 	br	10013bc <alt_alarm_start+0x60>
      }
      else
      {
        alarm->rollover = 0;
 10013b8:	20000405 	stb	zero,16(r4)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 10013bc:	00804034 	movhi	r2,256
 10013c0:	10868404 	addi	r2,r2,6672
  entry->next     = list->next;
 10013c4:	10c00017 	ldw	r3,0(r2)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 10013c8:	20800115 	stw	r2,4(r4)
  entry->next     = list->next;
 10013cc:	20c00015 	stw	r3,0(r4)

  list->next->previous = entry;
 10013d0:	10c00017 	ldw	r3,0(r2)
  list->next           = entry;
 10013d4:	11000015 	stw	r4,0(r2)
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;

  list->next->previous = entry;
 10013d8:	19000115 	stw	r4,4(r3)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10013dc:	3001703a 	wrctl	status,r6
 10013e0:	0007883a 	mov	r3,zero
  }
  else
  {
    return -ENOTSUP;
  }
}
 10013e4:	1805883a 	mov	r2,r3
 10013e8:	f800283a 	ret

010013ec <alt_irq_register>:
                      alt_isr_func handler)
{
  int rc = -EINVAL;  
  alt_irq_context status;

  if (id < ALT_NIRQ)
 10013ec:	008007c4 	movi	r2,31
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
 10013f0:	200f883a 	mov	r7,r4
  int rc = -EINVAL;  
  alt_irq_context status;

  if (id < ALT_NIRQ)
 10013f4:	00fffa84 	movi	r3,-22
 10013f8:	11002236 	bltu	r2,r4,1001484 <alt_irq_register+0x98>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10013fc:	0015303a 	rdctl	r10,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1001400:	027fff84 	movi	r9,-2
 1001404:	5244703a 	and	r2,r10,r9
 1001408:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all ();

    alt_irq[id].handler = handler;
 100140c:	200490fa 	slli	r2,r4,3
 1001410:	00c04034 	movhi	r3,256
 1001414:	18c69f04 	addi	r3,r3,6780
 1001418:	02004034 	movhi	r8,256
 100141c:	42068d04 	addi	r8,r8,6708
 1001420:	10c5883a 	add	r2,r2,r3
    alt_irq[id].context = context;
 1001424:	11400115 	stw	r5,4(r2)
     * state.
     */

    status = alt_irq_disable_all ();

    alt_irq[id].handler = handler;
 1001428:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = context;

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 100142c:	30000826 	beq	r6,zero,1001450 <alt_irq_register+0x64>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1001430:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1001434:	2244703a 	and	r2,r4,r9
 1001438:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
 100143c:	00c00044 	movi	r3,1
 1001440:	19c6983a 	sll	r3,r3,r7
 1001444:	40800017 	ldw	r2,0(r8)
 1001448:	10c4b03a 	or	r2,r2,r3
 100144c:	00000706 	br	100146c <alt_irq_register+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1001450:	0009303a 	rdctl	r4,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1001454:	2244703a 	and	r2,r4,r9
 1001458:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
 100145c:	00ffff84 	movi	r3,-2
 1001460:	19c6183a 	rol	r3,r3,r7
 1001464:	40800017 	ldw	r2,0(r8)
 1001468:	10c4703a 	and	r2,r2,r3
 100146c:	40800015 	stw	r2,0(r8)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1001470:	40800017 	ldw	r2,0(r8)
 1001474:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1001478:	2001703a 	wrctl	status,r4
 100147c:	5001703a 	wrctl	status,r10
 1001480:	0007883a 	mov	r3,zero

    alt_irq_enable_all(status);
  }
  return rc; 
}
 1001484:	1805883a 	mov	r2,r3
 1001488:	f800283a 	ret

0100148c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 100148c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 1001490:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 1001494:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 1001498:	10015b80 	call	10015b8 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 100149c:	10015980 	call	1001598 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 10014a0:	d1200d17 	ldw	r4,-32716(gp)
 10014a4:	d1600e17 	ldw	r5,-32712(gp)
 10014a8:	d1a00f17 	ldw	r6,-32708(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
 10014ac:	dfc00017 	ldw	ra,0(sp)
 10014b0:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
 10014b4:	10000381 	jmpi	1000038 <main>

010014b8 <alt_alarm_stop>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10014b8:	000b303a 	rdctl	r5,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10014bc:	00bfff84 	movi	r2,-2
 10014c0:	2884703a 	and	r2,r5,r2
 10014c4:	1001703a 	wrctl	status,r2
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 10014c8:	20c00017 	ldw	r3,0(r4)
 10014cc:	20800117 	ldw	r2,4(r4)
 10014d0:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 10014d4:	20800117 	ldw	r2,4(r4)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 10014d8:	21000115 	stw	r4,4(r4)
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
  entry->previous->next = entry->next;
 10014dc:	10c00015 	stw	r3,0(r2)
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
  entry->next     = entry;
 10014e0:	21000015 	stw	r4,0(r4)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10014e4:	2801703a 	wrctl	status,r5
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
  alt_llist_remove (&alarm->llist);
  alt_irq_enable_all (irq_context);
}
 10014e8:	f800283a 	ret

010014ec <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 10014ec:	defffd04 	addi	sp,sp,-12

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 10014f0:	d0a01117 	ldw	r2,-32700(gp)
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 10014f4:	dc000015 	stw	r16,0(sp)
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 10014f8:	d4200317 	ldw	r16,-32756(gp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 10014fc:	10800044 	addi	r2,r2,1
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 1001500:	dfc00215 	stw	ra,8(sp)
 1001504:	dc400115 	stw	r17,4(sp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 1001508:	d0a01115 	stw	r2,-32700(gp)
 100150c:	00001b06 	br	100157c <alt_tick+0x90>
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 1001510:	80800403 	ldbu	r2,16(r16)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
  {
    next = (alt_alarm*) alarm->llist.next;
 1001514:	84400017 	ldw	r17,0(r16)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 1001518:	10000326 	beq	r2,zero,1001528 <alt_tick+0x3c>
 100151c:	d0a01117 	ldw	r2,-32700(gp)
 1001520:	1000011e 	bne	r2,zero,1001528 <alt_tick+0x3c>
    {
      alarm->rollover = 0;
 1001524:	80000405 	stb	zero,16(r16)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 1001528:	d0e01117 	ldw	r3,-32700(gp)
 100152c:	80800217 	ldw	r2,8(r16)
 1001530:	18801136 	bltu	r3,r2,1001578 <alt_tick+0x8c>
 1001534:	80800403 	ldbu	r2,16(r16)
 1001538:	10000f1e 	bne	r2,zero,1001578 <alt_tick+0x8c>
    {
      next_callback = alarm->callback (alarm->context);
 100153c:	81000517 	ldw	r4,20(r16)
 1001540:	80800317 	ldw	r2,12(r16)
 1001544:	103ee83a 	callr	r2
 1001548:	1009883a 	mov	r4,r2

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 100154c:	1000031e 	bne	r2,zero,100155c <alt_tick+0x70>
      {
        alt_alarm_stop (alarm);
 1001550:	8009883a 	mov	r4,r16
 1001554:	10014b80 	call	10014b8 <alt_alarm_stop>
 1001558:	00000706 	br	1001578 <alt_tick+0x8c>
      }
      else
      {
        alarm->time += next_callback;
 100155c:	80800217 	ldw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 1001560:	d0e01117 	ldw	r3,-32700(gp)
      {
        alt_alarm_stop (alarm);
      }
      else
      {
        alarm->time += next_callback;
 1001564:	1105883a 	add	r2,r2,r4
 1001568:	80800215 	stw	r2,8(r16)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 100156c:	10c0022e 	bgeu	r2,r3,1001578 <alt_tick+0x8c>
        {
          alarm->rollover = 1;
 1001570:	00800044 	movi	r2,1
 1001574:	80800405 	stb	r2,16(r16)
 1001578:	8821883a 	mov	r16,r17

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 100157c:	d0a00304 	addi	r2,gp,-32756
 1001580:	80bfe31e 	bne	r16,r2,1001510 <alt_tick+0x24>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 1001584:	dfc00217 	ldw	ra,8(sp)
 1001588:	dc400117 	ldw	r17,4(sp)
 100158c:	dc000017 	ldw	r16,0(sp)
 1001590:	dec00304 	addi	sp,sp,12
 1001594:	f800283a 	ret

01001598 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 1001598:	deffff04 	addi	sp,sp,-4
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_CFI_FLASH_INIT ( ROM_0, rom_0);
    ALTERA_AVALON_FIFO_INIT ( FIFO_0, fifo_0);
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
    M2VDD_HX8347A_INIT ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);
 100159c:	d1200504 	addi	r4,gp,-32748
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 10015a0:	dfc00015 	stw	ra,0(sp)
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_CFI_FLASH_INIT ( ROM_0, rom_0);
    ALTERA_AVALON_FIFO_INIT ( FIFO_0, fifo_0);
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
    M2VDD_HX8347A_INIT ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);
 10015a4:	10018980 	call	1001898 <m2vdd_hx8347a_init>
    M2VDEC_INIT ( M2VDEC_0, m2vdec_0);
 10015a8:	d1200604 	addi	r4,gp,-32744
}
 10015ac:	dfc00017 	ldw	ra,0(sp)
 10015b0:	dec00104 	addi	sp,sp,4
    ALTERA_AVALON_CFI_FLASH_INIT ( ROM_0, rom_0);
    ALTERA_AVALON_FIFO_INIT ( FIFO_0, fifo_0);
    ALTERA_AVALON_SPI_INIT ( SPI_0, spi_0);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
    M2VDD_HX8347A_INIT ( M2VDD_HX8347A_0, m2vdd_hx8347a_0);
    M2VDEC_INIT ( M2VDEC_0, m2vdec_0);
 10015b4:	10019481 	jmpi	1001948 <m2vdec_init>

010015b8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 10015b8:	deffff04 	addi	sp,sp,-4
 10015bc:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2_QSYS_0, nios2_qsys_0);
 10015c0:	100194c0 	call	100194c <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 10015c4:	00800044 	movi	r2,1
 10015c8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 10015cc:	dfc00017 	ldw	ra,0(sp)
 10015d0:	dec00104 	addi	sp,sp,4
 10015d4:	f800283a 	ret

010015d8 <altera_avalon_fifo_read_backpressure>:
}

int altera_avalon_fifo_read_backpressure (alt_u32 read_address){
    // Read data from FIFO directly. If FIFO is empty and backpressure is supported, this call is backpressure.
    return IORD_ALTERA_AVALON_FIFO_DATA(read_address);  
}
 10015d8:	20800037 	ldwio	r2,0(r4)
 10015dc:	f800283a 	ret

010015e0 <altera_avalon_fifo_read_other_info>:
}

int altera_avalon_fifo_read_other_info(alt_u32 read_address)
{
    return IORD_ALTERA_AVALON_FIFO_OTHER_INFO(read_address);
}
 10015e0:	20800137 	ldwio	r2,4(r4)
 10015e4:	f800283a 	ret

010015e8 <altera_avalon_fifo_read_level>:
}

int altera_avalon_fifo_read_level(alt_u32 address)
{
    return IORD_ALTERA_AVALON_FIFO_LEVEL(address);
}
 10015e8:	20800037 	ldwio	r2,0(r4)
 10015ec:	f800283a 	ret

010015f0 <altera_avalon_fifo_read_event>:
    return IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address);
}

int altera_avalon_fifo_read_event(alt_u32 address, alt_u32 mask)
{
    return (IORD_ALTERA_AVALON_FIFO_EVENT(address) & mask);
 10015f0:	20800237 	ldwio	r2,8(r4)
}
 10015f4:	1144703a 	and	r2,r2,r5
 10015f8:	f800283a 	ret

010015fc <altera_avalon_fifo_read_almostempty>:
}

int altera_avalon_fifo_read_almostempty(alt_u32 address)
{
    return IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address);
}
 10015fc:	20800537 	ldwio	r2,20(r4)
 1001600:	f800283a 	ret

01001604 <altera_avalon_fifo_read_almostfull>:
}

int altera_avalon_fifo_read_almostfull(alt_u32 address)
{
    return IORD_ALTERA_AVALON_FIFO_ALMOSTFULL(address);
}
 1001604:	20800437 	ldwio	r2,16(r4)
 1001608:	f800283a 	ret

0100160c <altera_avalon_fifo_read_ienable>:
}

int altera_avalon_fifo_read_ienable(alt_u32 address, alt_u32 mask)
{
	
    return (IORD_ALTERA_AVALON_FIFO_IENABLE(address) & mask);
 100160c:	20800337 	ldwio	r2,12(r4)
}
 1001610:	1144703a 	and	r2,r2,r5
 1001614:	f800283a 	ret

01001618 <altera_avalon_fifo_read_status>:
    return ALTERA_AVALON_FIFO_OK;
}

int altera_avalon_fifo_read_status(alt_u32 address, alt_u32 mask)
{
    return (IORD_ALTERA_AVALON_FIFO_STATUS(address) & mask);
 1001618:	20800137 	ldwio	r2,4(r4)
}
 100161c:	1144703a 	and	r2,r2,r5
 1001620:	f800283a 	ret

01001624 <altera_avalon_fifo_read_fifo>:
    }
    return return_val;
}

int altera_avalon_fifo_read_fifo(alt_u32 read_address, alt_u32 ctrl_address)
{
 1001624:	defffe04 	addi	sp,sp,-8
 1001628:	dc000015 	stw	r16,0(sp)
 100162c:	2021883a 	mov	r16,r4
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 1001630:	2809883a 	mov	r4,r5
 1001634:	01400084 	movi	r5,2
    }
    return return_val;
}

int altera_avalon_fifo_read_fifo(alt_u32 read_address, alt_u32 ctrl_address)
{
 1001638:	dfc00115 	stw	ra,4(sp)
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 100163c:	10016180 	call	1001618 <altera_avalon_fifo_read_status>
 1001640:	0007883a 	mov	r3,zero
 1001644:	1000011e 	bne	r2,zero,100164c <altera_avalon_fifo_read_fifo+0x28>
    {
        return IORD_ALTERA_AVALON_FIFO_DATA(read_address);
 1001648:	80c00037 	ldwio	r3,0(r16)
    }
    return 0;
}
 100164c:	1805883a 	mov	r2,r3
 1001650:	dfc00117 	ldw	ra,4(sp)
 1001654:	dc000017 	ldw	r16,0(sp)
 1001658:	dec00204 	addi	sp,sp,8
 100165c:	f800283a 	ret

01001660 <altera_avalon_read_fifo>:
        return ALTERA_AVALON_FIFO_FULL;
    }
}

int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
 1001660:	defffc04 	addi	sp,sp,-16
 1001664:	dc800215 	stw	r18,8(sp)
 1001668:	dc000015 	stw	r16,0(sp)
 100166c:	2025883a 	mov	r18,r4
 1001670:	2821883a 	mov	r16,r5
    int return_val = 0;
    *data = 0;
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 1001674:	2809883a 	mov	r4,r5
}

int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
    int return_val = 0;
    *data = 0;
 1001678:	30000015 	stw	zero,0(r6)
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 100167c:	01400084 	movi	r5,2
        return ALTERA_AVALON_FIFO_FULL;
    }
}

int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
 1001680:	dc400115 	stw	r17,4(sp)
 1001684:	dfc00315 	stw	ra,12(sp)
 1001688:	3023883a 	mov	r17,r6
    int return_val = 0;
    *data = 0;
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 100168c:	10016180 	call	1001618 <altera_avalon_fifo_read_status>
 1001690:	0007883a 	mov	r3,zero
    {
        return_val = altera_avalon_fifo_read_level(ctrl_address);
 1001694:	8009883a 	mov	r4,r16
int altera_avalon_read_fifo(alt_u32 read_address, alt_u32 ctrl_address, int *data)
{
    int return_val = 0;
    *data = 0;
    
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_E_MSK))
 1001698:	1000041e 	bne	r2,zero,10016ac <altera_avalon_read_fifo+0x4c>
    {
        return_val = altera_avalon_fifo_read_level(ctrl_address);
 100169c:	10015e80 	call	10015e8 <altera_avalon_fifo_read_level>
 10016a0:	1007883a 	mov	r3,r2
        *data = IORD_ALTERA_AVALON_FIFO_DATA(read_address);
 10016a4:	90800037 	ldwio	r2,0(r18)
 10016a8:	88800015 	stw	r2,0(r17)
    
    }
    return return_val;
}
 10016ac:	1805883a 	mov	r2,r3
 10016b0:	dfc00317 	ldw	ra,12(sp)
 10016b4:	dc800217 	ldw	r18,8(sp)
 10016b8:	dc400117 	ldw	r17,4(sp)
 10016bc:	dc000017 	ldw	r16,0(sp)
 10016c0:	dec00404 	addi	sp,sp,16
 10016c4:	f800283a 	ret

010016c8 <altera_avalon_fifo_write_other_info>:
}

int altera_avalon_fifo_write_other_info(alt_u32 write_address,
					alt_u32 ctrl_address,
					alt_u32 data)
{
 10016c8:	defffd04 	addi	sp,sp,-12
 10016cc:	dc400115 	stw	r17,4(sp)
 10016d0:	2023883a 	mov	r17,r4
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 10016d4:	2809883a 	mov	r4,r5
 10016d8:	01400044 	movi	r5,1
}

int altera_avalon_fifo_write_other_info(alt_u32 write_address,
					alt_u32 ctrl_address,
					alt_u32 data)
{
 10016dc:	dc000015 	stw	r16,0(sp)
 10016e0:	dfc00215 	stw	ra,8(sp)
 10016e4:	3021883a 	mov	r16,r6
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 10016e8:	10016180 	call	1001618 <altera_avalon_fifo_read_status>
 10016ec:	00ffff04 	movi	r3,-4
 10016f0:	1000021e 	bne	r2,zero,10016fc <altera_avalon_fifo_write_other_info+0x34>
    {
	IOWR_ALTERA_AVALON_FIFO_OTHER_INFO(write_address, data);
 10016f4:	8c000135 	stwio	r16,4(r17)
 10016f8:	0007883a 	mov	r3,zero
    }
    else
    {
	return ALTERA_AVALON_FIFO_FULL;
    }
}
 10016fc:	1805883a 	mov	r2,r3
 1001700:	dfc00217 	ldw	ra,8(sp)
 1001704:	dc400117 	ldw	r17,4(sp)
 1001708:	dc000017 	ldw	r16,0(sp)
 100170c:	dec00304 	addi	sp,sp,12
 1001710:	f800283a 	ret

01001714 <altera_avalon_fifo_write_fifo>:
}

int altera_avalon_fifo_write_fifo(alt_u32 write_address,
                                  alt_u32 ctrl_address,
                                  alt_u32 data)
{
 1001714:	defffd04 	addi	sp,sp,-12
 1001718:	dc400115 	stw	r17,4(sp)
 100171c:	2023883a 	mov	r17,r4
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 1001720:	2809883a 	mov	r4,r5
 1001724:	01400044 	movi	r5,1
}

int altera_avalon_fifo_write_fifo(alt_u32 write_address,
                                  alt_u32 ctrl_address,
                                  alt_u32 data)
{
 1001728:	dc000015 	stw	r16,0(sp)
 100172c:	dfc00215 	stw	ra,8(sp)
 1001730:	3021883a 	mov	r16,r6
    if(!altera_avalon_fifo_read_status(ctrl_address, ALTERA_AVALON_FIFO_STATUS_F_MSK))
 1001734:	10016180 	call	1001618 <altera_avalon_fifo_read_status>
 1001738:	00ffff04 	movi	r3,-4
 100173c:	1000021e 	bne	r2,zero,1001748 <altera_avalon_fifo_write_fifo+0x34>
    {
        IOWR_ALTERA_AVALON_FIFO_DATA(write_address, data);
 1001740:	8c000035 	stwio	r16,0(r17)
 1001744:	0007883a 	mov	r3,zero
    }
    else
    {
        return ALTERA_AVALON_FIFO_FULL;
    }
}
 1001748:	1805883a 	mov	r2,r3
 100174c:	dfc00217 	ldw	ra,8(sp)
 1001750:	dc400117 	ldw	r17,4(sp)
 1001754:	dc000017 	ldw	r16,0(sp)
 1001758:	dec00304 	addi	sp,sp,12
 100175c:	f800283a 	ret

01001760 <altera_avalon_fifo_write_almostempty>:
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
}

int altera_avalon_fifo_write_almostempty(alt_u32 address, alt_u32 data)
{
    IOWR_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address, data);
 1001760:	20800504 	addi	r2,r4,20
 1001764:	21400535 	stwio	r5,20(r4)
    if(IORD_ALTERA_AVALON_FIFO_ALMOSTEMPTY(address) == data)
 1001768:	10800037 	ldwio	r2,0(r2)
 100176c:	0007883a 	mov	r3,zero
 1001770:	11400126 	beq	r2,r5,1001778 <altera_avalon_fifo_write_almostempty+0x18>
 1001774:	00ffff44 	movi	r3,-3
        return ALTERA_AVALON_FIFO_OK;
    else
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
}
 1001778:	1805883a 	mov	r2,r3
 100177c:	f800283a 	ret

01001780 <altera_avalon_fifo_write_almostfull>:
        return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
}

int altera_avalon_fifo_write_almostfull(alt_u32 address, alt_u32 data)
{
    IOWR_ALTERA_AVALON_FIFO_ALMOSTFULL(address, data);
 1001780:	20800404 	addi	r2,r4,16
 1001784:	21400435 	stwio	r5,16(r4)
    if(IORD_ALTERA_AVALON_FIFO_ALMOSTFULL(address) == data)
 1001788:	10800037 	ldwio	r2,0(r2)
 100178c:	0007883a 	mov	r3,zero
 1001790:	11400126 	beq	r2,r5,1001798 <altera_avalon_fifo_write_almostfull+0x18>
 1001794:	00ffff44 	movi	r3,-3
        return ALTERA_AVALON_FIFO_OK;
    else
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
}
 1001798:	1805883a 	mov	r2,r3
 100179c:	f800283a 	ret

010017a0 <altera_avalon_fifo_write_ienable>:
    return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
}

int altera_avalon_fifo_write_ienable(alt_u32 address, alt_u32 mask)
{
    IOWR_ALTERA_AVALON_FIFO_IENABLE(address, mask);
 10017a0:	20800304 	addi	r2,r4,12
 10017a4:	21400335 	stwio	r5,12(r4)
    if(IORD_ALTERA_AVALON_FIFO_IENABLE(address) == mask)
 10017a8:	10800037 	ldwio	r2,0(r2)
 10017ac:	0007883a 	mov	r3,zero
 10017b0:	11400126 	beq	r2,r5,10017b8 <altera_avalon_fifo_write_ienable+0x18>
 10017b4:	00ffff84 	movi	r3,-2
        return ALTERA_AVALON_FIFO_OK;
    else
        return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
}
 10017b8:	1805883a 	mov	r2,r3
 10017bc:	f800283a 	ret

010017c0 <altera_avalon_fifo_clear_event>:
    return IORD_ALTERA_AVALON_FIFO_LEVEL(address);
}

int altera_avalon_fifo_clear_event(alt_u32 address, alt_u32 mask)
{
    IOWR_ALTERA_AVALON_FIFO_EVENT(address, mask);
 10017c0:	20800204 	addi	r2,r4,8
 10017c4:	21400235 	stwio	r5,8(r4)
    if((IORD_ALTERA_AVALON_FIFO_EVENT(address) & mask) == 0)
 10017c8:	10800037 	ldwio	r2,0(r2)
 10017cc:	1144703a 	and	r2,r2,r5
 10017d0:	1004c03a 	cmpne	r2,r2,zero
        return ALTERA_AVALON_FIFO_OK;
    else
    return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
}
 10017d4:	0085c83a 	sub	r2,zero,r2
 10017d8:	f800283a 	ret

010017dc <altera_avalon_fifo_init>:



int altera_avalon_fifo_init(alt_u32 address, alt_u32 ienable,
                            alt_u32 emptymark, alt_u32 fullmark)
{
 10017dc:	defffb04 	addi	sp,sp,-20
 10017e0:	dc000015 	stw	r16,0(sp)
 10017e4:	2821883a 	mov	r16,r5
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
 10017e8:	01400fc4 	movi	r5,63



int altera_avalon_fifo_init(alt_u32 address, alt_u32 ienable,
                            alt_u32 emptymark, alt_u32 fullmark)
{
 10017ec:	dcc00315 	stw	r19,12(sp)
 10017f0:	dc800215 	stw	r18,8(sp)
 10017f4:	dc400115 	stw	r17,4(sp)
 10017f8:	dfc00415 	stw	ra,16(sp)
 10017fc:	2023883a 	mov	r17,r4
 1001800:	3027883a 	mov	r19,r6
 1001804:	3825883a 	mov	r18,r7
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
 1001808:	10017c00 	call	10017c0 <altera_avalon_fifo_clear_event>
 100180c:	00ffffc4 	movi	r3,-1
    {
        return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
    }

    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
 1001810:	800b883a 	mov	r5,r16
 1001814:	8809883a 	mov	r4,r17


int altera_avalon_fifo_init(alt_u32 address, alt_u32 ienable,
                            alt_u32 emptymark, alt_u32 fullmark)
{
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
 1001818:	10000d1e 	bne	r2,zero,1001850 <altera_avalon_fifo_init+0x74>
    {
        return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
    }

    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
 100181c:	10017a00 	call	10017a0 <altera_avalon_fifo_write_ienable>
 1001820:	00ffff84 	movi	r3,-2
    {
         return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
    }

    if( altera_avalon_fifo_write_almostfull(address, fullmark) != ALTERA_AVALON_FIFO_OK)
 1001824:	900b883a 	mov	r5,r18
 1001828:	8809883a 	mov	r4,r17
    if(altera_avalon_fifo_clear_event(address, ALTERA_AVALON_FIFO_EVENT_ALL) != ALTERA_AVALON_FIFO_OK)
    {
        return ALTERA_AVALON_FIFO_EVENT_CLEAR_ERROR;
    }

    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
 100182c:	1000081e 	bne	r2,zero,1001850 <altera_avalon_fifo_init+0x74>
    {
         return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
    }

    if( altera_avalon_fifo_write_almostfull(address, fullmark) != ALTERA_AVALON_FIFO_OK)
 1001830:	10017800 	call	1001780 <altera_avalon_fifo_write_almostfull>
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
    }
  
    if( altera_avalon_fifo_write_almostempty(address, emptymark) != ALTERA_AVALON_FIFO_OK)
 1001834:	8809883a 	mov	r4,r17
 1001838:	980b883a 	mov	r5,r19
    if( altera_avalon_fifo_write_ienable(address, ienable) != ALTERA_AVALON_FIFO_OK)
    {
         return ALTERA_AVALON_FIFO_IENABLE_WRITE_ERROR;
    }

    if( altera_avalon_fifo_write_almostfull(address, fullmark) != ALTERA_AVALON_FIFO_OK)
 100183c:	1000031e 	bne	r2,zero,100184c <altera_avalon_fifo_init+0x70>
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
    }
  
    if( altera_avalon_fifo_write_almostempty(address, emptymark) != ALTERA_AVALON_FIFO_OK)
 1001840:	10017600 	call	1001760 <altera_avalon_fifo_write_almostempty>
 1001844:	0007883a 	mov	r3,zero
 1001848:	10000126 	beq	r2,zero,1001850 <altera_avalon_fifo_init+0x74>
 100184c:	00ffff44 	movi	r3,-3
    {
        return ALTERA_AVALON_FIFO_THRESHOLD_WRITE_ERROR;
    }

    return ALTERA_AVALON_FIFO_OK;
}
 1001850:	1805883a 	mov	r2,r3
 1001854:	dfc00417 	ldw	ra,16(sp)
 1001858:	dcc00317 	ldw	r19,12(sp)
 100185c:	dc800217 	ldw	r18,8(sp)
 1001860:	dc400117 	ldw	r17,4(sp)
 1001864:	dc000017 	ldw	r16,0(sp)
 1001868:	dec00504 	addi	sp,sp,20
 100186c:	f800283a 	ret

01001870 <m2vdd_hx8347a_write_reg>:
	}
}

void m2vdd_hx8347a_write_reg(alt_u32 base, alt_u8 index, alt_u16 value)
{
	while(IORD_M2VDD_HX8347A_CONTROL(base) & 2);
 1001870:	20800037 	ldwio	r2,0(r4)
 1001874:	1080008c 	andi	r2,r2,2
 1001878:	103ffd1e 	bne	r2,zero,1001870 <m2vdd_hx8347a_write_reg>
	IOWR_M2VDD_HX8347A_CONTROL(base, index |
 100187c:	28803fcc 	andi	r2,r5,255
 1001880:	109000b4 	orhi	r2,r2,16386
 1001884:	20800035 	stwio	r2,0(r4)
		M2VDD_HX8347A_CONTROL_WRITE_MSK |
		M2VDD_HX8347A_CONTROL_RESET_MSK);
	IOWR_M2VDD_HX8347A_CONTROL(base, value |
 1001888:	30bfffcc 	andi	r2,r6,65535
 100188c:	109000f4 	orhi	r2,r2,16387
 1001890:	20800035 	stwio	r2,0(r4)
		M2VDD_HX8347A_CONTROL_WRITE_MSK |
		M2VDD_HX8347A_CONTROL_RESET_MSK |
		M2VDD_HX8347A_CONTROL_RS_MSK);
}
 1001894:	f800283a 	ret

01001898 <m2vdd_hx8347a_init>:
//--------------------------------------------------------------------------------
// Initialize LCD
//
void m2vdd_hx8347a_init(m2vdd_hx8347a_state* sp)
{
	void* base = sp->base;
 1001898:	21000017 	ldw	r4,0(r4)

	// Soft reset
	IOWR_M2VDD_HX8347A_CONTROL(base, M2VDD_HX8347A_CONTROL_SRESET_MSK);
 100189c:	00820034 	movhi	r2,2048
 10018a0:	20800035 	stwio	r2,0(r4)
 10018a4:	00804034 	movhi	r2,256
 10018a8:	10869204 	addi	r2,r2,6728
 10018ac:	10c00017 	ldw	r3,0(r2)
 10018b0:	100b883a 	mov	r5,r2
#include "m2vdd_hx8347a_regs.h"
#include "sys/alt_alarm.h"

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 10018b4:	18c00084 	addi	r3,r3,2
 10018b8:	28800017 	ldw	r2,0(r5)
	while(alt_nticks() < end);
 10018bc:	10fffe36 	bltu	r2,r3,10018b8 <m2vdd_hx8347a_init+0x20>
	void* base = sp->base;

	// Soft reset
	IOWR_M2VDD_HX8347A_CONTROL(base, M2VDD_HX8347A_CONTROL_SRESET_MSK);
	delay(1);
	IOWR_M2VDD_HX8347A_CONTROL(base, 0);
 10018c0:	20000035 	stwio	zero,0(r4)
 10018c4:	28800017 	ldw	r2,0(r5)
 10018c8:	01404034 	movhi	r5,256
 10018cc:	29469204 	addi	r5,r5,6728
#include "m2vdd_hx8347a_regs.h"
#include "sys/alt_alarm.h"

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 10018d0:	10c00084 	addi	r3,r2,2
 10018d4:	28800017 	ldw	r2,0(r5)
	while(alt_nticks() < end);
 10018d8:	10fffe36 	bltu	r2,r3,10018d4 <m2vdd_hx8347a_init+0x3c>
	delay(1);
	IOWR_M2VDD_HX8347A_CONTROL(base, 0);
	delay(1);

	// Assert LCD's reset
	IOWR_M2VDD_HX8347A_CONTROL(base, M2VDD_HX8347A_CONTROL_WRITE_MSK);
 10018dc:	00900034 	movhi	r2,16384
 10018e0:	20800035 	stwio	r2,0(r4)
 10018e4:	01404034 	movhi	r5,256
 10018e8:	29465804 	addi	r5,r5,6496
 10018ec:	02003fc4 	movi	r8,255
 10018f0:	01c04034 	movhi	r7,256
 10018f4:	39c69204 	addi	r7,r7,6728
	};

	const unsigned char* p = codes;
	for(;; p += 2)
	{
		if(p[0] == 0xff)
 10018f8:	28800003 	ldbu	r2,0(r5)
 10018fc:	12000a1e 	bne	r2,r8,1001928 <m2vdd_hx8347a_init+0x90>
		{
			if(p[1] == 0) break;
 1001900:	28c00043 	ldbu	r3,1(r5)
 1001904:	18000f26 	beq	r3,zero,1001944 <m2vdd_hx8347a_init+0xac>
 1001908:	38800017 	ldw	r2,0(r7)
 100190c:	01804034 	movhi	r6,256
 1001910:	31869204 	addi	r6,r6,6728
#include "m2vdd_hx8347a_regs.h"
#include "sys/alt_alarm.h"

static void delay(int ms)
{
	int end = alt_nticks() + ms + 1;
 1001914:	10800044 	addi	r2,r2,1
 1001918:	1887883a 	add	r3,r3,r2
 100191c:	30800017 	ldw	r2,0(r6)
	while(alt_nticks() < end);
 1001920:	10c0062e 	bgeu	r2,r3,100193c <m2vdd_hx8347a_init+0xa4>
 1001924:	003ffd06 	br	100191c <m2vdd_hx8347a_init+0x84>
			if(p[1] == 0) break;
			delay(p[1]);
		}
		else
		{
			IOWR_M2VDD_HX8347A_CONTROL(base, p[0] |
 1001928:	109000b4 	orhi	r2,r2,16386
 100192c:	20800035 	stwio	r2,0(r4)
				M2VDD_HX8347A_CONTROL_WRITE_MSK |
				M2VDD_HX8347A_CONTROL_RESET_MSK);
			IOWR_M2VDD_HX8347A_CONTROL(base, p[1] |
 1001930:	28800043 	ldbu	r2,1(r5)
 1001934:	109000f4 	orhi	r2,r2,16387
 1001938:	20800035 	stwio	r2,0(r4)

	0xff,   0, // END
	};

	const unsigned char* p = codes;
	for(;; p += 2)
 100193c:	29400084 	addi	r5,r5,2
 1001940:	003fed06 	br	10018f8 <m2vdd_hx8347a_init+0x60>
 1001944:	f800283a 	ret

01001948 <m2vdec_init>:
//--------------------------------------------------------------------------------
// Initialize MPEG2 Video Decoder
//
void m2vdec_init(m2vdec_state* sp)
{
}
 1001948:	f800283a 	ret

0100194c <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
 100194c:	000170fa 	wrctl	ienable,zero
}
 1001950:	f800283a 	ret
